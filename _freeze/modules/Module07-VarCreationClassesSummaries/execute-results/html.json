{
  "hash": "5ecd3b27a4a72d2ba1db1285b9852998",
  "result": {
    "markdown": "---\ntitle: \"Module 7: Variable Creation, Classes, and Summaries\"\nformat: \n  revealjs:\n    scrollable: true\n    smaller: true\n---\n\n\n## Learning Objectives\n\nAfter module 7, you should be able to...\n\n-   Create new variables\n-   Characterize variable classes\n-   Manipulate the classes of variables\n-   Conduct 1 variable data summaries\n\n## Import data for this module\nLet's first read in the data from the previous module and look at it briefly with a new function `head()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- read.csv(file = \"data/serodata.csv\") #relative path\nhead(x=df, n=3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  observation_id IgG_concentration age gender     slum\n1           5772         0.3176895   2 Female Non slum\n2           8095         3.4368231   4 Female Non slum\n3           9784         0.3000000   4   Male Non slum\n```\n:::\n:::\n\n\n```\nRegistered S3 method overwritten by 'printr':\n  method                from     \n  knit_print.data.frame rmarkdown\n```\n\nReturn the First or Last Parts of an Object\n\nDescription:\n\n     Returns the first or last parts of a vector, matrix, table, data\n     frame or function.  Since 'head()' and 'tail()' are generic\n     functions, they may also have been extended to other classes.\n\nUsage:\n\n     head(x, ...)\n     ## Default S3 method:\n     head(x, n = 6L, ...)\n     \n     ## S3 method for class 'matrix'\n     head(x, n = 6L, ...) # is exported as head.matrix()\n     ## NB: The methods for 'data.frame' and 'array'  are identical to the 'matrix' one\n     \n     ## S3 method for class 'ftable'\n     head(x, n = 6L, ...)\n     ## S3 method for class 'function'\n     head(x, n = 6L, ...)\n     \n     \n     tail(x, ...)\n     ## Default S3 method:\n     tail(x, n = 6L, keepnums = FALSE, addrownums, ...)\n     ## S3 method for class 'matrix'\n     tail(x, n = 6L, keepnums = TRUE, addrownums, ...) # exported as tail.matrix()\n     ## NB: The methods for 'data.frame', 'array', and 'table'\n     ##     are identical to the  'matrix'  one\n     \n     ## S3 method for class 'ftable'\n     tail(x, n = 6L, keepnums = FALSE, addrownums, ...)\n     ## S3 method for class 'function'\n     tail(x, n = 6L, ...)\n     \nArguments:\n\n       x: an object\n\n       n: an integer vector of length up to 'dim(x)' (or 1, for\n          non-dimensioned objects).  A 'logical' is silently coerced to\n          integer.  Values specify the indices to be selected in the\n          corresponding dimension (or along the length) of the object.\n          A positive value of 'n[i]' includes the first/last 'n[i]'\n          indices in that dimension, while a negative value excludes\n          the last/first 'abs(n[i])', including all remaining indices.\n          'NA' or non-specified values (when 'length(n) <\n          length(dim(x))') select all indices in that dimension. Must\n          contain at least one non-missing value.\n\nkeepnums: in each dimension, if no names in that dimension are present,\n          create them using the indices included in that dimension.\n          Ignored if 'dim(x)' is 'NULL' or its length 1.\n\naddrownums: deprecated - 'keepnums' should be used instead. Taken as\n          the value of 'keepnums' if it is explicitly set when\n          'keepnums' is not.\n\n     ...: arguments to be passed to or from other methods.\n\nDetails:\n\n     For vector/array based objects, 'head()' ('tail()') returns a\n     subset of the same dimensionality as 'x', usually of the same\n     class. For historical reasons, by default they select the first\n     (last) 6 indices in the first dimension (\"rows\") or along the\n     length of a non-dimensioned vector, and the full extent (all\n     indices) in any remaining dimensions. 'head.matrix()' and\n     'tail.matrix()' are exported.\n\n     The default and array(/matrix) methods for 'head()' and 'tail()'\n     are quite general. They will work as is for any class which has a\n     'dim()' method, a 'length()' method (only required if 'dim()'\n     returns 'NULL'), and a '[' method (that accepts the 'drop'\n     argument and can subset in all dimensions in the dimensioned\n     case).\n\n     For functions, the lines of the deparsed function are returned as\n     character strings.\n\n     When 'x' is an array(/matrix) of dimensionality two and more,\n     'tail()' will add dimnames similar to how they would appear in a\n     full printing of 'x' for all dimensions 'k' where 'n[k]' is\n     specified and non-missing and 'dimnames(x)[[k]]' (or 'dimnames(x)'\n     itself) is 'NULL'.  Specifically, the form of the added dimnames\n     will vary for different dimensions as follows:\n\n     'k=1' (rows): '\"[n,]\"' (right justified with whitespace padding)\n\n     'k=2' (columns): '\"[,n]\"' (with _no_ whitespace padding)\n\n     'k>2' (higher dims): '\"n\"', i.e., the indices as _character_\n          values\n\n     Setting 'keepnums = FALSE' suppresses this behaviour.\n\n     As 'data.frame' subsetting ('indexing') keeps 'attributes', so do\n     the 'head()' and 'tail()' methods for data frames.\n\nValue:\n\n     An object (usually) like 'x' but generally smaller.  Hence, for\n     'array's, the result corresponds to 'x[.., drop=FALSE]'.  For\n     'ftable' objects 'x', a transformed 'format(x)'.\n\nNote:\n\n     For array inputs the output of 'tail' when 'keepnums' is 'TRUE',\n     any dimnames vectors added for dimensions '>2' are the original\n     numeric indices in that dimension _as character vectors_.  This\n     means that, e.g., for 3-dimensional array 'arr', 'tail(arr,\n     c(2,2,-1))[ , , 2]' and 'tail(arr, c(2,2,-1))[ , , \"2\"]' may both\n     be valid but have completely different meanings.\n\nAuthor(s):\n\n     Patrick Burns, improved and corrected by R-Core. Negative argument\n     added by Vincent Goulet.  Multi-dimension support added by Gabriel\n     Becker.\n\nExamples:\n\n     head(letters)\n     head(letters, n = -6L)\n     \n     head(freeny.x, n = 10L)\n     head(freeny.y)\n     \n     head(iris3)\n     head(iris3, c(6L, 2L))\n     head(iris3, c(6L, -1L, 2L))\n     \n     tail(letters)\n     tail(letters, n = -6L)\n     \n     tail(freeny.x)\n     ## the bottom-right \"corner\" :\n     tail(freeny.x, n = c(4, 2))\n     tail(freeny.y)\n     \n     tail(iris3)\n     tail(iris3, c(6L, 2L))\n     tail(iris3, c(6L, -1L, 2L))\n     \n     ## iris with dimnames stripped\n     a3d <- iris3 ; dimnames(a3d) <- NULL\n     tail(a3d, c(6, -1, 2)) # keepnums = TRUE is default here!\n     tail(a3d, c(6, -1, 2), keepnums = FALSE)\n     \n     ## data frame w/ a (non-standard) attribute:\n     treeS <- structure(trees, foo = \"bar\")\n     (n <- nrow(treeS))\n     stopifnot(exprs = { # attribute is kept\n         identical(htS <- head(treeS), treeS[1:6, ])\n         identical(attr(htS, \"foo\") , \"bar\")\n         identical(tlS <- tail(treeS), treeS[(n-5):n, ])\n         ## BUT if I use \"useAttrib(.)\", this is *not* ok, when n is of length 2:\n         ## --- because [i,j]-indexing of data frames *also* drops \"other\" attributes ..\n         identical(tail(treeS, 3:2), treeS[(n-2):n, 2:3] )\n     })\n     \n     tail(library) # last lines of function\n     \n     head(stats::ftable(Titanic))\n     \n     ## 1d-array (with named dim) :\n     a1 <- array(1:7, 7); names(dim(a1)) <- \"O2\"\n     stopifnot(exprs = {\n       identical( tail(a1, 10), a1)\n       identical( head(a1, 10), a1)\n       identical( head(a1, 1), a1 [1 , drop=FALSE] ) # was a1[1] in R <= 3.6.x\n       identical( tail(a1, 2), a1[6:7])\n       identical( tail(a1, 1), a1 [7 , drop=FALSE] ) # was a1[7] in R <= 3.6.x\n     })\n\n\n\n## Adding new columns\n\nYou can add a new column, called `newcol` to `df`, using the `$` operator:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$log_IgG <- log(df$IgG_concentration)\nhead(df,3)\n```\n\n::: {.cell-output-display}\n| observation_id| IgG_concentration| age|gender |slum     |   log_IgG|\n|--------------:|-----------------:|---:|:------|:--------|---------:|\n|           5772|         0.3176895|   2|Female |Non slum | -1.146681|\n|           8095|         3.4368231|   4|Female |Non slum |  1.234547|\n|           9784|         0.3000000|   4|Male   |Non slum | -1.203973|\n:::\n:::\n\n\n## Creating conditional variables\n\nOne frequently-used tool is creating variables with conditions. A general function for creating new variables based on existing variables is the Base R `ifelse()` function, which \"returns a value depending on whether the element of test is `TRUE` or `FALSE`.\"\n\n\nConditional Element Selection\n\nDescription:\n\n     'ifelse' returns a value with the same shape as 'test' which is\n     filled with elements selected from either 'yes' or 'no' depending\n     on whether the element of 'test' is 'TRUE' or 'FALSE'.\n\nUsage:\n\n     ifelse(test, yes, no)\n     \nArguments:\n\n    test: an object which can be coerced to logical mode.\n\n     yes: return values for true elements of 'test'.\n\n      no: return values for false elements of 'test'.\n\nDetails:\n\n     If 'yes' or 'no' are too short, their elements are recycled.\n     'yes' will be evaluated if and only if any element of 'test' is\n     true, and analogously for 'no'.\n\n     Missing values in 'test' give missing values in the result.\n\nValue:\n\n     A vector of the same length and attributes (including dimensions\n     and '\"class\"') as 'test' and data values from the values of 'yes'\n     or 'no'.  The mode of the answer will be coerced from logical to\n     accommodate first any values taken from 'yes' and then any values\n     taken from 'no'.\n\nWarning:\n\n     The mode of the result may depend on the value of 'test' (see the\n     examples), and the class attribute (see 'oldClass') of the result\n     is taken from 'test' and may be inappropriate for the values\n     selected from 'yes' and 'no'.\n\n     Sometimes it is better to use a construction such as\n\n       (tmp <- yes; tmp[!test] <- no[!test]; tmp)\n     \n     , possibly extended to handle missing values in 'test'.\n\n     Further note that 'if(test) yes else no' is much more efficient\n     and often much preferable to 'ifelse(test, yes, no)' whenever\n     'test' is a simple true/false result, i.e., when 'length(test) ==\n     1'.\n\n     The 'srcref' attribute of functions is handled specially: if\n     'test' is a simple true result and 'yes' evaluates to a function\n     with 'srcref' attribute, 'ifelse' returns 'yes' including its\n     attribute (the same applies to a false 'test' and 'no' argument).\n     This functionality is only for backwards compatibility, the form\n     'if(test) yes else no' should be used whenever 'yes' and 'no' are\n     functions.\n\nReferences:\n\n     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S\n     Language_.  Wadsworth & Brooks/Cole.\n\nSee Also:\n\n     'if'.\n\nExamples:\n\n     x <- c(6:-4)\n     sqrt(x)  #- gives warning\n     sqrt(ifelse(x >= 0, x, NA))  # no warning\n     \n     ## Note: the following also gives the warning !\n     ifelse(x >= 0, sqrt(x), NA)\n     \n     \n     ## ifelse() strips attributes\n     ## This is important when working with Dates and factors\n     x <- seq(as.Date(\"2000-02-29\"), as.Date(\"2004-10-04\"), by = \"1 month\")\n     ## has many \"yyyy-mm-29\", but a few \"yyyy-03-01\" in the non-leap years\n     y <- ifelse(as.POSIXlt(x)$mday == 29, x, NA)\n     head(y) # not what you expected ... ==> need restore the class attribute:\n     class(y) <- class(x)\n     y\n     ## This is a (not atypical) case where it is better *not* to use ifelse(),\n     ## but rather the more efficient and still clear:\n     y2 <- x\n     y2[as.POSIXlt(x)$mday != 29] <- NA\n     ## which gives the same as ifelse()+class() hack:\n     stopifnot(identical(y2, y))\n     \n     \n     ## example of different return modes (and 'test' alone determining length):\n     yes <- 1:3\n     no  <- pi^(1:4)\n     utils::str( ifelse(NA,    yes, no) ) # logical, length 1\n     utils::str( ifelse(TRUE,  yes, no) ) # integer, length 1\n     utils::str( ifelse(FALSE, yes, no) ) # double,  length 1\n\n\n\n## `ifelse` example\n\nReminder of the first three arguments in the `ifelse()` function are `ifelse(test, yes, no)`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$age_group <- ifelse(df$age <= 5, \"young\", \"old\")\nhead(df)\n```\n\n::: {.cell-output-display}\n| observation_id| IgG_concentration| age|gender |slum     |    log_IgG|age_group |\n|--------------:|-----------------:|---:|:------|:--------|----------:|:---------|\n|           5772|         0.3176895|   2|Female |Non slum | -1.1466807|young     |\n|           8095|         3.4368231|   4|Female |Non slum |  1.2345475|young     |\n|           9784|         0.3000000|   4|Male   |Non slum | -1.2039728|young     |\n|           9338|       143.2363014|   4|Male   |Non slum |  4.9644957|young     |\n|           6369|         0.4476534|   1|Male   |Non slum | -0.8037359|young     |\n|           6885|         0.0252708|   4|Male   |Non slum | -3.6781074|young     |\n:::\n:::\n\n\n\n## Nesting `ifelse` statements example\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$age_group <- ifelse(df$age <= 5, \"young\", \n                       ifelse(df$age<=10 & df$age>5, \"middle\", \n                              ifelse(df$age>10, \"old\", NA)))\nhead(df)\n```\n\n::: {.cell-output-display}\n| observation_id| IgG_concentration| age|gender |slum     |    log_IgG|age_group |\n|--------------:|-----------------:|---:|:------|:--------|----------:|:---------|\n|           5772|         0.3176895|   2|Female |Non slum | -1.1466807|young     |\n|           8095|         3.4368231|   4|Female |Non slum |  1.2345475|young     |\n|           9784|         0.3000000|   4|Male   |Non slum | -1.2039728|young     |\n|           9338|       143.2363014|   4|Male   |Non slum |  4.9644957|young     |\n|           6369|         0.4476534|   1|Male   |Non slum | -0.8037359|young     |\n|           6885|         0.0252708|   4|Male   |Non slum | -3.6781074|young     |\n:::\n:::\n\n\n\n# Data Classes\n\n## Overview - Data Classes\n\n1. One dimensional types (i.e., vectors of characters, numeric, logical, or factor values)\n\n2. Two dimensional types (e.g., matrix, data frame, tibble)\n\n3. Special data classes (e.g., lists, dates). \n\n## \t`class()` function\n\nThe `class()` function allows you to evaluate the class of an object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(df$IgG_concentration)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nclass(df$age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\nclass(df$gender)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\nReturn the First or Last Parts of an Object\n\nDescription:\n\n     Returns the first or last parts of a vector, matrix, table, data\n     frame or function.  Since 'head()' and 'tail()' are generic\n     functions, they may also have been extended to other classes.\n\nUsage:\n\n     head(x, ...)\n     ## Default S3 method:\n     head(x, n = 6L, ...)\n     \n     ## S3 method for class 'matrix'\n     head(x, n = 6L, ...) # is exported as head.matrix()\n     ## NB: The methods for 'data.frame' and 'array'  are identical to the 'matrix' one\n     \n     ## S3 method for class 'ftable'\n     head(x, n = 6L, ...)\n     ## S3 method for class 'function'\n     head(x, n = 6L, ...)\n     \n     \n     tail(x, ...)\n     ## Default S3 method:\n     tail(x, n = 6L, keepnums = FALSE, addrownums, ...)\n     ## S3 method for class 'matrix'\n     tail(x, n = 6L, keepnums = TRUE, addrownums, ...) # exported as tail.matrix()\n     ## NB: The methods for 'data.frame', 'array', and 'table'\n     ##     are identical to the  'matrix'  one\n     \n     ## S3 method for class 'ftable'\n     tail(x, n = 6L, keepnums = FALSE, addrownums, ...)\n     ## S3 method for class 'function'\n     tail(x, n = 6L, ...)\n     \nArguments:\n\n       x: an object\n\n       n: an integer vector of length up to 'dim(x)' (or 1, for\n          non-dimensioned objects).  A 'logical' is silently coerced to\n          integer.  Values specify the indices to be selected in the\n          corresponding dimension (or along the length) of the object.\n          A positive value of 'n[i]' includes the first/last 'n[i]'\n          indices in that dimension, while a negative value excludes\n          the last/first 'abs(n[i])', including all remaining indices.\n          'NA' or non-specified values (when 'length(n) <\n          length(dim(x))') select all indices in that dimension. Must\n          contain at least one non-missing value.\n\nkeepnums: in each dimension, if no names in that dimension are present,\n          create them using the indices included in that dimension.\n          Ignored if 'dim(x)' is 'NULL' or its length 1.\n\naddrownums: deprecated - 'keepnums' should be used instead. Taken as\n          the value of 'keepnums' if it is explicitly set when\n          'keepnums' is not.\n\n     ...: arguments to be passed to or from other methods.\n\nDetails:\n\n     For vector/array based objects, 'head()' ('tail()') returns a\n     subset of the same dimensionality as 'x', usually of the same\n     class. For historical reasons, by default they select the first\n     (last) 6 indices in the first dimension (\"rows\") or along the\n     length of a non-dimensioned vector, and the full extent (all\n     indices) in any remaining dimensions. 'head.matrix()' and\n     'tail.matrix()' are exported.\n\n     The default and array(/matrix) methods for 'head()' and 'tail()'\n     are quite general. They will work as is for any class which has a\n     'dim()' method, a 'length()' method (only required if 'dim()'\n     returns 'NULL'), and a '[' method (that accepts the 'drop'\n     argument and can subset in all dimensions in the dimensioned\n     case).\n\n     For functions, the lines of the deparsed function are returned as\n     character strings.\n\n     When 'x' is an array(/matrix) of dimensionality two and more,\n     'tail()' will add dimnames similar to how they would appear in a\n     full printing of 'x' for all dimensions 'k' where 'n[k]' is\n     specified and non-missing and 'dimnames(x)[[k]]' (or 'dimnames(x)'\n     itself) is 'NULL'.  Specifically, the form of the added dimnames\n     will vary for different dimensions as follows:\n\n     'k=1' (rows): '\"[n,]\"' (right justified with whitespace padding)\n\n     'k=2' (columns): '\"[,n]\"' (with _no_ whitespace padding)\n\n     'k>2' (higher dims): '\"n\"', i.e., the indices as _character_\n          values\n\n     Setting 'keepnums = FALSE' suppresses this behaviour.\n\n     As 'data.frame' subsetting ('indexing') keeps 'attributes', so do\n     the 'head()' and 'tail()' methods for data frames.\n\nValue:\n\n     An object (usually) like 'x' but generally smaller.  Hence, for\n     'array's, the result corresponds to 'x[.., drop=FALSE]'.  For\n     'ftable' objects 'x', a transformed 'format(x)'.\n\nNote:\n\n     For array inputs the output of 'tail' when 'keepnums' is 'TRUE',\n     any dimnames vectors added for dimensions '>2' are the original\n     numeric indices in that dimension _as character vectors_.  This\n     means that, e.g., for 3-dimensional array 'arr', 'tail(arr,\n     c(2,2,-1))[ , , 2]' and 'tail(arr, c(2,2,-1))[ , , \"2\"]' may both\n     be valid but have completely different meanings.\n\nAuthor(s):\n\n     Patrick Burns, improved and corrected by R-Core. Negative argument\n     added by Vincent Goulet.  Multi-dimension support added by Gabriel\n     Becker.\n\nExamples:\n\n     head(letters)\n     head(letters, n = -6L)\n     \n     head(freeny.x, n = 10L)\n     head(freeny.y)\n     \n     head(iris3)\n     head(iris3, c(6L, 2L))\n     head(iris3, c(6L, -1L, 2L))\n     \n     tail(letters)\n     tail(letters, n = -6L)\n     \n     tail(freeny.x)\n     ## the bottom-right \"corner\" :\n     tail(freeny.x, n = c(4, 2))\n     tail(freeny.y)\n     \n     tail(iris3)\n     tail(iris3, c(6L, 2L))\n     tail(iris3, c(6L, -1L, 2L))\n     \n     ## iris with dimnames stripped\n     a3d <- iris3 ; dimnames(a3d) <- NULL\n     tail(a3d, c(6, -1, 2)) # keepnums = TRUE is default here!\n     tail(a3d, c(6, -1, 2), keepnums = FALSE)\n     \n     ## data frame w/ a (non-standard) attribute:\n     treeS <- structure(trees, foo = \"bar\")\n     (n <- nrow(treeS))\n     stopifnot(exprs = { # attribute is kept\n         identical(htS <- head(treeS), treeS[1:6, ])\n         identical(attr(htS, \"foo\") , \"bar\")\n         identical(tlS <- tail(treeS), treeS[(n-5):n, ])\n         ## BUT if I use \"useAttrib(.)\", this is *not* ok, when n is of length 2:\n         ## --- because [i,j]-indexing of data frames *also* drops \"other\" attributes ..\n         identical(tail(treeS, 3:2), treeS[(n-2):n, 2:3] )\n     })\n     \n     tail(library) # last lines of function\n     \n     head(stats::ftable(Titanic))\n     \n     ## 1d-array (with named dim) :\n     a1 <- array(1:7, 7); names(dim(a1)) <- \"O2\"\n     stopifnot(exprs = {\n       identical( tail(a1, 10), a1)\n       identical( head(a1, 10), a1)\n       identical( head(a1, 1), a1 [1 , drop=FALSE] ) # was a1[1] in R <= 3.6.x\n       identical( tail(a1, 2), a1[6:7])\n       identical( tail(a1, 1), a1 [7 , drop=FALSE] ) # was a1[7] in R <= 3.6.x\n     })\n\n\n\n## One dimensional data types\n\n* Character: strings or individual characters, quoted\n* Numeric: any real number(s)\n    - Double: contains fractional values (i.e., double precision) - default numeric\n    - Integer: any integer(s)/whole numbers\n* Logical: variables composed of TRUE or FALSE\n* Factor: categorical/qualitative variables\n\n## Character and numeric\n\nThis can also be a bit tricky. \n\nIf only one character in the whole vector, the class is assumed to be character\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(c(1, 2, \"tree\")) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\nHere because integers are in quotations, it is read as a character class by R.\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(c(\"1\", \"4\", \"7\")) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\nNote, this is the first time we have shown you nested functions.  Here, instead of creating a new vector object (e.g., `x <- c(\"1\", \"4\", \"7\")`) and then feeding the vector object `x` into the first argument of the `class()` function (e.g., `class(x)`), we combined the two steps and directly fed a vector object into the class function.\n\n## Numeric Subclasses\n\nThere are two major numeric subclasses\n\n1. `Double` is a special subset of `numeric` that contains <span style=\"color: red;\">fractional values</span>. `Double` stands for [double-precision](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)\n2. `Integer` is a special subset of `numeric` that contains only <span style=\"color: red;\">whole numbers</span>. \n\n`typeof()` identifies the vector type (double, integer, logical, or character), whereas `class()` identifies the root class. The difference between the two will be more clear when we look at two dimensional classes below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(df$IgG_concentration)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nclass(df$age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(df$IgG_concentration)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(df$age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n:::\n\n\n\n## Logical\n\nReminder `logical` is a type that only has two possible elements: `TRUE` and `FALSE`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(c(TRUE, FALSE, TRUE, TRUE, FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n:::\n\n\nNote that `logical` elements are NOT in quotes. Putting R special classes (e.g., `NA` or `FALSE`) in quotations turns them into character value. \n\n\n## Other useful functions for evaluating/setting classes\n\nThere are two useful functions associated with practically all R classes: \n\n- `is.CLASS_NAME(x)` to **logically check** whether or not `x` is of certain  class.  For example,  `is.integer` or `is.character` or `is.numeric`\n- `as.CLASS_NAME(x)` to **coerce between classes** `x` from current `x` class into a certain class. For example, `as.integer` or `as.character` or `as.numeric`.  This is particularly useful is maybe integer variable was read in as a character variable, or when you need to change a character variable to a factor variable (more on this later).\n\n## Examples `is.CLASS_NAME(x)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.numeric(df$IgG_concentration)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.character(df$age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis.character(df$gender)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n## Examples `as.CLASS_NAME(x)`\n\nIn some cases, coercing is seamless\n\n::: {.cell}\n\n```{.r .cell-code}\nas.character(c(1, 4, 7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\" \"4\" \"7\"\n```\n:::\n\n```{.r .cell-code}\nas.numeric(c(\"1\", \"4\", \"7\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 4 7\n```\n:::\n\n```{.r .cell-code}\nas.logical(c(\"TRUE\", \"FALSE\", \"FALSE\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE FALSE\n```\n:::\n:::\n\n\nIn some cases the coercing is not possible; if executed, will return `NA` (an R constant representing \"**N**ot **A**vailable\" i.e. missing value)\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(c(\"1\", \"4\", \"7a\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: NAs introduced by coercion\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1  4 NA\n```\n:::\n\n```{.r .cell-code}\nas.logical(c(\"TRUE\", \"FALSE\", \"UNKNOWN\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE    NA\n```\n:::\n:::\n\n\n\n## Factors\n\nA `factor` is a special `character` vector where the elements have pre-defined groups or 'levels'. You can think of these as qualitative or categorical variables. Use the `factor()` function to create factors from character values. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(df$age_group)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\ndf$age_group_factor <- factor(df$age_group)\nclass(df$age_group_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"factor\"\n```\n:::\n\n```{.r .cell-code}\nlevels(df$age_group_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"middle\" \"old\"    \"young\" \n```\n:::\n:::\n\n\nNote that levels are, by default, set to **alphanumerical** order! And, the first is always the \"reference\" group. However, we often prefer a different reference group.\n\n## Reference Groups \n\n**Why do we care about reference groups?** \n\nGeneralized linear regression allows you to compare the outcome of two or more groups. Your reference group is the group that everything else is compared to. Say we want to assess whether being <5 years old is associated with higher IgG antibody concentrations \n\nBy default `middle` is the reference group therefore we will only generate beta coefficients comparing `middle` to `young` AND `middle` to `old`.  But, we want `young` to be the reference group so we will generate beta coefficients comparing `young` to `middle` AND `young` to `old`.\n\n## Changing factor reference \n\nChanging the reference group of a factor variable.\n- If the object is already a factor then use `relevel()` function and the `ref` argument to specify the reference.\n- If the object is a character then use `factor()` function and `levels` argument to specify the order of the values, the first being the reference.\n\n\n\nReorder Levels of Factor\n\nDescription:\n\n     The levels of a factor are re-ordered so that the level specified\n     by 'ref' is first and the others are moved down. This is useful\n     for 'contr.treatment' contrasts which take the first level as the\n     reference.\n\nUsage:\n\n     relevel(x, ref, ...)\n     \nArguments:\n\n       x: an unordered factor.\n\n     ref: the reference level, typically a string.\n\n     ...: additional arguments for future methods.\n\nDetails:\n\n     This, as 'reorder()', is a special case of simply calling\n     'factor(x, levels = levels(x)[....])'.\n\nValue:\n\n     A factor of the same length as 'x'.\n\nSee Also:\n\n     'factor', 'contr.treatment', 'levels', 'reorder'.\n\nExamples:\n\n     warpbreaks$tension <- relevel(warpbreaks$tension, ref = \"M\")\n     summary(lm(breaks ~ wool + tension, data = warpbreaks))\n\nFactors\n\nDescription:\n\n     The function 'factor' is used to encode a vector as a factor (the\n     terms 'category' and 'enumerated type' are also used for factors).\n     If argument 'ordered' is 'TRUE', the factor levels are assumed to\n     be ordered.  For compatibility with S there is also a function\n     'ordered'.\n\n     'is.factor', 'is.ordered', 'as.factor' and 'as.ordered' are the\n     membership and coercion functions for these classes.\n\nUsage:\n\n     factor(x = character(), levels, labels = levels,\n            exclude = NA, ordered = is.ordered(x), nmax = NA)\n     \n     ordered(x = character(), ...)\n     \n     is.factor(x)\n     is.ordered(x)\n     \n     as.factor(x)\n     as.ordered(x)\n     \n     addNA(x, ifany = FALSE)\n     \n     .valid.factor(object)\n     \nArguments:\n\n       x: a vector of data, usually taking a small number of distinct\n          values.\n\n  levels: an optional vector of the unique values (as character\n          strings) that 'x' might have taken.  The default is the\n          unique set of values taken by 'as.character(x)', sorted into\n          increasing order _of 'x'_.  Note that this set can be\n          specified as smaller than 'sort(unique(x))'.\n\n  labels: _either_ an optional character vector of labels for the\n          levels (in the same order as 'levels' after removing those in\n          'exclude'), _or_ a character string of length 1.  Duplicated\n          values in 'labels' can be used to map different values of 'x'\n          to the same factor level.\n\n exclude: a vector of values to be excluded when forming the set of\n          levels.  This may be factor with the same level set as 'x' or\n          should be a 'character'.\n\n ordered: logical flag to determine if the levels should be regarded as\n          ordered (in the order given).\n\n    nmax: an upper bound on the number of levels; see 'Details'.\n\n     ...: (in 'ordered(.)'): any of the above, apart from 'ordered'\n          itself.\n\n   ifany: only add an 'NA' level if it is used, i.e.  if\n          'any(is.na(x))'.\n\n  object: an R object.\n\nDetails:\n\n     The type of the vector 'x' is not restricted; it only must have an\n     'as.character' method and be sortable (by 'order').\n\n     Ordered factors differ from factors only in their class, but\n     methods and the model-fitting functions treat the two classes\n     quite differently.\n\n     The encoding of the vector happens as follows.  First all the\n     values in 'exclude' are removed from 'levels'. If 'x[i]' equals\n     'levels[j]', then the 'i'-th element of the result is 'j'.  If no\n     match is found for 'x[i]' in 'levels' (which will happen for\n     excluded values) then the 'i'-th element of the result is set to\n     'NA'.\n\n     Normally the 'levels' used as an attribute of the result are the\n     reduced set of levels after removing those in 'exclude', but this\n     can be altered by supplying 'labels'.  This should either be a set\n     of new labels for the levels, or a character string, in which case\n     the levels are that character string with a sequence number\n     appended.\n\n     'factor(x, exclude = NULL)' applied to a factor without 'NA's is a\n     no-operation unless there are unused levels: in that case, a\n     factor with the reduced level set is returned.  If 'exclude' is\n     used, since R version 3.4.0, excluding non-existing character\n     levels is equivalent to excluding nothing, and when 'exclude' is a\n     'character' vector, that _is_ applied to the levels of 'x'.\n     Alternatively, 'exclude' can be factor with the same level set as\n     'x' and will exclude the levels present in 'exclude'.\n\n     The codes of a factor may contain 'NA'.  For a numeric 'x', set\n     'exclude = NULL' to make 'NA' an extra level (prints as '<NA>');\n     by default, this is the last level.\n\n     If 'NA' is a level, the way to set a code to be missing (as\n     opposed to the code of the missing level) is to use 'is.na' on the\n     left-hand-side of an assignment (as in 'is.na(f)[i] <- TRUE';\n     indexing inside 'is.na' does not work).  Under those circumstances\n     missing values are currently printed as '<NA>', i.e., identical to\n     entries of level 'NA'.\n\n     'is.factor' is generic: you can write methods to handle specific\n     classes of objects, see InternalMethods.\n\n     Where 'levels' is not supplied, 'unique' is called.  Since factors\n     typically have quite a small number of levels, for large vectors\n     'x' it is helpful to supply 'nmax' as an upper bound on the number\n     of unique values.\n\n     When using 'c' to combine a (possibly ordered) factor with other\n     objects, if all objects are (possibly ordered) factors, the result\n     will be a factor with levels the union of the level sets of the\n     elements, in the order the levels occur in the level sets of the\n     elements (which means that if all the elements have the same level\n     set, that is the level set of the result), equivalent to how\n     'unlist' operates on a list of factor objects.\n\nValue:\n\n     'factor' returns an object of class '\"factor\"' which has a set of\n     integer codes the length of 'x' with a '\"levels\"' attribute of\n     mode 'character' and unique ('!anyDuplicated(.)') entries.  If\n     argument 'ordered' is true (or 'ordered()' is used) the result has\n     class 'c(\"ordered\", \"factor\")'.  Undocumentedly for a long time,\n     'factor(x)' loses all 'attributes(x)' but '\"names\"', and resets\n     '\"levels\"' and '\"class\"'.\n\n     Applying 'factor' to an ordered or unordered factor returns a\n     factor (of the same type) with just the levels which occur: see\n     also '[.factor' for a more transparent way to achieve this.\n\n     'is.factor' returns 'TRUE' or 'FALSE' depending on whether its\n     argument is of type factor or not.  Correspondingly, 'is.ordered'\n     returns 'TRUE' when its argument is an ordered factor and 'FALSE'\n     otherwise.\n\n     'as.factor' coerces its argument to a factor.  It is an\n     abbreviated (sometimes faster) form of 'factor'.\n\n     'as.ordered(x)' returns 'x' if this is ordered, and 'ordered(x)'\n     otherwise.\n\n     'addNA' modifies a factor by turning 'NA' into an extra level (so\n     that 'NA' values are counted in tables, for instance).\n\n     '.valid.factor(object)' checks the validity of a factor, currently\n     only 'levels(object)', and returns 'TRUE' if it is valid,\n     otherwise a string describing the validity problem.  This function\n     is used for 'validObject(<factor>)'.\n\nWarning:\n\n     The interpretation of a factor depends on both the codes and the\n     '\"levels\"' attribute.  Be careful only to compare factors with the\n     same set of levels (in the same order).  In particular,\n     'as.numeric' applied to a factor is meaningless, and may happen by\n     implicit coercion.  To transform a factor 'f' to approximately its\n     original numeric values, 'as.numeric(levels(f))[f]' is recommended\n     and slightly more efficient than 'as.numeric(as.character(f))'.\n\n     The levels of a factor are by default sorted, but the sort order\n     may well depend on the locale at the time of creation, and should\n     not be assumed to be ASCII.\n\n     There are some anomalies associated with factors that have 'NA' as\n     a level.  It is suggested to use them sparingly, e.g., only for\n     tabulation purposes.\n\nComparison operators and group generic methods:\n\n     There are '\"factor\"' and '\"ordered\"' methods for the group generic\n     'Ops' which provide methods for the Comparison operators, and for\n     the 'min', 'max', and 'range' generics in 'Summary' of\n     '\"ordered\"'.  (The rest of the groups and the 'Math' group\n     generate an error as they are not meaningful for factors.)\n\n     Only '==' and '!=' can be used for factors: a factor can only be\n     compared to another factor with an identical set of levels (not\n     necessarily in the same ordering) or to a character vector.\n     Ordered factors are compared in the same way, but the general\n     dispatch mechanism precludes comparing ordered and unordered\n     factors.\n\n     All the comparison operators are available for ordered factors.\n     Collation is done by the levels of the operands: if both operands\n     are ordered factors they must have the same level set.\n\nNote:\n\n     In earlier versions of R, storing character data as a factor was\n     more space efficient if there is even a small proportion of\n     repeats.  However, identical character strings now share storage,\n     so the difference is small in most cases.  (Integer values are\n     stored in 4 bytes whereas each reference to a character string\n     needs a pointer of 4 or 8 bytes.)\n\nReferences:\n\n     Chambers, J. M. and Hastie, T. J. (1992) _Statistical Models in\n     S_.  Wadsworth & Brooks/Cole.\n\nSee Also:\n\n     '[.factor' for subsetting of factors.\n\n     'gl' for construction of balanced factors and 'C' for factors with\n     specified contrasts.  'levels' and 'nlevels' for accessing the\n     levels, and 'unclass' to get integer codes.\n\nExamples:\n\n     (ff <- factor(substring(\"statistics\", 1:10, 1:10), levels = letters))\n     as.integer(ff)      # the internal codes\n     (f. <- factor(ff))  # drops the levels that do not occur\n     ff[, drop = TRUE]   # the same, more transparently\n     \n     factor(letters[1:20], labels = \"letter\")\n     \n     class(ordered(4:1)) # \"ordered\", inheriting from \"factor\"\n     z <- factor(LETTERS[3:1], ordered = TRUE)\n     ## and \"relational\" methods work:\n     stopifnot(sort(z)[c(1,3)] == range(z), min(z) < max(z))\n     \n     \n     ## suppose you want \"NA\" as a level, and to allow missing values.\n     (x <- factor(c(1, 2, NA), exclude = NULL))\n     is.na(x)[2] <- TRUE\n     x  # [1] 1    <NA> <NA>\n     is.na(x)\n     # [1] FALSE  TRUE FALSE\n     \n     ## More rational, since R 3.4.0 :\n     factor(c(1:2, NA), exclude =  \"\" ) # keeps <NA> , as\n     factor(c(1:2, NA), exclude = NULL) # always did\n     ## exclude = <character>\n     z # ordered levels 'A < B < C'\n     factor(z, exclude = \"C\") # does exclude\n     factor(z, exclude = \"B\") # ditto\n     \n     ## Now, labels maybe duplicated:\n     ## factor() with duplicated labels allowing to \"merge levels\"\n     x <- c(\"Man\", \"Male\", \"Man\", \"Lady\", \"Female\")\n     ## Map from 4 different values to only two levels:\n     (xf <- factor(x, levels = c(\"Male\", \"Man\" , \"Lady\",   \"Female\"),\n                      labels = c(\"Male\", \"Male\", \"Female\", \"Female\")))\n     #> [1] Male   Male   Male   Female Female\n     #> Levels: Male Female\n     \n     ## Using addNA()\n     Month <- airquality$Month\n     table(addNA(Month))\n     table(addNA(Month, ifany = TRUE))\n\n\n\n## Changing factor reference examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$age_group_factor <- relevel(df$age_group_factor, ref=\"young\")\nlevels(df$age_group_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"young\"  \"middle\" \"old\"   \n```\n:::\n:::\n\n\nOR\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$age_group_factor <- factor(df$age_group, levels=c(\"young\", \"middle\", \"old\"))\nlevels(df$age_group_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"young\"  \"middle\" \"old\"   \n```\n:::\n:::\n\n\nArranging, tabulating, and plotting the data will reflect the new order\n\n\n## Two-dimensional data classes\n\nTwo-dimensional classes are those we would often use to store data read from a file \n\n* a matrix (`matrix` class)\n* a data frame (`data.frame` or `tibble` classes)\n\n\n## Matrices\n\nMatrices, like data frames are also composed of rows and columns. Matrices, unlike `data.frame`, the entire matrix is composed of one R class. **For example: all entries are `numeric`, or all entries are `character`**\n\n`as.matrix()` creates a matrix from a data frame (where all values are the same class).\n\nYou can also create a matrix from scratch using `matrix()` Use `?matrix` to see the arguments.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(1:6, ncol = 2) \n```\n\n::: {.cell-output-display}\n|   |   |\n|--:|--:|\n|  1|  4|\n|  2|  5|\n|  3|  6|\n:::\n\n```{.r .cell-code}\nmatrix(1:6, ncol=2, byrow=TRUE) \n```\n\n::: {.cell-output-display}\n|   |   |\n|--:|--:|\n|  1|  2|\n|  3|  4|\n|  5|  6|\n:::\n:::\n\n\nNotice, the first matrix filled in numbers 1-6 by columns first and then rows because default `byrow` argument is FALSE. In the second matrix, we changed the argument `byrow` to `TRUE`, and now numbers 1-6 are filled by rows first and then columns.\n\n## Data Frame \n\nYou can transform an existing matrix into data frames and tibble using `as.data.frame()`.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.data.frame(matrix(1:6, ncol = 2) ) \n```\n\n::: {.cell-output-display}\n| V1| V2|\n|--:|--:|\n|  1|  4|\n|  2|  5|\n|  3|  6|\n:::\n:::\n\n\n\n## Numeric variable data summary\n\nData summarization on numeric vectors/variables:\n-\t\t`mean()`: takes the mean of x\n-\t\t`sd()`: takes the standard deviation of x\n-\t\t`median()`: takes the median of x\n-\t\t`quantile()`: displays sample quantiles of x. Default is min, IQR, max\n-\t\t`range()`: displays the range. Same as `c(min(), max())`\n-\t\t`sum()`: sum of x\n-\t\t`max()`: maximum value in x\n-\t\t`min()`: minimum value in x\n\nNote, **all have the ** `na.rm =` **argument for missing data**\n\n\nArithmetic Mean\n\nDescription:\n\n     Generic function for the (trimmed) arithmetic mean.\n\nUsage:\n\n     mean(x, ...)\n     \n     ## Default S3 method:\n     mean(x, trim = 0, na.rm = FALSE, ...)\n     \nArguments:\n\n       x: An R object.  Currently there are methods for numeric/logical\n          vectors and date, date-time and time interval objects.\n          Complex vectors are allowed for 'trim = 0', only.\n\n    trim: the fraction (0 to 0.5) of observations to be trimmed from\n          each end of 'x' before the mean is computed.  Values of trim\n          outside that range are taken as the nearest endpoint.\n\n   na.rm: a logical evaluating to 'TRUE' or 'FALSE' indicating whether\n          'NA' values should be stripped before the computation\n          proceeds.\n\n     ...: further arguments passed to or from other methods.\n\nValue:\n\n     If 'trim' is zero (the default), the arithmetic mean of the values\n     in 'x' is computed, as a numeric or complex vector of length one.\n     If 'x' is not logical (coerced to numeric), numeric (including\n     integer) or complex, 'NA_real_' is returned, with a warning.\n\n     If 'trim' is non-zero, a symmetrically trimmed mean is computed\n     with a fraction of 'trim' observations deleted from each end\n     before the mean is computed.\n\nReferences:\n\n     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S\n     Language_.  Wadsworth & Brooks/Cole.\n\nSee Also:\n\n     'weighted.mean', 'mean.POSIXct', 'colMeans' for row and column\n     means.\n\nExamples:\n\n     x <- c(0:10, 50)\n     xm <- mean(x)\n     c(xm, mean(x, trim = 0.10))\n\n\n## Numeric variable data summary examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(df)\n```\n\n::: {.cell-output-display}\n|   |observation_id |IgG_concentration |     age       |   gender        |    slum         |   log_IgG      | age_group       |age_group_factor |\n|:--|:--------------|:-----------------|:--------------|:----------------|:----------------|:---------------|:----------------|:----------------|\n|   |Min.   :5006   |Min.   :  0.0054  |Min.   : 1.000 |Length:651       |Length:651       |Min.   :-5.2231 |Length:651       |young :316       |\n|   |1st Qu.:6306   |1st Qu.:  0.3000  |1st Qu.: 3.000 |Class :character |Class :character |1st Qu.:-1.2040 |Class :character |middle:179       |\n|   |Median :7495   |Median :  1.6658  |Median : 6.000 |Mode  :character |Mode  :character |Median : 0.5103 |Mode  :character |old   :147       |\n|   |Mean   :7492   |Mean   : 87.3683  |Mean   : 6.606 |NA               |NA               |Mean   : 1.6074 |NA               |NA's  :  9       |\n|   |3rd Qu.:8749   |3rd Qu.:141.4405  |3rd Qu.:10.000 |NA               |NA               |3rd Qu.: 4.9519 |NA               |NA               |\n|   |Max.   :9982   |Max.   :916.4179  |Max.   :15.000 |NA               |NA               |Max.   : 6.8205 |NA               |NA               |\n|   |NA             |NA's   :10        |NA's   :9      |NA               |NA               |NA's   :10      |NA               |NA               |\n:::\n\n```{.r .cell-code}\nrange(df$age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA NA\n```\n:::\n\n```{.r .cell-code}\nrange(df$age, na.rm=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1 15\n```\n:::\n\n```{.r .cell-code}\nmedian(df$IgG_concentration, na.rm=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.665753\n```\n:::\n:::\n\n\n\n## Character Variable Data Summaries\n\nData summarization on character or factor vectors/variables\n\t\t* `table()`\n\t\t\n\nCross Tabulation and Table Creation\n\nDescription:\n\n     'table' uses cross-classifying factors to build a contingency\n     table of the counts at each combination of factor levels.\n\nUsage:\n\n     table(...,\n           exclude = if (useNA == \"no\") c(NA, NaN),\n           useNA = c(\"no\", \"ifany\", \"always\"),\n           dnn = list.names(...), deparse.level = 1)\n     \n     as.table(x, ...)\n     is.table(x)\n     \n     ## S3 method for class 'table'\n     as.data.frame(x, row.names = NULL, ...,\n                   responseName = \"Freq\", stringsAsFactors = TRUE,\n                   sep = \"\", base = list(LETTERS))\n     \nArguments:\n\n     ...: one or more objects which can be interpreted as factors\n          (including numbers or character strings), or a 'list' (such\n          as a data frame) whose components can be so interpreted.\n          (For 'as.table', arguments passed to specific methods; for\n          'as.data.frame', unused.)\n\n exclude: levels to remove for all factors in '...'.  If it does not\n          contain 'NA' and 'useNA' is not specified, it implies 'useNA\n          = \"ifany\"'.  See 'Details' for its interpretation for\n          non-factor arguments.\n\n   useNA: whether to include 'NA' values in the table.  See 'Details'.\n          Can be abbreviated.\n\n     dnn: the names to be given to the dimensions in the result (the\n          _dimnames names_).\n\ndeparse.level: controls how the default 'dnn' is constructed.  See\n          'Details'.\n\n       x: an arbitrary R object, or an object inheriting from class\n          '\"table\"' for the 'as.data.frame' method. Note that\n          'as.data.frame.table(x, *)' may be called explicitly for\n          non-table 'x' for \"reshaping\" 'array's.\n\nrow.names: a character vector giving the row names for the data frame.\n\nresponseName: The name to be used for the column of table entries,\n          usually counts.\n\nstringsAsFactors: logical: should the classifying factors be returned\n          as factors (the default) or character vectors?\n\nsep, base: passed to 'provideDimnames'.\n\nDetails:\n\n     If the argument 'dnn' is not supplied, the internal function\n     'list.names' is called to compute the 'dimname names' as follows:\n     If '...' is one 'list' with its own 'names()', these 'names' are\n     used.  Otherwise, if the arguments in '...' are named, those names\n     are used.  For the remaining arguments, 'deparse.level = 0' gives\n     an empty name, 'deparse.level = 1' uses the supplied argument if\n     it is a symbol, and 'deparse.level = 2' will deparse the argument.\n\n     Only when 'exclude' is specified (i.e., not by default) and\n     non-empty, will 'table' potentially drop levels of factor\n     arguments.\n\n     'useNA' controls if the table includes counts of 'NA' values: the\n     allowed values correspond to never ('\"no\"'), only if the count is\n     positive ('\"ifany\"') and even for zero counts ('\"always\"').  Note\n     the somewhat \"pathological\" case of two different kinds of 'NA's\n     which are treated differently, depending on both 'useNA' and\n     'exclude', see 'd.patho' in the 'Examples:' below.\n\n     Both 'exclude' and 'useNA' operate on an \"all or none\" basis.  If\n     you want to control the dimensions of a multiway table separately,\n     modify each argument using 'factor' or 'addNA'.\n\n     Non-factor arguments 'a' are coerced via 'factor(a,\n     exclude=exclude)'.  Since R 3.4.0, care is taken _not_ to count\n     the excluded values (where they were included in the 'NA' count,\n     previously).\n\n     The 'summary' method for class '\"table\"' (used for objects created\n     by 'table' or 'xtabs') which gives basic information and performs\n     a chi-squared test for independence of factors (note that the\n     function 'chisq.test' currently only handles 2-d tables).\n\nValue:\n\n     'table()' returns a _contingency table_, an object of class\n     '\"table\"', an array of integer values.  Note that unlike S the\n     result is always an 'array', a 1D array if one factor is given.\n\n     'as.table' and 'is.table' coerce to and test for contingency\n     table, respectively.\n\n     The 'as.data.frame' method for objects inheriting from class\n     '\"table\"' can be used to convert the array-based representation of\n     a contingency table to a data frame containing the classifying\n     factors and the corresponding entries (the latter as component\n     named by 'responseName').  This is the inverse of 'xtabs'.\n\nReferences:\n\n     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S\n     Language_.  Wadsworth & Brooks/Cole.\n\nSee Also:\n\n     'tabulate' is the underlying function and allows finer control.\n\n     Use 'ftable' for printing (and more) of multidimensional tables.\n     'margin.table', 'prop.table', 'addmargins'.\n\n     'addNA' for constructing factors with 'NA' as a level.\n\n     'xtabs' for cross tabulation of data frames with a formula\n     interface.\n\nExamples:\n\n     require(stats) # for rpois and xtabs\n     ## Simple frequency distribution\n     table(rpois(100, 5))\n     ## Check the design:\n     with(warpbreaks, table(wool, tension))\n     table(state.division, state.region)\n     \n     # simple two-way contingency table\n     with(airquality, table(cut(Temp, quantile(Temp)), Month))\n     \n     a <- letters[1:3]\n     table(a, sample(a))                    # dnn is c(\"a\", \"\")\n     table(a, sample(a), deparse.level = 0) # dnn is c(\"\", \"\")\n     table(a, sample(a), deparse.level = 2) # dnn is c(\"a\", \"sample(a)\")\n     \n     ## xtabs() <-> as.data.frame.table() :\n     UCBAdmissions ## already a contingency table\n     DF <- as.data.frame(UCBAdmissions)\n     class(tab <- xtabs(Freq ~ ., DF)) # xtabs & table\n     ## tab *is* \"the same\" as the original table:\n     all(tab == UCBAdmissions)\n     all.equal(dimnames(tab), dimnames(UCBAdmissions))\n     \n     a <- rep(c(NA, 1/0:3), 10)\n     table(a)                 # does not report NA's\n     table(a, exclude = NULL) # reports NA's\n     b <- factor(rep(c(\"A\",\"B\",\"C\"), 10))\n     table(b)\n     table(b, exclude = \"B\")\n     d <- factor(rep(c(\"A\",\"B\",\"C\"), 10), levels = c(\"A\",\"B\",\"C\",\"D\",\"E\"))\n     table(d, exclude = \"B\")\n     print(table(b, d), zero.print = \".\")\n     \n     ## NA counting:\n     is.na(d) <- 3:4\n     d. <- addNA(d)\n     d.[1:7]\n     table(d.) # \", exclude = NULL\" is not needed\n     ## i.e., if you want to count the NA's of 'd', use\n     table(d, useNA = \"ifany\")\n     \n     ## \"pathological\" case:\n     d.patho <- addNA(c(1,NA,1:2,1:3))[-7]; is.na(d.patho) <- 3:4\n     d.patho\n     ## just 3 consecutive NA's ? --- well, have *two* kinds of NAs here :\n     as.integer(d.patho) # 1 4 NA NA 1 2\n     ##\n     ## In R >= 3.4.0, table() allows to differentiate:\n     table(d.patho)                   # counts the \"unusual\" NA\n     table(d.patho, useNA = \"ifany\")  # counts all three\n     table(d.patho, exclude = NULL)   #  (ditto)\n     table(d.patho, exclude = NA)     # counts none\n     \n     ## Two-way tables with NA counts. The 3rd variant is absurd, but shows\n     ## something that cannot be done using exclude or useNA.\n     with(airquality,\n        table(OzHi = Ozone > 80, Month, useNA = \"ifany\"))\n     with(airquality,\n        table(OzHi = Ozone > 80, Month, useNA = \"always\"))\n     with(airquality,\n        table(OzHi = Ozone > 80, addNA(Month)))\n\n\n\n\n## Character variable data summary examples\n\nNumber of observations in each category\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(df$gender)\n```\n\n::: {.cell-output-display}\n| Female| Male|\n|------:|----:|\n|    325|  326|\n:::\n\n```{.r .cell-code}\ntable(df$gender, useNA=\"always\")\n```\n\n::: {.cell-output-display}\n| Female| Male| NA|\n|------:|----:|--:|\n|    325|  326|  0|\n:::\n\n```{.r .cell-code}\ntable(df$age_group, useNA=\"always\")\n```\n\n::: {.cell-output-display}\n| middle| old| young| NA|\n|------:|---:|-----:|--:|\n|    179| 147|   316|  9|\n:::\n:::\n\n\nPercent of observations in each category (xxzane - better way in base r?)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(df$gender)/nrow(df) #if no NA values\n```\n\n::: {.cell-output-display}\n|   Female|     Male|\n|--------:|--------:|\n| 0.499232| 0.500768|\n:::\n\n```{.r .cell-code}\ntable(df$age_group)/nrow(df[!is.na(df$age_group),]) #if there are NA values\n```\n\n::: {.cell-output-display}\n|    middle|      old|     young|\n|---------:|--------:|---------:|\n| 0.2788162| 0.228972| 0.4922118|\n:::\n\n```{.r .cell-code}\ntable(df$age_group)/nrow(subset(df, !is.na(df$age_group),)) #if there are NA values\n```\n\n::: {.cell-output-display}\n|    middle|      old|     young|\n|---------:|--------:|---------:|\n| 0.2788162| 0.228972| 0.4922118|\n:::\n:::\n\n\n\n\n## Summary\n\n-   Adding (or modifying) columns/variable to a data frame by using `$` \n-   There are two types of numeric class objects: integer and double\n-   Logical class objects only have `TRUE` or `False` (without quotes)\n-   `is.CLASS_NAME(x)` can be used to test the class of an object x\n-   `as.CLASS_NAME(x)` can be used to change the class of an object x\n-   Factors are a special character class that has levels \n-   ...\n\t\t\n\n## Acknowledgements\n\nThese are the materials I looked through, modified, or extracted to complete this module's lecture.\n\n-   [\"Introduction to R for Public Health Researchers\" Johns Hopkins University](https://jhudatascience.org/intro_to_r/)\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}