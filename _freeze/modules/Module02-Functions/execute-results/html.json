{
  "hash": "4d4a3bffe15ffe6003dbf3e2cfd1791a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Module 2: Functions\"\nformat: \n  revealjs:\n    scrollable: true\n    smaller: true\n    toc: false\n---\n\n\n\n\n\n\n## Learning Objectives\n\nAfter module 2, you should be able to...\n\n-   Describe and execute functions in R\n-   Modify default behavior of functions using arguments in R\n-   Use R-specific sources of help to get more information about functions and packages \n-   Differentiate between Base R functions and functions that come from other packages\n\n\n## Function - Basic term\n\n**Function** - Functions are \"self contained\" modules of code that **accomplish specific tasks**. Functions usually take in some sort of object (e.g., vector, list), process it, and return a result. You can write your own, use functions that come directly from installing R (i.e., Base R functions), or use functions from external packages.\n\nA function might help you add numbers together, create a plot, or organize your data. In fact, we have already used three functions in the Module 1, including `c()`, `matrix()`, `list()`. Here is another one, `sum()`\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(1, 20234)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20235\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n## Function\n\nThe general usage for a function is the name of the function followed by parentheses (i.e., the function signature). Within the parentheses are **arguments**.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction_name(argument1, argument2, ...)\n```\n:::\n\n\n\n\n\n\n\n## Arguments - Basic term\n\n**Arguments** are what you pass to the function and can include:\n\n1.  the physical object on which the function carries out a task (e.g., can be data such as a number 1 or 20234)\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(1, 20234)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20235\n```\n\n\n:::\n:::\n\n\n\n\n\n\n2.  options that alter the way the function operates (e.g., such as the `base` argument in the function `log()`)\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(10, base = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nlog(10, base = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.321928\n```\n\n\n:::\n\n```{.r .cell-code}\nlog(10, base=exp(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.302585\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Arguments\n\nMost functions are created with **default argument options**. The defaults represent standard values that the author of the function specified as being \"good enough in standard cases\". This means if you don't specify an argument when calling the function, it will use a default.\n\n-   If you want something specific, simply change the argument yourself with a value of your choice.\n-   If an argument is required but you did not specify it and there is no default argument specified when the function was created, you will receive an error.\n\n## Example\n\nWhat is the default in the `base` argument of the `log()` function?\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.302585\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Sure that is easy enough, but how do you know\n\n- the purpose of a function? \n- what arguments a function includes? \n- how to specify the arguments?\n\n## Seeking help for using functions\n\nThe best way of finding out this information is to use the `?` followed by the name of the function. Doing this will open up the help manual in the bottom RStudio Help panel. It provides a description of the function, usage, arguments, details, and examples. Lets look at the help file for the function `round()`\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?log\n```\n:::\n\n\n```\nRegistered S3 method overwritten by 'printr':\n  method                from     \n  knit_print.data.frame rmarkdown\n```\n\n```{=html}\n<div class=\"r-help-page\"><div class=\"container\"><main>\n\n<table style=\"width: 100%;\"><tr><td>log</td><td style=\"text-align: right;\">R Documentation</td></tr></table>\n\n<h2>Logarithms and Exponentials</h2>\n\n<h3>Description</h3>\n\n<p><code>log</code> computes logarithms, by default natural logarithms,\n<code>log10</code> computes common (i.e., base 10) logarithms, and\n<code>log2</code> computes binary (i.e., base 2) logarithms.\nThe general form <code>log(x, base)</code> computes logarithms with base\n<code>base</code>.\n</p>\n<p><code>log1p(x)</code> computes <code class=\"reqn\">\\log(1+x)</code> accurately also for\n<code class=\"reqn\">|x| \\ll 1</code>.\n</p>\n<p><code>exp</code> computes the exponential function.\n</p>\n<p><code>expm1(x)</code> computes <code class=\"reqn\">\\exp(x) - 1</code> accurately also for\n<code class=\"reqn\">|x| \\ll 1</code>.\n</p>\n\n\n<h3>Usage</h3>\n\n<pre><code class='language-R'>log(x, base = exp(1))\nlogb(x, base = exp(1))\nlog10(x)\nlog2(x)\n\nlog1p(x)\n\nexp(x)\nexpm1(x)\n</code></pre>\n\n\n<h3>Arguments</h3>\n\n<table>\n<tr><td><code id=\"x\">x</code></td>\n<td>\n<p>a numeric or complex vector.</p>\n</td></tr>\n<tr><td><code id=\"base\">base</code></td>\n<td>\n<p>a positive or complex number: the base with respect to which\nlogarithms are computed.  Defaults to <code class=\"reqn\">e</code>=<code>exp(1)</code>.</p>\n</td></tr>\n</table>\n\n\n<h3>Details</h3>\n\n<p>All except <code>logb</code> are generic functions: methods can be defined\nfor them individually or via the <code>Math</code>\ngroup generic.\n</p>\n<p><code>log10</code> and <code>log2</code> are only convenience wrappers, but logs\nto bases 10 and 2 (whether computed <em>via</em> <code>log</code> or the wrappers)\nwill be computed more efficiently and accurately where supported by the OS.\nMethods can be set for them individually (and otherwise methods for\n<code>log</code> will be used).\n</p>\n<p><code>logb</code> is a wrapper for <code>log</code> for compatibility with S.  If\n(S3 or S4) methods are set for <code>log</code> they will be dispatched.\nDo not set S4 methods on <code>logb</code> itself.\n</p>\n<p>All except <code>log</code> are primitive functions.\n</p>\n\n\n<h3>Value</h3>\n\n<p>A vector of the same length as <code>x</code> containing the transformed\nvalues.  <code>log(0)</code> gives <code>-Inf</code>, and <code>log(x)</code> for\nnegative values of <code>x</code> is <code>NaN</code>.  <code>exp(-Inf)</code> is <code>0</code>.\n</p>\n<p>For complex inputs to the log functions, the value is a complex number\nwith imaginary part in the range <code class=\"reqn\">[-\\pi, \\pi]</code>: which\nend of the range is used might be platform-specific.\n</p>\n\n\n<h3>S4 methods</h3>\n\n<p><code>exp</code>, <code>expm1</code>, <code>log</code>, <code>log10</code>, <code>log2</code> and\n<code>log1p</code> are S4 generic and are members of the\n<code>Math</code> group generic.\n</p>\n<p>Note that this means that the S4 generic for <code>log</code> has a\nsignature with only one argument, <code>x</code>, but that <code>base</code> can\nbe passed to methods (but will not be used for method selection).  On\nthe other hand, if you only set a method for the <code>Math</code> group\ngeneric then <code>base</code> argument of <code>log</code> will be ignored for\nyour class.\n</p>\n\n\n<h3>Source</h3>\n\n<p><code>log1p</code> and <code>expm1</code> may be taken from the operating system,\nbut if not available there then they are based on the Fortran subroutine\n<code>dlnrel</code> by W. Fullerton of Los Alamos Scientific Laboratory (see\n<a href=\"https://netlib.org/slatec/fnlib/dlnrel.f\">https://netlib.org/slatec/fnlib/dlnrel.f</a>) and (for small x) a\nsingle Newton step for the solution of <code>log1p(y) = x</code>\nrespectively.\n</p>\n\n\n<h3>References</h3>\n\n<p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988)\n<em>The New S Language</em>.\nWadsworth &amp; Brooks/Cole.\n(for <code>log</code>, <code>log10</code> and <code>exp</code>.)\n</p>\n<p>Chambers, J. M. (1998)\n<em>Programming with Data.  A Guide to the S Language</em>.\nSpringer. (for <code>logb</code>.)\n</p>\n\n\n<h3>See Also</h3>\n\n<p><code>Trig</code>,\n<code>sqrt</code>,\n<code>Arithmetic</code>.\n</p>\n\n\n<h3>Examples</h3>\n\n<pre><code class='language-R'>log(exp(3))\nlog10(1e7) # = 7\n\nx &lt;- 10^-(1+2*1:9)\ncbind(deparse.level=2, # to get nice column names\n      x, log(1+x), log1p(x), exp(x)-1, expm1(x))\n</code></pre>\n\n</main>\n\n</div>\n</div>\n```\n\n\n\n\n\n\n## How to specify arguments\n\n1.  Arguments are separated with a comma\n2.  You can specify arguments by either including them in the correct order OR by assigning the argument within the function parentheses.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/log_args.png){width=70%}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(10, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.321928\n```\n\n\n:::\n\n```{.r .cell-code}\nlog(base=2, x=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.321928\n```\n\n\n:::\n\n```{.r .cell-code}\nlog(x=10, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.321928\n```\n\n\n:::\n\n```{.r .cell-code}\nlog(10, base=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.321928\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Package - Basic term\n\nWhen you download R, it has a \"base\" set of functions, that are associated with a \"base\" set of packages including: 'base', 'datasets', 'graphics', 'grDevices', 'methods', 'stats' (typically just referred to as **Base R**).\n\n-   e.g., the `log()` function comes from the 'base' package\n\n**Package** - a package in R is a bundle or \"package\" of code (and or possibly data) that can be loaded together for easy repeated use or for **sharing** with others.\n\nPackages are analogous to software applications like Microsoft Word. After installation, your operating system allows you to use it, just like having Word installed allows you to use it.\n\n## Packages\n\nThe Packages pane in RStudio can help you identify what have been installed (listed), and which one have been attached (check mark).\n\nLets go look at the Packages pane, find the `base` package and find the `log()` function. It automatically loads the help file that we looked at earlier using `?log`.\n\n\n## Additional Packages\n\nYou can install additional packages for your use from [CRAN](https://cran.r-project.org/) or [GitHub](https://github.com/). These additional packages are written by RStudio or R users/developers (like us)\n\n-   Not all packages available on CRAN or GitHub are trustworthy\n-   RStudio (the company) makes a lot of great packages\n-   Who wrote it? **Hadley Wickham** is a major authority on R (Employee and Developer at RStudio)\n-   How to [trust](https://simplystatistics.org/posts/2015-11-06-how-i-decide-when-to-trust-an-r-package/#:~:text=The%20first%20thing%20I%20do,I%20immediately%20trust%20the%20package.) an R package\n\n## **Installing** and attaching packages\n\nTo use the bundle or \"package\" of code (and or possibly data) from a package, you need to install and also attach the package.\n\nTo install a package you can \n\n1. go to R Studio Menu Bar Tools Menu ---\\> Install Packages in the RStudio header\n\nOR\n\n2. use the following code:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"package_name\")\n```\n:::\n\n\n\n\n\n\n\n## Installing and **attaching** packages\n\nTo attach (i.e., be able to use the package) you can use the following code:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(package_name) #library(package_name) also works\n```\n:::\n\n\n\n\n\n\nMore on installing and attaching packages later...\n\n\n## Mini exercise\n\nFind and execute a **Base R** function that will round the number 0.86424 to two digits.\n\n\n## Functions from Module 1\n\nThe combine function `c()` concatenate/collects/combines single R objects into a vector of R objects. It is mostly used for creating vectors of numbers, character strings, and other data types. \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?c\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n```{=html}\n<div class=\"r-help-page\"><div class=\"container\"><main>\n\n<table style=\"width: 100%;\"><tr><td>c</td><td style=\"text-align: right;\">R Documentation</td></tr></table>\n\n<h2>Combine Values into a Vector or List</h2>\n\n<h3>Description</h3>\n\n<p>This is a generic function which combines its arguments.\n</p>\n<p>The default method combines its arguments to form a vector.\nAll arguments are coerced to a common type which is the type\nof the returned value, and all attributes except names are removed.\n</p>\n\n\n<h3>Usage</h3>\n\n<pre><code class='language-R'>## S3 Generic function\nc(...)\n\n## Default S3 method:\nc(..., recursive = FALSE, use.names = TRUE)\n</code></pre>\n\n\n<h3>Arguments</h3>\n\n<table>\n<tr><td><code id=\"...\">...</code></td>\n<td>\n<p>objects to be concatenated.  All <code>NULL</code> entries\nare dropped before method dispatch unless at the very beginning of the\nargument list.</p>\n</td></tr>\n<tr><td><code id=\"recursive\">recursive</code></td>\n<td>\n<p>logical.  If <code>recursive = TRUE</code>, the function\nrecursively descends through lists (and pairlists) combining all\ntheir elements into a vector.</p>\n</td></tr>\n<tr><td><code id=\"use.names\">use.names</code></td>\n<td>\n<p>logical indicating if <code>names</code> should be\npreserved.</p>\n</td></tr>\n</table>\n\n\n<h3>Details</h3>\n\n<p>The output type is determined from the highest type of the components\nin the hierarchy NULL &lt; raw &lt; logical &lt; integer &lt; double &lt; complex &lt; character\n&lt; list &lt; expression.  Pairlists are treated as lists, whereas non-vector\ncomponents (such as <code>name</code>s / <code>symbol</code>s and <code>call</code>s)\nare treated as one-element <code>list</code>s\nwhich cannot be unlisted even if <code>recursive = TRUE</code>.\n</p>\n<p>If the output type is <code>complex</code>, logical, integer, and double\n<code>NA</code>s keep their imaginary parts zero when coerced, and hence will\n<em>not</em> become <code>NA_complex_</code> (with imaginary part <code>NA</code>).\n</p>\n<p>There is a <code>c.factor</code> method which combines factors into\na factor.\n</p>\n<p><code>c</code> is sometimes used for its side effect of removing attributes\nexcept names, for example to turn an <code>array</code> into a vector.\n<code>as.vector</code> is a more intuitive way to do this, but also drops\nnames.  Note that <code>c</code> methods other than the default are not required\nto remove attributes (and they will almost certainly preserve a class attribute).\n</p>\n<p>This is a primitive function.\n</p>\n\n\n<h3>Value</h3>\n\n<p><code>NULL</code> or an expression or a vector of an appropriate mode.\n(With no arguments the value is <code>NULL</code>.)\n</p>\n\n\n<h3>S4 methods</h3>\n\n<p>This function is S4 generic, but with argument list\n<code>(x, ...)</code>.\n</p>\n\n\n<h3>References</h3>\n\n<p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988)\n<em>The New S Language</em>.\nWadsworth &amp; Brooks/Cole.\n</p>\n\n\n<h3>See Also</h3>\n\n<p><code>unlist</code> and <code>as.vector</code> to produce\nattribute-free vectors.\n</p>\n\n\n<h3>Examples</h3>\n\n<pre><code class='language-R'>c(1, 7:9)\nc(1:5, 10.5, \"next\")\n\n## uses with a single argument to drop attributes\nx &lt;- 1:4\nnames(x) &lt;- letters[1:4]\nx\nc(x)          # has names\nas.vector(x)  # no names\ndim(x) &lt;- c(2,2)\nx\nc(x)\nas.vector(x)\n\n## append to a list:\nll &lt;- list(A = 1, c = \"C\")\n## do *not* use\nc(ll, d = 1:3) # which is == c(ll, as.list(c(d = 1:3)))\n## but rather\nc(ll, d = list(1:3))  # c() combining two lists\n\n## descend through lists:\nc(list(A = c(B = 1)), recursive = TRUE)\nc(list(A = c(B = 1, C = 2), B = c(E = 7)), recursive = TRUE)\n</code></pre>\n\n</main>\n\n</div>\n</div>\n```\n:::\n:::\n\n\n\n\n\n\n## Functions from Module 1\n\nThe `matrix()` function creates a matrix from the given set of values.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?matrix\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n```{=html}\n<div class=\"r-help-page\"><div class=\"container\"><main>\n\n<table style=\"width: 100%;\"><tr><td>matrix</td><td style=\"text-align: right;\">R Documentation</td></tr></table>\n\n<h2>Matrices</h2>\n\n<h3>Description</h3>\n\n<p><code>matrix</code> creates a matrix from the given set of values.\n</p>\n<p><code>as.matrix</code> attempts to turn its argument into a matrix.\n</p>\n<p><code>is.matrix</code> tests if its argument is a (strict) matrix.\n</p>\n\n\n<h3>Usage</h3>\n\n<pre><code class='language-R'>matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE,\n       dimnames = NULL)\n\nas.matrix(x, ...)\n## S3 method for class 'data.frame'\nas.matrix(x, rownames.force = NA, ...)\n\nis.matrix(x)\n</code></pre>\n\n\n<h3>Arguments</h3>\n\n<table>\n<tr><td><code id=\"data\">data</code></td>\n<td>\n<p>an optional data vector (including a list or\n<code>expression</code> vector).  Non-atomic classed <span class=\"rlang\"><b>R</b></span> objects are\ncoerced by <code>as.vector</code> and all attributes discarded.</p>\n</td></tr>\n<tr><td><code id=\"nrow\">nrow</code></td>\n<td>\n<p>the desired number of rows.</p>\n</td></tr>\n<tr><td><code id=\"ncol\">ncol</code></td>\n<td>\n<p>the desired number of columns.</p>\n</td></tr>\n<tr><td><code id=\"byrow\">byrow</code></td>\n<td>\n<p>logical. If <code>FALSE</code> (the default) the matrix is\nfilled by columns, otherwise the matrix is filled by rows.</p>\n</td></tr>\n<tr><td><code id=\"dimnames\">dimnames</code></td>\n<td>\n<p>a <code>dimnames</code> attribute for the matrix:\n<code>NULL</code> or a <code>list</code> of length 2 giving the row and column\nnames respectively.  An empty list is treated as <code>NULL</code>, and a\nlist of length one as row names.  The list can be named, and the\nlist names will be used as names for the dimensions.</p>\n</td></tr>\n<tr><td><code id=\"x\">x</code></td>\n<td>\n<p>an <span class=\"rlang\"><b>R</b></span> object.</p>\n</td></tr>\n<tr><td><code id=\"...\">...</code></td>\n<td>\n<p>additional arguments to be passed to or from methods.</p>\n</td></tr>\n<tr><td><code id=\"rownames.force\">rownames.force</code></td>\n<td>\n<p>logical indicating if the resulting matrix\nshould have character (rather than <code>NULL</code>)\n<code>rownames</code>.  The default, <code>NA</code>, uses <code>NULL</code>\nrownames if the data frame has &lsquo;automatic&rsquo; row.names or for a\nzero-row data frame.</p>\n</td></tr>\n</table>\n\n\n<h3>Details</h3>\n\n<p>If one of <code>nrow</code> or <code>ncol</code> is not given, an attempt is\nmade to infer it from the length of <code>data</code> and the other\nparameter.  If neither is given, a one-column matrix is returned.\n</p>\n<p>If there are too few elements in <code>data</code> to fill the matrix,\nthen the elements in <code>data</code> are recycled.  If <code>data</code> has\nlength zero, <code>NA</code> of an appropriate type is used for atomic\nvectors (<code>0</code> for raw vectors) and <code>NULL</code> for lists.\n</p>\n<p><code>is.matrix</code> returns <code>TRUE</code> if <code>x</code> is a vector and has a\n<code>\"dim\"</code> attribute of length 2 and <code>FALSE</code> otherwise.\nNote that a <code>data.frame</code> is <strong>not</strong> a matrix by this\ntest.  The function is generic: you can write methods to handle\nspecific classes of objects, see InternalMethods.\n</p>\n<p><code>as.matrix</code> is a generic function.  The method for data frames\nwill return a character matrix if there is only atomic columns and any\nnon-(numeric/logical/complex) column, applying <code>as.vector</code>\nto factors and <code>format</code> to other non-character columns.\nOtherwise, the usual coercion hierarchy (logical &lt; integer &lt; double &lt;\ncomplex) will be used, e.g., all-logical data frames will be coerced\nto a logical matrix, mixed logical-integer will give a integer matrix,\netc.\n</p>\n<p>The default method for <code>as.matrix</code> calls <code>as.vector(x)</code>, and\nhence e.g. coerces factors to character vectors.\n</p>\n<p>When coercing a vector, it produces a one-column matrix, and\npromotes the names (if any) of the vector to the rownames of the matrix.\n</p>\n<p><code>is.matrix</code> is a primitive function.\n</p>\n<p>The <code>print</code> method for a matrix gives a rectangular layout with\ndimnames or indices.  For a list matrix, the entries of length not\none are printed in  the form &lsquo;<span class=\"samp\">&#8288;integer,7&#8288;</span>&rsquo; indicating the type\nand length.\n</p>\n\n\n<h3>Note</h3>\n\n<p>If you just want to convert a vector to a matrix, something like\n</p>\n<pre>  dim(x) &lt;- c(nx, ny)\n  dimnames(x) &lt;- list(row_names, col_names)\n</pre>\n<p>will avoid duplicating <code>x</code> <em>and</em> preserve\n<code>class(x)</code> which may be useful, e.g.,\nfor <code>Date</code> objects.\n</p>\n\n\n<h3>References</h3>\n\n<p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988)\n<em>The New S Language</em>.\nWadsworth &amp; Brooks/Cole.\n</p>\n\n\n<h3>See Also</h3>\n\n<p><code>data.matrix</code>, which attempts to convert to a numeric\nmatrix.\n</p>\n<p>A matrix is the special case of a two-dimensional <code>array</code>.\n<code>inherits(m, \"array\")</code> is true for a <code>matrix</code> <code>m</code>.\n</p>\n\n\n<h3>Examples</h3>\n\n<pre><code class='language-R'>is.matrix(as.matrix(1:10))\n!is.matrix(warpbreaks)  # data.frame, NOT matrix!\nwarpbreaks[1:10,]\nas.matrix(warpbreaks[1:10,])  # using as.matrix.data.frame(.) method\n\n## Example of setting row and column names\nmdat &lt;- matrix(c(1,2,3, 11,12,13), nrow = 2, ncol = 3, byrow = TRUE,\n               dimnames = list(c(\"row1\", \"row2\"),\n                               c(\"C.1\", \"C.2\", \"C.3\")))\nmdat\n</code></pre>\n\n</main>\n\n</div>\n</div>\n```\n:::\n:::\n\n\n\n\n\n\n\n## Summary\n\n- Functions are \"self contained\" modules of code that accomplish specific tasks.\n- Arguments are what you pass to functions (e.g., objects on which you carry out the task or options for how to carry out the task)\n- Arguments may include defaults that the author of the function specified as being \"good enough in standard cases\", but that can be changed.\n- An R Package is a bundle or \"package\" of code (and or possibly data) that can be used by installing it once and attaching it (using `require`()`) each time R/Rstudio is opened\n- The Help pane in RStudio is useful for to get more information about functions and packages \n\n\n## Acknowledgements\n\nThese are the materials we looked through, modified, or extracted to complete this module's lecture.\n\n- [\"Introduction to R - ARCHIVED\" from  Harvard Chan Bioinformatics Core (HBC)](https://hbctraining.github.io/Intro-to-R/lessons/03_introR-functions-and-arguments.html#:\\~:text=A%20key%20feature%20of%20R,it%2C%20and%20return%20a%20result.)\n\n\n",
    "supporting": [
      "Module02-Functions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
