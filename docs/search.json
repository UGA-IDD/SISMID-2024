[
  {
    "objectID": "schedule.html",
    "href": "schedule.html",
    "title": "Course Schedule",
    "section": "",
    "text": "Meeting times:\nLocation: Randal Rollins Building (RR) 201, Emory University",
    "crumbs": [
      "Course Schedule"
    ]
  },
  {
    "objectID": "schedule.html#day-01-monday",
    "href": "schedule.html#day-01-monday",
    "title": "Course Schedule",
    "section": "Day 01 – Monday",
    "text": "Day 01 – Monday\n\n\n\n\n\n\n\nTime\nSection\n\n\n\n\n08:30 am - 10:00 am\ncontent\n\n\n10:00 am - 10:15 am\nCoffee break\n\n\n10:30 am - 12:00 pm\ncontent\n\n\n12:00 pm - 01:30 pm\nLunch (2nd floor lobby)\n\n\n01:30 pm - 03:00 pm\ncontent\n\n\n03:00 pm - 03:15 pm\nCoffee break\n\n\n03:00 pm - 05:00 pm\ncontent\n\n\n05:00 pm - 07:00 pm\nNetworking night and poster session, Randal Rollins P01",
    "crumbs": [
      "Course Schedule"
    ]
  },
  {
    "objectID": "schedule.html#day-02-tuesday",
    "href": "schedule.html#day-02-tuesday",
    "title": "Course Schedule",
    "section": "Day 02 – Tuesday",
    "text": "Day 02 – Tuesday\n\n\n\n\n\n\n\nTime\nSection\n\n\n\n\n08:30 am - 10:00 am\ncontent\n\n\n10:00 am - 10:15 am\nCoffee break\n\n\n10:30 am - 12:00 pm\ncontent\n\n\n12:00 pm - 01:30 pm\nLunch (2nd floor lobby); Lunch and Learn!\n\n\n01:30 pm - 03:00 pm\ncontent\n\n\n03:00 pm - 03:15 pm\nCoffee break\n\n\n03:00 pm - 05:00 pm\ncontent\n\n\n05:00 pm - 07:00 pm\nNetworking night and poster session, Randal Rollins P01",
    "crumbs": [
      "Course Schedule"
    ]
  },
  {
    "objectID": "schedule.html#day-03-wednesday",
    "href": "schedule.html#day-03-wednesday",
    "title": "Course Schedule",
    "section": "Day 03 – Wednesday",
    "text": "Day 03 – Wednesday\n\n\n\n\n\n\n\nTime\nSection\n\n\n\n\n08:30 am - 10:00 am\ncontent\n\n\n10:00 am - 10:15 am\nCoffee break\n\n\n10:30 am - 12:00 pm\ncontent",
    "crumbs": [
      "Course Schedule"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#learning-goals",
    "href": "modules/ModuleXX-Iteration.html#learning-goals",
    "title": "Iteration in R",
    "section": "Learning goals",
    "text": "Learning goals\n\nReplace repetitive code with a for loop\nCompare and contrast for loops and *apply() functions\nUse vectorization to replace unnecessary loops",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "Welcome to “Introduction to R”!\nThis website contains all of the slides and exercises for the 2024 Summer Institute in Modeling for Infectious Diseases (SISMID) Module “Introduction to R”.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#prerequisities",
    "href": "index.html#prerequisities",
    "title": "Welcome",
    "section": "Prerequisities",
    "text": "Prerequisities\nFamiliary with basic statistical concepts on the level of an introductory statistics class is assumed for our course\nBefore the course begins, you should install R and RStudio on your laptop. If you are using an older version of R, you should update it before the course begins. You will need at least R version 4.3.0 for this course, but using the most recent version (4.4.1 at the time of writing) is always preferable.\n\nYou can install R from the CRAN website by clicking on the correct download link for your OS.\nYou can install RStudio from the Posit website.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#about-the-instructors",
    "href": "index.html#about-the-instructors",
    "title": "Welcome",
    "section": "About the instructors",
    "text": "About the instructors\n\n\n\nInstructor: Dr. Amy Winter\n\n\nDr. Winter is an Assistant Professor of Epidemiology at the University of Georgia. She has been coding in R for 10 years, and uses R day-to-day to conduct her research addressing policy-relevant questions on the transmission and control of infectious diseases in human populations, particularly VPDs. She teaches a semester-long course titled Introduction to Coding in R for Public Health to graduate students at the University of Georgia.\n\n\n\nTA: Zane Billings\n\n\nZane Billings is a PhD student in Epidemiology and Biostatistics at the University of Georgia, working with Andreas Handel. He has been using R since 2017, and uses R for nearly all of his statistics and data science practice. Zane’s research focuses on the immune response to influenza vaccination, and uses machine learning and multilevel regression modeling (in R!) to improve our understanding of influenza immunology.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "modules/Module01-Intro.html",
    "href": "modules/Module01-Intro.html",
    "title": "Intro to Modeling",
    "section": "",
    "text": "ReuseCC BY-NC 4.0",
    "crumbs": [
      "Day 1",
      "Intro to Modeling"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\nReferences\n\n\nMatloff, Norman. 2011. The Art of R Programming. San Francisco, CA: No Starch Press.\n\n\nWickham, Hadley, Mine Çetinkaya-Rundel, and Garrett Grolemund. 2023. R for Data Science. 2nd ed. Sebastopol, CA: O’Reilly Media.\n\n\n\n\n\n\n\n\nReuseCC BY-NC 4.0",
    "crumbs": [
      "More References"
    ]
  },
  {
    "objectID": "exercises/CaseStudy01.html#learning-goals",
    "href": "exercises/CaseStudy01.html#learning-goals",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Learning goals",
    "text": "Learning goals\n\nUse logical operators, subsetting functions, and math calculations in R\nTranslate human-understandable problem descriptions into instructions that R can understand."
  },
  {
    "objectID": "exercises/CaseStudy01.html#instructions",
    "href": "exercises/CaseStudy01.html#instructions",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Instructions",
    "text": "Instructions\n\nMake a new R script for this case study, and save it to your code folder.\nWe’ll use the diphtheria serosample data from Exercise 1 for this case study. Load it into R and use the functions we’ve learned to look at it."
  },
  {
    "objectID": "exercises/CaseStudy01.html#instructions-1",
    "href": "exercises/CaseStudy01.html#instructions-1",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Instructions",
    "text": "Instructions\n\nMake a new R script for this case study, and save it to your code folder.\nWe’ll use the diphtheria serosample data from Exercise 1 for this case study. Load it into R and use the functions we’ve learned to look at it.\nThe str() of your dataset should look like this.\n\n\n\ntibble [250 × 5] (S3: tbl_df/tbl/data.frame)\n $ age_months  : num [1:250] 15 44 103 88 88 118 85 19 78 112 ...\n $ group       : chr [1:250] \"urban\" \"rural\" \"urban\" \"urban\" ...\n $ DP_antibody : num [1:250] 0.481 0.657 1.368 1.218 0.333 ...\n $ DP_infection: num [1:250] 1 1 1 1 1 1 1 1 1 1 ...\n $ DP_vacc     : num [1:250] 0 1 1 1 1 1 1 1 1 1 ..."
  },
  {
    "objectID": "modules/Module01-Intro.html#welcome-to-class",
    "href": "modules/Module01-Intro.html#welcome-to-class",
    "title": "Intro to Modeling",
    "section": "Welcome to class!",
    "text": "Welcome to class!\n\n2 + 2\n\n[1] 4",
    "crumbs": [
      "Day 1",
      "Intro to Modeling"
    ]
  },
  {
    "objectID": "exercises/CaseStudy01.html#part-1",
    "href": "exercises/CaseStudy01.html#part-1",
    "title": "Case Study 1",
    "section": "Part 1",
    "text": "Part 1\n\n\n\nWas the overall prevalence higher in urban or rural areas?"
  },
  {
    "objectID": "exercises/CaseStudy01.html#what-is",
    "href": "exercises/CaseStudy01.html#what-is",
    "title": "Case Study 1",
    "section": "What is",
    "text": "What is\nWhat is"
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-was-the-overall-prevalence-higher-in-urban-or-rural-areas",
    "href": "exercises/CaseStudy01.html#q1-was-the-overall-prevalence-higher-in-urban-or-rural-areas",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: Was the overall prevalence higher in urban or rural areas?",
    "text": "Q1: Was the overall prevalence higher in urban or rural areas?\n\n\nHow do we calculate the prevalence from the data?\nHow do we calculate the prevalence separately for urban and rural areas?\nHow do we determine which prevalence is higher and if the difference is meaningful?"
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-how-do-we-calculate-the-prevalence-from-the-data",
    "href": "exercises/CaseStudy01.html#q1-how-do-we-calculate-the-prevalence-from-the-data",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: How do we calculate the prevalence from the data?",
    "text": "Q1: How do we calculate the prevalence from the data?\n\n\nThe variable DP_infection in our dataset is binary / dichotomous.\nThe prevalence is the number or percent of people who had the disease over some duration.\nThe average of a binary variable gives the prevalence!\n\n\n\n\nmean(diph$DP_infection)\n\n[1] 0.8"
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-how-do-we-calculate-the-prevalence-separately-for-urban-and-rural-areas",
    "href": "exercises/CaseStudy01.html#q1-how-do-we-calculate-the-prevalence-separately-for-urban-and-rural-areas",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: How do we calculate the prevalence separately for urban and rural areas?",
    "text": "Q1: How do we calculate the prevalence separately for urban and rural areas?\n\n\nmean(diph[diph$group == \"urban\", ]$DP_infection)\n\n[1] 0.8235294\n\nmean(diph[diph$group == \"rural\", ]$DP_infection)\n\n[1] 0.778626\n\n\n\n\n\nThere are many ways you could write this code! You can use subset() or you can write the indices many ways.\nUsing tbl_df objects from haven uses different [[ rules than a base R data frame."
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is",
    "href": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is",
    "title": "Case Study 1",
    "section": "Q1: How do we determine which prevalence is higher and if the difference is",
    "text": "Q1: How do we determine which prevalence is higher and if the difference is\nmeaningful?\n\n\nWe probably need to include a confidence interval in our calculation.\nThis is actually not so easy without more advanced tools that we will learn in upcoming modules.\nRight now the best options are to do it by hand or google a function."
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-1",
    "href": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-1",
    "title": "Case Study 1",
    "section": "Q1: How do we determine which prevalence is higher and if the difference is",
    "text": "Q1: How do we determine which prevalence is higher and if the difference is\nmeaningful? (By hand)\n\n\nUrban: 0.82; 95% CI: (0.78, 0.87)\nRural: 0.78; 95% CI: (0.73, 0.83)\n\n\n\nWe can see that the 95% CI’s overlap, so the groups are probably not that different. To be sure, we need to do a 2-sample test! But this is not a statistics class.\nSome people will tell you that coding like this is “bad”. But ‘bad’ code that gives you answers is better than broken code!\nWe will learn techniques for writing this with less work and less repetition in upcoming modules."
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-2",
    "href": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-2",
    "title": "Case Study 1",
    "section": "Q1: How do we determine which prevalence is higher and if the difference is",
    "text": "Q1: How do we determine which prevalence is higher and if the difference is\nmeaningful? (Google a package)\n\n\n  group DP_infection.mean DP_infection.lwr.ci DP_infection.upr.ci\n1 rural         0.7786260           0.7065872           0.8506647\n2 urban         0.8235294           0.7540334           0.8930254\n\n\n\nNotice that the results are slightly different from what we did manually! One advantage of writing your own code is that you know exactly what it does!\nFiguring out the details of how that function works might take a lot of time."
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-meaningful",
    "href": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-meaningful",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: How do we determine which prevalence is higher and if the difference is meaningful?",
    "text": "Q1: How do we determine which prevalence is higher and if the difference is meaningful?\n\n\nWe probably need to include a confidence interval in our calculation.\nThis is actually not so easy without more advanced tools that we will learn in upcoming modules.\nRight now the best options are to do it by hand or google a function."
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-meaningful-by-hand",
    "href": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-meaningful-by-hand",
    "title": "Case Study 1",
    "section": "Q1: How do we determine which prevalence is higher and if the difference is meaningful? (By hand)",
    "text": "Q1: How do we determine which prevalence is higher and if the difference is meaningful? (By hand)\n\np_urban &lt;- mean(diph[diph$group == \"urban\", ]$DP_infection)\np_rural &lt;- mean(diph[diph$group == \"rural\", ]$DP_infection)\nse_urban &lt;- sqrt(p_urban * (1 - p_urban) / nrow(diph))\nse_rural &lt;- sqrt(p_rural * (1 - p_rural) / nrow(diph))\n\nresult_urban &lt;- paste0(\n    \"Urban: \", round(p_urban, 2), \"; 95% CI: (\",\n    round(p_urban - 1.96 * se_urban, 2), \", \",\n    round(p_urban + 1.96 * se_urban, 2), \")\"\n)\n\nresult_rural &lt;- paste0(\n    \"Rural: \", round(p_rural, 2), \"; 95% CI: (\",\n    round(p_rural - 1.96 * se_rural, 2), \", \",\n    round(p_rural + 1.96 * se_rural, 2), \")\"\n)\n\ncat(result_urban, result_rural, sep = \"\\n\")\n\nUrban: 0.82; 95% CI: (0.78, 0.87)\nRural: 0.78; 95% CI: (0.73, 0.83)"
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-meaningful-google-a-package",
    "href": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-meaningful-google-a-package",
    "title": "Case Study 1",
    "section": "Q1: How do we determine which prevalence is higher and if the difference is meaningful? (Google a package)",
    "text": "Q1: How do we determine which prevalence is higher and if the difference is meaningful? (Google a package)\n\n# install.packages(\"DescTools\")\nlibrary(DescTools)\n\naggregate(DP_infection ~ group, data = diph, FUN = DescTools::MeanCI)\n\n  group DP_infection.mean DP_infection.lwr.ci DP_infection.upr.ci\n1 rural         0.7786260           0.7065872           0.8506647\n2 urban         0.8235294           0.7540334           0.8930254\n\n\n\nNotice that the results are slightly different from what we did manually! One advantage of writing your own code is that you know exactly what it does!\nFiguring out the details of how that function works might take a lot of time."
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-how-do-we-calculate-the-prevalence-separately-for-urban-and-rural-areas-1",
    "href": "exercises/CaseStudy01.html#q1-how-do-we-calculate-the-prevalence-separately-for-urban-and-rural-areas-1",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: How do we calculate the prevalence separately for urban and rural areas?",
    "text": "Q1: How do we calculate the prevalence separately for urban and rural areas?\n\nOne easy way is to use the aggregate() function.\n\n\naggregate(DP_infection ~ group, data = diph, FUN = mean)\n\n  group DP_infection\n1 rural    0.7786260\n2 urban    0.8235294"
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-meaningful-by-hand-1",
    "href": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-meaningful-by-hand-1",
    "title": "Case Study 1",
    "section": "Q1: How do we determine which prevalence is higher and if the difference is meaningful? (By hand)",
    "text": "Q1: How do we determine which prevalence is higher and if the difference is meaningful? (By hand)\n\nWe can see that the 95% CI’s overlap, so the groups are probably not that different. To be sure, we need to do a 2-sample test! But this is not a statistics class.\nSome people will tell you that coding like this is “bad”. But ‘bad’ code that gives you answers is better than broken code! We will learn techniques for writing this with less work and less repetition in upcoming modules."
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-googling-a-package",
    "href": "exercises/CaseStudy01.html#q1-googling-a-package",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: Googling a package",
    "text": "Q1: Googling a package\n\n# install.packages(\"DescTools\")\nlibrary(DescTools)\n\naggregate(DP_infection ~ group, data = diph, FUN = DescTools::MeanCI)\n\n  group DP_infection.mean DP_infection.lwr.ci DP_infection.upr.ci\n1 rural         0.7786260           0.7065872           0.8506647\n2 urban         0.8235294           0.7540334           0.8930254"
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-by-hand",
    "href": "exercises/CaseStudy01.html#q1-by-hand",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: By hand",
    "text": "Q1: By hand\n\np_urban &lt;- mean(diph[diph$group == \"urban\", ]$DP_infection)\np_rural &lt;- mean(diph[diph$group == \"rural\", ]$DP_infection)\nse_urban &lt;- sqrt(p_urban * (1 - p_urban) / nrow(diph[diph$group == \"urban\", ]))\nse_rural &lt;- sqrt(p_rural * (1 - p_rural) / nrow(diph[diph$group == \"rural\", ])) \n\nresult_urban &lt;- paste0(\n    \"Urban: \", round(p_urban, 2), \"; 95% CI: (\",\n    round(p_urban - 1.96 * se_urban, 2), \", \",\n    round(p_urban + 1.96 * se_urban, 2), \")\"\n)\n\nresult_rural &lt;- paste0(\n    \"Rural: \", round(p_rural, 2), \"; 95% CI: (\",\n    round(p_rural - 1.96 * se_rural, 2), \", \",\n    round(p_rural + 1.96 * se_rural, 2), \")\"\n)\n\ncat(result_urban, result_rural, sep = \"\\n\")\n\nUrban: 0.82; 95% CI: (0.76, 0.89)\nRural: 0.78; 95% CI: (0.71, 0.85)"
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-by-hand-1",
    "href": "exercises/CaseStudy01.html#q1-by-hand-1",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: By hand",
    "text": "Q1: By hand\n\nWe can see that the 95% CI’s overlap, so the groups are probably not that different. To be sure, we need to do a 2-sample test! But this is not a statistics class.\nSome people will tell you that coding like this is “bad”. But ‘bad’ code that gives you answers is better than broken code! We will learn techniques for writing this with less work and less repetition in upcoming modules."
  },
  {
    "objectID": "exercises/CaseStudy01.html#congratulations-for-finishing-the-first-case-study",
    "href": "exercises/CaseStudy01.html#congratulations-for-finishing-the-first-case-study",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Congratulations for finishing the first case study!",
    "text": "Congratulations for finishing the first case study!\n\nWhat R functions and skills did you practice?\nWhat other questions could you answer about the same dataset with the skills you know now?"
  },
  {
    "objectID": "modules/CaseStudy01.html#learning-goals",
    "href": "modules/CaseStudy01.html#learning-goals",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Learning goals",
    "text": "Learning goals\n\nUse logical operators, subsetting functions, and math calculations in R\nTranslate human-understandable problem descriptions into instructions that R can understand.",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/CaseStudy01.html#instructions",
    "href": "modules/CaseStudy01.html#instructions",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Instructions",
    "text": "Instructions\n\nMake a new R script for this case study, and save it to your code folder.\nWe’ll use the diphtheria serosample data from Exercise 1 for this case study. Load it into R and use the functions we’ve learned to look at it.",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/CaseStudy01.html#instructions-1",
    "href": "modules/CaseStudy01.html#instructions-1",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Instructions",
    "text": "Instructions\n\nMake a new R script for this case study, and save it to your code folder.\nWe’ll use the diphtheria serosample data from Exercise 1 for this case study. Load it into R and use the functions we’ve learned to look at it.\nThe str() of your dataset should look like this.\n\n\n\ntibble [250 × 5] (S3: tbl_df/tbl/data.frame)\n $ age_months  : num [1:250] 15 44 103 88 88 118 85 19 78 112 ...\n $ group       : chr [1:250] \"urban\" \"rural\" \"urban\" \"urban\" ...\n $ DP_antibody : num [1:250] 0.481 0.657 1.368 1.218 0.333 ...\n $ DP_infection: num [1:250] 1 1 1 1 1 1 1 1 1 1 ...\n $ DP_vacc     : num [1:250] 0 1 1 1 1 1 1 1 1 1 ...",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/CaseStudy01.html#q1-was-the-overall-prevalence-higher-in-urban-or-rural-areas",
    "href": "modules/CaseStudy01.html#q1-was-the-overall-prevalence-higher-in-urban-or-rural-areas",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: Was the overall prevalence higher in urban or rural areas?",
    "text": "Q1: Was the overall prevalence higher in urban or rural areas?\n\n\nHow do we calculate the prevalence from the data?\nHow do we calculate the prevalence separately for urban and rural areas?\nHow do we determine which prevalence is higher and if the difference is meaningful?",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/CaseStudy01.html#q1-how-do-we-calculate-the-prevalence-from-the-data",
    "href": "modules/CaseStudy01.html#q1-how-do-we-calculate-the-prevalence-from-the-data",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: How do we calculate the prevalence from the data?",
    "text": "Q1: How do we calculate the prevalence from the data?\n\n\nThe variable DP_infection in our dataset is binary / dichotomous.\nThe prevalence is the number or percent of people who had the disease over some duration.\nThe average of a binary variable gives the prevalence!\n\n\n\n\nmean(diph$DP_infection)\n\n[1] 0.8",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/CaseStudy01.html#q1-how-do-we-calculate-the-prevalence-separately-for-urban-and-rural-areas",
    "href": "modules/CaseStudy01.html#q1-how-do-we-calculate-the-prevalence-separately-for-urban-and-rural-areas",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: How do we calculate the prevalence separately for urban and rural areas?",
    "text": "Q1: How do we calculate the prevalence separately for urban and rural areas?\n\n\nmean(diph[diph$group == \"urban\", ]$DP_infection)\n\n[1] 0.8235294\n\nmean(diph[diph$group == \"rural\", ]$DP_infection)\n\n[1] 0.778626\n\n\n\n\n\nThere are many ways you could write this code! You can use subset() or you can write the indices many ways.\nUsing tbl_df objects from haven uses different [[ rules than a base R data frame.",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/CaseStudy01.html#q1-how-do-we-calculate-the-prevalence-separately-for-urban-and-rural-areas-1",
    "href": "modules/CaseStudy01.html#q1-how-do-we-calculate-the-prevalence-separately-for-urban-and-rural-areas-1",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: How do we calculate the prevalence separately for urban and rural areas?",
    "text": "Q1: How do we calculate the prevalence separately for urban and rural areas?\n\nOne easy way is to use the aggregate() function.\n\n\naggregate(DP_infection ~ group, data = diph, FUN = mean)\n\n  group DP_infection\n1 rural    0.7786260\n2 urban    0.8235294",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-meaningful",
    "href": "modules/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-meaningful",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: How do we determine which prevalence is higher and if the difference is meaningful?",
    "text": "Q1: How do we determine which prevalence is higher and if the difference is meaningful?\n\n\nWe probably need to include a confidence interval in our calculation.\nThis is actually not so easy without more advanced tools that we will learn in upcoming modules.\nRight now the best options are to do it by hand or google a function.",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/CaseStudy01.html#q1-by-hand",
    "href": "modules/CaseStudy01.html#q1-by-hand",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: By hand",
    "text": "Q1: By hand\n\np_urban &lt;- mean(diph[diph$group == \"urban\", ]$DP_infection)\np_rural &lt;- mean(diph[diph$group == \"rural\", ]$DP_infection)\nse_urban &lt;- sqrt(p_urban * (1 - p_urban) / nrow(diph[diph$group == \"urban\", ]))\nse_rural &lt;- sqrt(p_rural * (1 - p_rural) / nrow(diph[diph$group == \"rural\", ])) \n\nresult_urban &lt;- paste0(\n    \"Urban: \", round(p_urban, 2), \"; 95% CI: (\",\n    round(p_urban - 1.96 * se_urban, 2), \", \",\n    round(p_urban + 1.96 * se_urban, 2), \")\"\n)\n\nresult_rural &lt;- paste0(\n    \"Rural: \", round(p_rural, 2), \"; 95% CI: (\",\n    round(p_rural - 1.96 * se_rural, 2), \", \",\n    round(p_rural + 1.96 * se_rural, 2), \")\"\n)\n\ncat(result_urban, result_rural, sep = \"\\n\")\n\nUrban: 0.82; 95% CI: (0.76, 0.89)\nRural: 0.78; 95% CI: (0.71, 0.85)",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/CaseStudy01.html#q1-by-hand-1",
    "href": "modules/CaseStudy01.html#q1-by-hand-1",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: By hand",
    "text": "Q1: By hand\n\nWe can see that the 95% CI’s overlap, so the groups are probably not that different. To be sure, we need to do a 2-sample test! But this is not a statistics class.\nSome people will tell you that coding like this is “bad”. But ‘bad’ code that gives you answers is better than broken code! We will learn techniques for writing this with less work and less repetition in upcoming modules.",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/CaseStudy01.html#q1-googling-a-package",
    "href": "modules/CaseStudy01.html#q1-googling-a-package",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: Googling a package",
    "text": "Q1: Googling a package\n\n\n# install.packages(\"DescTools\")\nlibrary(DescTools)\n\naggregate(DP_infection ~ group, data = diph, FUN = DescTools::MeanCI)\n\n  group DP_infection.mean DP_infection.lwr.ci DP_infection.upr.ci\n1 rural         0.7786260           0.7065872           0.8506647\n2 urban         0.8235294           0.7540334           0.8930254",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/CaseStudy01.html#you-try-it",
    "href": "modules/CaseStudy01.html#you-try-it",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "You try it!",
    "text": "You try it!\n\nUsing any of the approaches you can think of, answer this question!\nHow many children under 5 were vaccinated? In children under 5, did vaccination lower the prevalence of infection?",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/CaseStudy01.html#you-try-it-1",
    "href": "modules/CaseStudy01.html#you-try-it-1",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "You try it!",
    "text": "You try it!\n\n# How many children under 5 were vaccinated\nsum(diph$DP_vacc[diph$age_months &lt; 60])\n\n[1] 91\n\n# Prevalence in both vaccine groups for children under 5\naggregate(\n    DP_infection ~ DP_vacc,\n    data = subset(diph, age_months &lt; 60),\n    FUN = DescTools::MeanCI\n)\n\n  DP_vacc DP_infection.mean DP_infection.lwr.ci DP_infection.upr.ci\n1       0         0.4285714           0.1977457           0.6593972\n2       1         0.6373626           0.5366845           0.7380407\n\n\nIt appears that prevalence was HIGHER in the vaccine group? That is counterintuitive, but the sample size for the unvaccinated group is too small to be sure.",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/CaseStudy01.html#congratulations-for-finishing-the-first-case-study",
    "href": "modules/CaseStudy01.html#congratulations-for-finishing-the-first-case-study",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Congratulations for finishing the first case study!",
    "text": "Congratulations for finishing the first case study!\n\nWhat R functions and skills did you practice?\nWhat other questions could you answer about the same dataset with the skills you know now?",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#what-is-iteration",
    "href": "modules/ModuleXX-Iteration.html#what-is-iteration",
    "title": "Iteration in R",
    "section": "What is iteration?",
    "text": "What is iteration?\n\nWhenever you repeat something, that’s iteration.\nIn R, this means running the same code multiple times in a row.\n\n\ndata(\"penguins\", package = \"palmerpenguins\")\nfor (this_island in levels(penguins$island)) {\n    island_mean &lt;-\n        penguins$bill_depth_mm[penguins$island == this_island] |&gt;\n        mean(na.rm = TRUE) |&gt;\n        round(digits = 2)\n    \n    cat(paste(\"The mean bill depth on\", this_island, \"Island was\", island_mean,\n                            \"mm.\\n\"))\n}\n\nThe mean bill depth on Biscoe Island was 15.87 mm.\nThe mean bill depth on Dream Island was 18.34 mm.\nThe mean bill depth on Torgersen Island was 18.43 mm.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#parts-of-a-loop",
    "href": "modules/ModuleXX-Iteration.html#parts-of-a-loop",
    "title": "Iteration in R",
    "section": "Parts of a loop",
    "text": "Parts of a loop\n\nfor (this_island in levels(penguins$island)) {\n    island_mean &lt;-\n        penguins$bill_depth_mm[penguins$island == this_island] |&gt;\n        mean(na.rm = TRUE) |&gt;\n        round(digits = 2)\n    \n    cat(paste(\"The mean bill depth on\", this_island, \"Island was\", island_mean,\n                            \"mm.\\n\"))\n}\n\nThe header declares how many times we will repeat the same code. The header contains a control variable that changes in each repetition and a sequence of values for the control variable to take.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#parts-of-a-loop-1",
    "href": "modules/ModuleXX-Iteration.html#parts-of-a-loop-1",
    "title": "Iteration in R",
    "section": "Parts of a loop",
    "text": "Parts of a loop\n\nfor (this_island in levels(penguins$island)) {\n    island_mean &lt;-\n        penguins$bill_depth_mm[penguins$island == this_island] |&gt;\n        mean(na.rm = TRUE) |&gt;\n        round(digits = 2)\n    \n    cat(paste(\"The mean bill depth on\", this_island, \"Island was\", island_mean,\n                            \"mm.\\n\"))\n}\n\nThe body of the loop contains code that will be repeated a number of times based on the header instructions. In R, the body has to be surrounded by curly braces.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#header-parts",
    "href": "modules/ModuleXX-Iteration.html#header-parts",
    "title": "Iteration in R",
    "section": "Header parts",
    "text": "Header parts\n\nfor (this_island in levels(penguins$island)) {...}\n\n\nfor: keyword that declares we are doing a for loop.\n(...): parentheses after for declare the control variable and sequence.\nthis_island: the control variable.\nin: keyword that separates the control varibale and sequence.\nlevels(penguins$island): the sequence.\n{}: curly braces will contain the body code.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#header-parts-1",
    "href": "modules/ModuleXX-Iteration.html#header-parts-1",
    "title": "Iteration in R",
    "section": "Header parts",
    "text": "Header parts\n\nfor (this_island in levels(penguins$island)) {...}\n\n\nSince levels(penguins$island) evaluates to c(\"Biscoe\", \"Dream\", \"Torgersen\"), our loop will repeat 3 times.\n\n\n\n\nIteration\nthis_island\n\n\n\n\n1\n“Biscoe”\n\n\n2\n“Dream”\n\n\n3\n“Torgersen”\n\n\n\n\nEverything inside of {...} will be repeated three times.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#loop-iteration-1",
    "href": "modules/ModuleXX-Iteration.html#loop-iteration-1",
    "title": "Iteration in R",
    "section": "Loop iteration 1",
    "text": "Loop iteration 1\n\nisland_mean &lt;-\n    penguins$bill_depth_mm[penguins$island == \"Biscoe\"] |&gt;\n    mean(na.rm = TRUE) |&gt;\n    round(digits = 2)\n\ncat(paste(\"The mean bill depth on\", \"Biscoe\", \"Island was\", island_mean,\n                    \"mm.\\n\"))\n\nThe mean bill depth on Biscoe Island was 15.87 mm.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#loop-iteration-2",
    "href": "modules/ModuleXX-Iteration.html#loop-iteration-2",
    "title": "Iteration in R",
    "section": "Loop iteration 2",
    "text": "Loop iteration 2\n\nisland_mean &lt;-\n    penguins$bill_depth_mm[penguins$island == \"Dream\"] |&gt;\n    mean(na.rm = TRUE) |&gt;\n    round(digits = 2)\n\ncat(paste(\"The mean bill depth on\", \"Dream\", \"Island was\", island_mean,\n                    \"mm.\\n\"))\n\nThe mean bill depth on Dream Island was 18.34 mm.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#loop-iteration-3",
    "href": "modules/ModuleXX-Iteration.html#loop-iteration-3",
    "title": "Iteration in R",
    "section": "Loop iteration 3",
    "text": "Loop iteration 3\n\nisland_mean &lt;-\n    penguins$bill_depth_mm[penguins$island == \"Torgersen\"] |&gt;\n    mean(na.rm = TRUE) |&gt;\n    round(digits = 2)\n\ncat(paste(\"The mean bill depth on\", \"Torgersen\", \"Island was\", island_mean,\n                    \"mm.\\n\"))\n\nThe mean bill depth on Torgersen Island was 18.43 mm.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#the-loop-structure-automates-this-process-for-us-so-we-dont-have-to-copy",
    "href": "modules/ModuleXX-Iteration.html#the-loop-structure-automates-this-process-for-us-so-we-dont-have-to-copy",
    "title": "Iteration in R",
    "section": "The loop structure automates this process for us so we don’t have to copy",
    "text": "The loop structure automates this process for us so we don’t have to copy\nand paste our code!\n\nfor (this_island in levels(penguins$island)) {\n    island_mean &lt;-\n        penguins$bill_depth_mm[penguins$island == this_island] |&gt;\n        mean(na.rm = TRUE) |&gt;\n        round(digits = 2)\n    \n    cat(paste(\"The mean bill depth on\", this_island, \"Island was\", island_mean,\n                            \"mm.\\n\"))\n}\n\nThe mean bill depth on Biscoe Island was 15.87 mm.\nThe mean bill depth on Dream Island was 18.34 mm.\nThe mean bill depth on Torgersen Island was 18.43 mm.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#the-loop-structure-automates-this-process-for-us-so-we-dont-have-to-copy-and-paste-our-code",
    "href": "modules/ModuleXX-Iteration.html#the-loop-structure-automates-this-process-for-us-so-we-dont-have-to-copy-and-paste-our-code",
    "title": "Iteration in R",
    "section": "The loop structure automates this process for us so we don’t have to copy and paste our code!",
    "text": "The loop structure automates this process for us so we don’t have to copy and paste our code!\n\nfor (this_island in levels(penguins$island)) {\n    island_mean &lt;-\n        penguins$bill_depth_mm[penguins$island == this_island] |&gt;\n        mean(na.rm = TRUE) |&gt;\n        round(digits = 2)\n    \n    cat(paste(\"The mean bill depth on\", this_island, \"Island was\", island_mean,\n                            \"mm.\\n\"))\n}\n\nThe mean bill depth on Biscoe Island was 15.87 mm.\nThe mean bill depth on Dream Island was 18.34 mm.\nThe mean bill depth on Torgersen Island was 18.43 mm.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#remember-write-dry-code",
    "href": "modules/ModuleXX-Iteration.html#remember-write-dry-code",
    "title": "Iteration in R",
    "section": "Remember: write DRY code!",
    "text": "Remember: write DRY code!\n\nDRY = “Don’t Repeat Yourself”\nInstead of copying and pasting, write loops and functions.\nEasier to debug and change in the future!\n\n\n\nOf course, we all copy and paste code sometimes. If you are running on a tight deadline or can’t get a loop or function to work, you might need to. DRY code is good, but working code is best!",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#tweet-slide",
    "href": "modules/ModuleXX-Iteration.html#tweet-slide",
    "title": "Iteration in R",
    "section": "",
    "text": "quart",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#you-try-it",
    "href": "modules/ModuleXX-Iteration.html#you-try-it",
    "title": "Iteration in R",
    "section": "You try it!",
    "text": "You try it!\nWrite a loop that goes from 1 to 10, squares each of the numbers, and prints the squared number.\n\n\nfor (i in 1:10) {\n    cat(i ^ 2, \"\\n\")\n}\n\n1 \n4 \n9 \n16 \n25 \n36 \n49 \n64 \n81 \n100",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#wait-did-we-need-to-do-that",
    "href": "modules/ModuleXX-Iteration.html#wait-did-we-need-to-do-that",
    "title": "Iteration in R",
    "section": "Wait, did we need to do that?",
    "text": "Wait, did we need to do that?\n\nWell, yes, because you need to practice loops!\nBut technically no, because we can use vectorization.\nAlmost all basic operations in R are vectorized: they work on a vector of arguments all at the same time.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#wait-did-we-need-to-do-that-1",
    "href": "modules/ModuleXX-Iteration.html#wait-did-we-need-to-do-that-1",
    "title": "Iteration in R",
    "section": "Wait, did we need to do that?",
    "text": "Wait, did we need to do that?\n\nWell, yes, because you need to practice loops!\nBut technically no, because we can use vectorization.\nAlmost all basic operations in R are vectorized: they work on a vector of arguments all at the same time.\n\n\n# No loop needed!\n(1:10)^2\n\n [1]   1   4   9  16  25  36  49  64  81 100",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#wait-did-we-need-to-do-that-2",
    "href": "modules/ModuleXX-Iteration.html#wait-did-we-need-to-do-that-2",
    "title": "Iteration in R",
    "section": "Wait, did we need to do that?",
    "text": "Wait, did we need to do that?\n\nWell, yes, because you need to practice loops!\nBut technically no, because we can use vectorization.\nAlmost all basic operations in R are vectorized: they work on a vector of arguments all at the same time.\n\n\n# No loop needed!\n(1:10)^2\n\n [1]   1   4   9  16  25  36  49  64  81 100\n\n\n\n# Get the first 10 odd numbers, a common CS 101 loop problem on exams\n(1:20)[which((1:20 %% 2) == 1)]\n\n [1]  1  3  5  7  9 11 13 15 17 19\n\n\n\nSo you should really try vectorization first, then use loops only when you can’t use vectorization.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#loop-walkthrough",
    "href": "modules/ModuleXX-Iteration.html#loop-walkthrough",
    "title": "Iteration in R",
    "section": "Loop walkthrough",
    "text": "Loop walkthrough\n\nLet’s walk through a complex but useful example where we can’t use vectorization.\nLoad the cleaned measles dataset, and subset it so you only have MCV1 records.\n\n\n\nmeas &lt;- readRDS(here::here(\"data\", \"measles_final.Rds\")) |&gt;\n    subset(vaccine_antigen == \"MCV1\")\nstr(meas)\n\n'data.frame':   7972 obs. of  7 variables:\n $ iso3c           : chr  \"AFG\" \"AFG\" \"AFG\" \"AFG\" ...\n $ time            : int  1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 ...\n $ country         : chr  \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" ...\n $ Cases           : int  2792 5166 2900 640 353 2012 1511 638 1154 492 ...\n $ vaccine_antigen : chr  \"MCV1\" \"MCV1\" \"MCV1\" \"MCV1\" ...\n $ vaccine_coverage: int  11 NA 8 9 14 14 14 31 34 22 ...\n $ total_pop       : chr  \"12486631\" \"11155195\" \"10088289\" \"9951449\" ...",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#loop-walkthrough-1",
    "href": "modules/ModuleXX-Iteration.html#loop-walkthrough-1",
    "title": "Iteration in R",
    "section": "Loop walkthrough",
    "text": "Loop walkthrough\n\nFirst, make an empty list. This is where we’ll store our results. Make it the same length as the number of countries in the dataset.\n\n\n\nres &lt;- vector(mode = \"list\", length = length(unique(meas$country)))\n\n\nThis is called preallocation and it can make your loops much faster.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#loop-walkthrough-2",
    "href": "modules/ModuleXX-Iteration.html#loop-walkthrough-2",
    "title": "Iteration in R",
    "section": "Loop walkthrough",
    "text": "Loop walkthrough\n\nLoop through every country in the dataset, and get the median, first and third quartiles, and range for each country. Store those summary statistics in a data frame.\nWhat should the header look like?\n\n\n\ncountries &lt;- unique(meas$country)\nfor (i in 1:length(countries)) {...}\n\n\n\n\nNote that we use the index as the control variable. When you need to do complex operations inside a loop, this is easier than the for-each construction we used earlier.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#loop-walkthrough-3",
    "href": "modules/ModuleXX-Iteration.html#loop-walkthrough-3",
    "title": "Iteration in R",
    "section": "Loop walkthrough",
    "text": "Loop walkthrough\n\nNow write out the body of the code. First we need to subset the data, to get only the data for the current country.\n\n\n\nfor (i in 1:length(countries)) {\n    # Get the data for the current country only\n    country_data &lt;- subset(meas, country == countries[i])\n}\n\n\n\n\nNext we need to get the summary of the cases for that country.\n\n\n\n\nfor (i in 1:length(countries)) {\n    # Get the data for the current country only\n    country_data &lt;- subset(meas, country == countries[i])\n    \n    # Get the summary statistics for this country\n    country_cases &lt;- country_data$Cases\n    country_med &lt;- median(country_cases, na.rm = TRUE)\n    country_iqr &lt;- IQR(country_cases, na.rm = TRUE)\n    country_range &lt;- range(country_cases, na.rm = TRUE)\n}\n\n\n\n\nNext we save the summary statistics into a data frame.\n\n\nfor (i in 1:length(countries)) {\n    # Get the data for the current country only\n    country_data &lt;- subset(meas, country == countries[i])\n    \n    # Get the summary statistics for this country\n    country_cases &lt;- country_data$Cases\n    country_quart &lt;- quantile(\n        country_cases, na.rm = TRUE, probs = c(0.25, 0.5, 0.75)\n    )\n    country_range &lt;- range(country_cases, na.rm = TRUE)\n    \n    # Save the summary statistics into a data frame\n    country_summary &lt;- data.frame(\n        country = countries[[i]],\n        min = country_range[[1]],\n        Q1 = country_quart[[1]],\n        median = country_quart[[2]],\n        Q3 = country_quart[[3]],\n        max = country_range[[2]]\n    )\n}\n\n\n\n\nAnd finally, we save the data frame as the next element in our storage list.\n\n\nfor (i in 1:length(countries)) {\n    # Get the data for the current country only\n    country_data &lt;- subset(meas, country == countries[i])\n    \n    # Get the summary statistics for this country\n    country_cases &lt;- country_data$Cases\n    country_quart &lt;- quantile(\n        country_cases, na.rm = TRUE, probs = c(0.25, 0.5, 0.75)\n    )\n    country_range &lt;- range(country_cases, na.rm = TRUE)\n    \n    # Save the summary statistics into a data frame\n    country_summary &lt;- data.frame(\n        country = countries[[i]],\n        min = country_range[[1]],\n        Q1 = country_quart[[1]],\n        median = country_quart[[2]],\n        Q3 = country_quart[[3]],\n        max = country_range[[2]]\n    )\n    \n    # Save the results to our container\n    res[[i]] &lt;- country_summary\n}\n\nWarning in min(x): no non-missing arguments to min; returning Inf\n\n\nWarning in max(x): no non-missing arguments to max; returning -Inf\n\n\nWarning in min(x): no non-missing arguments to min; returning Inf\n\n\nWarning in max(x): no non-missing arguments to max; returning -Inf\n\n\nWarning in min(x): no non-missing arguments to min; returning Inf\n\n\nWarning in max(x): no non-missing arguments to max; returning -Inf\n\n\n\n\n\nLet’s take a look at the results.\n\n\nhead(res)\n\n[[1]]\n      country min   Q1 median   Q3   max\n1 Afghanistan 353 1154   2205 5166 31107\n\n[[2]]\n  country min  Q1 median    Q3   max\n1  Angola  29 700   3271 14474 30067\n\n[[3]]\n  country min Q1 median Q3    max\n1 Albania   0  1     12 29 136034\n\n[[4]]\n  country min Q1 median Q3 max\n1 Andorra   0  0      1  2   5\n\n[[5]]\n               country min    Q1 median   Q3  max\n1 United Arab Emirates  22 89.75    320 1128 2913\n\n[[6]]\n    country min Q1 median     Q3   max\n1 Argentina   0  0     17 4591.5 42093\n\n\n\nHow do we deal with this to get it into a nice form?\n\n\n\n\nWe can use a vectorization trick: the function do.call() seems like ancient computer science magic. And it is. But it will actually help us a lot.\n\n\nres_df &lt;- do.call(rbind, res)\nhead(res_df)\n\n\n\n\ncountry\nmin\nQ1\nmedian\nQ3\nmax\n\n\n\n\nAfghanistan\n353\n1154.00\n2205\n5166.0\n31107\n\n\nAngola\n29\n700.00\n3271\n14474.0\n30067\n\n\nAlbania\n0\n1.00\n12\n29.0\n136034\n\n\nAndorra\n0\n0.00\n1\n2.0\n5\n\n\nUnited Arab Emirates\n22\n89.75\n320\n1128.0\n2913\n\n\nArgentina\n0\n0.00\n17\n4591.5\n42093\n\n\n\n\n\n\nIt combined our data frames together! Let’s take a look at the rbind and do.call() help packages to see what happened.\n\n\n\n\n?rbind\n\nCombine R Objects by Rows or Columns\n\nDescription:\n\n     Take a sequence of vector, matrix or data-frame arguments and\n     combine by _c_olumns or _r_ows, respectively.  These are generic\n     functions with methods for other R classes.\n\nUsage:\n\n     cbind(..., deparse.level = 1)\n     rbind(..., deparse.level = 1)\n     ## S3 method for class 'data.frame'\n     rbind(..., deparse.level = 1, make.row.names = TRUE,\n           stringsAsFactors = FALSE, factor.exclude = TRUE)\n     \nArguments:\n\n     ...: (generalized) vectors or matrices.  These can be given as\n          named arguments.  Other R objects may be coerced as\n          appropriate, or S4 methods may be used: see sections\n          'Details' and 'Value'.  (For the '\"data.frame\"' method of\n          'cbind' these can be further arguments to 'data.frame' such\n          as 'stringsAsFactors'.)\n\ndeparse.level: integer controlling the construction of labels in the\n          case of non-matrix-like arguments (for the default method):\n          'deparse.level = 0' constructs no labels;\n          the default 'deparse.level = 1' typically and 'deparse.level\n          = 2' always construct labels from the argument names, see the\n          'Value' section below.\n\nmake.row.names: (only for data frame method:) logical indicating if\n          unique and valid 'row.names' should be constructed from the\n          arguments.\n\nstringsAsFactors: logical, passed to 'as.data.frame'; only has an\n          effect when the '...' arguments contain a (non-'data.frame')\n          'character'.\n\nfactor.exclude: if the data frames contain factors, the default 'TRUE'\n          ensures that 'NA' levels of factors are kept, see PR#17562\n          and the 'Data frame methods'.  In R versions up to 3.6.x,\n          'factor.exclude = NA' has been implicitly hardcoded (R &lt;=\n          3.6.0) or the default (R = 3.6.x, x &gt;= 1).\n\nDetails:\n\n     The functions 'cbind' and 'rbind' are S3 generic, with methods for\n     data frames.  The data frame method will be used if at least one\n     argument is a data frame and the rest are vectors or matrices.\n     There can be other methods; in particular, there is one for time\n     series objects.  See the section on 'Dispatch' for how the method\n     to be used is selected.  If some of the arguments are of an S4\n     class, i.e., 'isS4(.)' is true, S4 methods are sought also, and\n     the hidden 'cbind' / 'rbind' functions from package 'methods'\n     maybe called, which in turn build on 'cbind2' or 'rbind2',\n     respectively.  In that case, 'deparse.level' is obeyed, similarly\n     to the default method.\n\n     In the default method, all the vectors/matrices must be atomic\n     (see 'vector') or lists.  Expressions are not allowed.  Language\n     objects (such as formulae and calls) and pairlists will be coerced\n     to lists: other objects (such as names and external pointers) will\n     be included as elements in a list result.  Any classes the inputs\n     might have are discarded (in particular, factors are replaced by\n     their internal codes).\n\n     If there are several matrix arguments, they must all have the same\n     number of columns (or rows) and this will be the number of columns\n     (or rows) of the result.  If all the arguments are vectors, the\n     number of columns (rows) in the result is equal to the length of\n     the longest vector.  Values in shorter arguments are recycled to\n     achieve this length (with a 'warning' if they are recycled only\n     _fractionally_).\n\n     When the arguments consist of a mix of matrices and vectors the\n     number of columns (rows) of the result is determined by the number\n     of columns (rows) of the matrix arguments.  Any vectors have their\n     values recycled or subsetted to achieve this length.\n\n     For 'cbind' ('rbind'), vectors of zero length (including 'NULL')\n     are ignored unless the result would have zero rows (columns), for\n     S compatibility.  (Zero-extent matrices do not occur in S3 and are\n     not ignored in R.)\n\n     Matrices are restricted to less than 2^31 rows and columns even on\n     64-bit systems.  So input vectors have the same length\n     restriction: as from R 3.2.0 input matrices with more elements\n     (but meeting the row and column restrictions) are allowed.\n\nValue:\n\n     For the default method, a matrix combining the '...' arguments\n     column-wise or row-wise.  (Exception: if there are no inputs or\n     all the inputs are 'NULL', the value is 'NULL'.)\n\n     The type of a matrix result determined from the highest type of\n     any of the inputs in the hierarchy raw &lt; logical &lt; integer &lt;\n     double &lt; complex &lt; character &lt; list .\n\n     For 'cbind' ('rbind') the column (row) names are taken from the\n     'colnames' ('rownames') of the arguments if these are matrix-like.\n     Otherwise from the names of the arguments or where those are not\n     supplied and 'deparse.level &gt; 0', by deparsing the expressions\n     given, for 'deparse.level = 1' only if that gives a sensible name\n     (a 'symbol', see 'is.symbol').\n\n     For 'cbind' row names are taken from the first argument with\n     appropriate names: rownames for a matrix, or names for a vector of\n     length the number of rows of the result.\n\n     For 'rbind' column names are taken from the first argument with\n     appropriate names: colnames for a matrix, or names for a vector of\n     length the number of columns of the result.\n\nData frame methods:\n\n     The 'cbind' data frame method is just a wrapper for\n     'data.frame(..., check.names = FALSE)'.  This means that it will\n     split matrix columns in data frame arguments, and convert\n     character columns to factors unless 'stringsAsFactors = FALSE' is\n     specified.\n\n     The 'rbind' data frame method first drops all zero-column and\n     zero-row arguments.  (If that leaves none, it returns the first\n     argument with columns otherwise a zero-column zero-row data\n     frame.)  It then takes the classes of the columns from the first\n     data frame, and matches columns by name (rather than by position).\n     Factors have their levels expanded as necessary (in the order of\n     the levels of the level sets of the factors encountered) and the\n     result is an ordered factor if and only if all the components were\n     ordered factors.  Old-style categories (integer vectors with\n     levels) are promoted to factors.\n\n     Note that for result column 'j', 'factor(., exclude = X(j))' is\n     applied, where\n\n       X(j) := if(isTRUE(factor.exclude)) {\n                  if(!NA.lev[j]) NA # else NULL\n               } else factor.exclude\n     \n     where 'NA.lev[j]' is true iff any contributing data frame has had\n     a 'factor' in column 'j' with an explicit 'NA' level.\n\nDispatch:\n\n     The method dispatching is _not_ done via 'UseMethod()', but by\n     C-internal dispatching.  Therefore there is no need for, e.g.,\n     'rbind.default'.\n\n     The dispatch algorithm is described in the source file\n     ('.../src/main/bind.c') as\n\n       1. For each argument we get the list of possible class\n          memberships from the class attribute.\n\n       2. We inspect each class in turn to see if there is an\n          applicable method.\n\n       3. If we find a method, we use it.  Otherwise, if there was an\n          S4 object among the arguments, we try S4 dispatch; otherwise,\n          we use the default code.\n\n     If you want to combine other objects with data frames, it may be\n     necessary to coerce them to data frames first.  (Note that this\n     algorithm can result in calling the data frame method if all the\n     arguments are either data frames or vectors, and this will result\n     in the coercion of character vectors to factors.)\n\nReferences:\n\n     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S\n     Language_.  Wadsworth & Brooks/Cole.\n\nSee Also:\n\n     'c' to combine vectors (and lists) as vectors, 'data.frame' to\n     combine vectors and matrices as a data frame.\n\nExamples:\n\n     m &lt;- cbind(1, 1:7) # the '1' (= shorter vector) is recycled\n     m\n     m &lt;- cbind(m, 8:14)[, c(1, 3, 2)] # insert a column\n     m\n     cbind(1:7, diag(3)) # vector is subset -&gt; warning\n     \n     cbind(0, rbind(1, 1:3))\n     cbind(I = 0, X = rbind(a = 1, b = 1:3))  # use some names\n     xx &lt;- data.frame(I = rep(0,2))\n     cbind(xx, X = rbind(a = 1, b = 1:3))   # named differently\n     \n     cbind(0, matrix(1, nrow = 0, ncol = 4)) #&gt; Warning (making sense)\n     dim(cbind(0, matrix(1, nrow = 2, ncol = 0))) #-&gt; 2 x 1\n     \n     ## deparse.level\n     dd &lt;- 10\n     rbind(1:4, c = 2, \"a++\" = 10, dd, deparse.level = 0) # middle 2 rownames\n     rbind(1:4, c = 2, \"a++\" = 10, dd, deparse.level = 1) # 3 rownames (default)\n     rbind(1:4, c = 2, \"a++\" = 10, dd, deparse.level = 2) # 4 rownames\n     \n     ## cheap row names:\n     b0 &lt;- gl(3,4, labels=letters[1:3])\n     bf &lt;- setNames(b0, paste0(\"o\", seq_along(b0)))\n     df  &lt;- data.frame(a = 1, B = b0, f = gl(4,3))\n     df. &lt;- data.frame(a = 1, B = bf, f = gl(4,3))\n     new &lt;- data.frame(a = 8, B =\"B\", f = \"1\")\n     (df1  &lt;- rbind(df , new))\n     (df.1 &lt;- rbind(df., new))\n     stopifnot(identical(df1, rbind(df,  new, make.row.names=FALSE)),\n               identical(df1, rbind(df., new, make.row.names=FALSE)))\n\n\n\n\n\n?do.call\n\nExecute a Function Call\n\nDescription:\n\n     'do.call' constructs and executes a function call from a name or a\n     function and a list of arguments to be passed to it.\n\nUsage:\n\n     do.call(what, args, quote = FALSE, envir = parent.frame())\n     \nArguments:\n\n    what: either a function or a non-empty character string naming the\n          function to be called.\n\n    args: a _list_ of arguments to the function call.  The 'names'\n          attribute of 'args' gives the argument names.\n\n   quote: a logical value indicating whether to quote the arguments.\n\n   envir: an environment within which to evaluate the call.  This will\n          be most useful if 'what' is a character string and the\n          arguments are symbols or quoted expressions.\n\nDetails:\n\n     If 'quote' is 'FALSE', the default, then the arguments are\n     evaluated (in the calling environment, not in 'envir').  If\n     'quote' is 'TRUE' then each argument is quoted (see 'quote') so\n     that the effect of argument evaluation is to remove the quotes -\n     leaving the original arguments unevaluated when the call is\n     constructed.\n\n     The behavior of some functions, such as 'substitute', will not be\n     the same for functions evaluated using 'do.call' as if they were\n     evaluated from the interpreter.  The precise semantics are\n     currently undefined and subject to change.\n\nValue:\n\n     The result of the (evaluated) function call.\n\nWarning:\n\n     This should not be used to attempt to evade restrictions on the\n     use of '.Internal' and other non-API calls.\n\nReferences:\n\n     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S\n     Language_.  Wadsworth & Brooks/Cole.\n\nSee Also:\n\n     'call' which creates an unevaluated call.\n\nExamples:\n\n     do.call(\"complex\", list(imaginary = 1:3))\n     \n     ## if we already have a list (e.g., a data frame)\n     ## we need c() to add further arguments\n     tmp &lt;- expand.grid(letters[1:2], 1:3, c(\"+\", \"-\"))\n     do.call(\"paste\", c(tmp, sep = \"\"))\n     \n     do.call(paste, list(as.name(\"A\"), as.name(\"B\")), quote = TRUE)\n     \n     ## examples of where objects will be found.\n     A &lt;- 2\n     f &lt;- function(x) print(x^2)\n     env &lt;- new.env()\n     assign(\"A\", 10, envir = env)\n     assign(\"f\", f, envir = env)\n     f &lt;- function(x) print(x)\n     f(A)                                      # 2\n     do.call(\"f\", list(A))                     # 2\n     do.call(\"f\", list(A), envir = env)        # 4\n     do.call( f,  list(A), envir = env)        # 2\n     do.call(\"f\", list(quote(A)), envir = env) # 100\n     do.call( f,  list(quote(A)), envir = env) # 10\n     do.call(\"f\", list(as.name(\"A\")), envir = env) # 100\n     \n     eval(call(\"f\", A))                      # 2\n     eval(call(\"f\", quote(A)))               # 2\n     eval(call(\"f\", A), envir = env)         # 4\n     eval(call(\"f\", quote(A)), envir = env)  # 100\n\n\n\n\n\nOK, so basically what happened is that\n\n\ndo.call(rbind, list)\n\n\nGets transformed into\n\n\nrbind(list[[1]], list[[2]], list[[3]], ..., list[[length(list)]])\n\n\nThat’s vectorization magic!",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#you-try-it-if-we-have-time",
    "href": "modules/ModuleXX-Iteration.html#you-try-it-if-we-have-time",
    "title": "Iteration in R",
    "section": "You try it! (if we have time)",
    "text": "You try it! (if we have time)\n\nUse the code you wrote before the get the incidence per 1000 people on the entire measles data set (add a column for incidence to the full data).\nUse the code plot(NULL, NULL, ...) to make a blank plot. You will need to set the xlim and ylim arguments to sensible values, and specify the axis titles as “Year” and “Incidence per 1000 people”.\nUsing a for loop and the lines() function, make a plot that shows all of the incidence curves over time, overlapping on the plot.\nHINT: use col = adjustcolor(black, alpha.f = 0.25) to make the curves transparent, so you can see the others.\nBONUS PROBLEM: using the function cumsum(), make a plot of the cumulative incidence per 1000 people over time for all of the countries. (Dealing with the NA’s here is tricky!!)",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#main-problem-solution",
    "href": "modules/ModuleXX-Iteration.html#main-problem-solution",
    "title": "Iteration in R",
    "section": "Main problem solution",
    "text": "Main problem solution\n\nmeas$cases_per_thousand &lt;- meas$Cases / as.numeric(meas$total_pop) * 1000\ncountries &lt;- unique(meas$country)\n\nplot(\n    NULL, NULL,\n    xlim = c(1980, 2022),\n    ylim = c(0, 50),\n    xlab = \"Year\",\n    ylab = \"Incidence per 1000 people\"\n)\n\nfor (i in 1:length(countries)) {\n    country_data &lt;- subset(meas, country == countries[[i]])\n    lines(\n        x = country_data$time,\n        y = country_data$cases_per_thousand,\n        col = adjustcolor(\"black\", alpha.f = 0.25)\n    )\n}",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#bonus-problem-solution",
    "href": "modules/ModuleXX-Iteration.html#bonus-problem-solution",
    "title": "Iteration in R",
    "section": "Bonus problem solution",
    "text": "Bonus problem solution\n\n# First calculate the cumulative cases, treating NA as zeroes\ncumulative_cases &lt;- ave(\n    x = ifelse(is.na(meas$Cases), 0, meas$Cases),\n    meas$country,\n    FUN = cumsum\n)\n\n# Now put the NAs back where they should be\nmeas$cumulative_cases &lt;- cumulative_cases + (meas$Cases * 0)\n\nplot(\n    NULL, NULL,\n    xlim = c(1980, 2022),\n    ylim = c(1, 6.2e6),\n    xlab = \"Year\",\n    ylab = \"Cumulative cases per 1000 people\"\n)\n\nfor (i in 1:length(countries)) {\n    country_data &lt;- subset(meas, country == countries[[i]])\n    lines(\n        x = country_data$time,\n        y = country_data$cumulative_cases,\n        col = adjustcolor(\"black\", alpha.f = 0.25)\n    )\n}\n\ntext(\n    x = 2020,\n    y = 6e6,\n    labels = \"China →\"\n)",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#main-problem-solution-1",
    "href": "modules/ModuleXX-Iteration.html#main-problem-solution-1",
    "title": "Iteration in R",
    "section": "Main problem solution",
    "text": "Main problem solution",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#bonus-problem-solution-1",
    "href": "modules/ModuleXX-Iteration.html#bonus-problem-solution-1",
    "title": "Iteration in R",
    "section": "Bonus problem solution",
    "text": "Bonus problem solution",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#more-practice-on-your-own",
    "href": "modules/ModuleXX-Iteration.html#more-practice-on-your-own",
    "title": "Iteration in R",
    "section": "More practice on your own",
    "text": "More practice on your own\n\nMerge the countries-regions.csv data with the measles_final.Rds data. Reshape the measles data so that MCV1 and MCV2 vaccine coverage are two separate columns. Then use a loop to fit a poisson regression model for each continent where Cases is the outcome, and MCV1 coverage and MCV2 coverage are the predictors. Discuss your findings, and try adding an interation term.\nAssess the impact of age_months as a confounder in the Diphtheria serology data. First, write code to transform age_months into age ranges for each year. Then, using a loop, calculate the crude odds ratio for the effect of vaccination on infection for each of the age ranges. How does the odds ratio change as age increases? Can you formalize this analysis by fitting a logistic regression model with age_months and vaccination as predictors?",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-RMarkdown.html#learning-goals",
    "href": "modules/ModuleXX-RMarkdown.html#learning-goals",
    "title": "Literate Programming",
    "section": "Learning goals",
    "text": "Learning goals\n\nDefine literate programming\nImplement literate programming in R using knitr and either R Markdown or Quarto\nInclude plots, tables, and references along with your code in a written report.\nLocate additional resources for literate programming with R Markdown or Quarto."
  },
  {
    "objectID": "modules/ModuleXX-RMarkdown.html#what-is-literate-programming",
    "href": "modules/ModuleXX-RMarkdown.html#what-is-literate-programming",
    "title": "Literate Programming",
    "section": "What is literate programming?",
    "text": "What is literate programming?\n\nProgramming files contain code along with text, code results, and other supporting information.\nInstead of having separate code and text, that you glue together in Word, we have one document which combines code and text."
  },
  {
    "objectID": "modules/ModuleXX-RMarkdown.html#literate-programming-examples",
    "href": "modules/ModuleXX-RMarkdown.html#literate-programming-examples",
    "title": "Literate Programming",
    "section": "Literate programming examples",
    "text": "Literate programming examples\n\nWriting a research paper with R Markdown: https://github.com/wzbillings/Patient-vs-Clinician-Symptom-Reports\nWriting a book with R Markdown: https://github.com/moderndive/ModernDive_book\nPersonal websites (like my tutorial!): https://jadeyryan.com/blog/2024-02-19_beginner-quarto-netlify/\nOther examples: https://bookdown.org/yihui/rmarkdown/basics-examples.html"
  },
  {
    "objectID": "modules/ModuleXX-RMarkdown.html#r-markdown-and-quarto",
    "href": "modules/ModuleXX-RMarkdown.html#r-markdown-and-quarto",
    "title": "Literate Programming",
    "section": "R Markdown and Quarto",
    "text": "R Markdown and Quarto\n\nR Markdown and Quarto are both implementations of literate programming using R, with the knitr package for the backend. Both are supported by RStudio.\nTo use R Markdown, you need to install.packages(\"rmarkdown\").\nQuarto comes with new versions of RStudio, but you can also install the latest version from the Quarto website.\nR Markdown is older and now very commonly used. Quarto is newer and so has many fancy new features, but more bugs that are constantly being found and fixed.\nIn this class, we will use R Markdown. But if you decide to use quarto, 90% of your knowledge will transfer since they are very similar.\n\nAdvantages of R Markdown: more online resources, most common bugs have been fixed over the years, many people are familiar with it.\nAdvantages of Quarto: supports other programming languages like Python and Julia, uses more modern syntax, less slapped together overall."
  },
  {
    "objectID": "modules/ModuleXX-RMarkdown.html#what-is-literate-programming-1",
    "href": "modules/ModuleXX-RMarkdown.html#what-is-literate-programming-1",
    "title": "Literate Programming",
    "section": "What is literate programming?",
    "text": "What is literate programming?\n\nR markdown example, from https://rmarkdown.rstudio.com/authoring_quick_tour.html"
  },
  {
    "objectID": "modules/ModuleXX-RMarkdown.html#a-few-sticking-points",
    "href": "modules/ModuleXX-RMarkdown.html#a-few-sticking-points",
    "title": "Literate Programming",
    "section": "A few sticking points",
    "text": "A few sticking points\n\nKnitting to html format is really easy, but most scientist don’t like html format for some reason. If you want to knit to pdf, you should install the package tinytex and read the intro.\nIf you want to knit to word (what many journals in epidemiology require), you need to have Word installed on your computer. Note that with word, you are a bit more restricted in your formatting options, so if weird things happen you’ll have to try some other options.\nYou maybe noticed in the tutorial that I used the here::here() function for all of my file paths. This is because R Markdown and Quarto files use a different working directory from the R Project. Using here::here() translates relative paths into absolute paths based on your R Project, so it makes sure your R Markdown files can always find the right path!"
  },
  {
    "objectID": "modules/ModuleXX-RMarkdown.html#you-try-it",
    "href": "modules/ModuleXX-RMarkdown.html#you-try-it",
    "title": "Literate Programming",
    "section": "You try it!",
    "text": "You try it!\n\nCreate an R Markdown document. Write about either the measles or diphtheria example data sets, and include a figure and a table.\nBONUS EXERCISE: read the intro of the bookdown book, and create a bookdown document. Modify your writeup to have a few references with a bibliography, and cross-references with your figures and tables.\nBONUS: Try to structure your document like a report, with a section stating the questions you want to answer (intro), a section with your R code and results, and a section with your interpretations (discussion). This is a very open ended exercise but by now I believe you can do it, and you’ll have a nice document you can put on your portfolio or show employers!"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#learning-objectives",
    "href": "modules/Module10-DataVisualization.html#learning-objectives",
    "title": "Module 10: Data Visualization",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nAfter module 10, you should be able to:\n\nCreate Base R plots"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#import-data-for-this-module",
    "href": "modules/Module10-DataVisualization.html#import-data-for-this-module",
    "title": "Module 10: Data Visualization",
    "section": "Import data for this module",
    "text": "Import data for this module\nLet’s read in our data (again) and take a quick look.\n\ndf &lt;- read.csv(file = \"data/serodata.csv\") #relative path\nhead(x=df, n=3)\n\n  observation_id IgG_concentration age gender     slum\n1           5772         0.3176895   2 Female Non slum\n2           8095         3.4368231   4 Female Non slum\n3           9784         0.3000000   4   Male Non slum"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#prep-data",
    "href": "modules/Module10-DataVisualization.html#prep-data",
    "title": "Module 10: Data Visualization",
    "section": "Prep data",
    "text": "Prep data\nCreate age_group three level factor variable\n\ndf$age_group &lt;- ifelse(df$age &lt;= 5, \"young\", \n                       ifelse(df$age&lt;=10 & df$age&gt;5, \"middle\", \n                              ifelse(df$age&gt;10, \"old\", NA)))\ndf$age_group &lt;- factor(df$age_group, levels=c(\"young\", \"middle\", \"old\"))\n\nCreate seropos binary variable representing seropositivity if antibody concentrations are &gt;10 mIUmL.\n\ndf$seropos &lt;- ifelse(df$IgG_concentration&lt;10, 0, \n                                        ifelse(df$IgG_concentration&gt;=10, 1, NA))"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#base-r-data-visualizattion-functions",
    "href": "modules/Module10-DataVisualization.html#base-r-data-visualizattion-functions",
    "title": "Module 10: Data Visualization",
    "section": "Base R data visualizattion functions",
    "text": "Base R data visualizattion functions\nThe Base R ‘graphics’ package has a ton of graphics options.\n\nlibrary(help = \"graphics\")\n\n\n\nRegistered S3 method overwritten by 'printr':\n  method                from     \n  knit_print.data.frame rmarkdown\n\n\n        Information on package 'graphics'\n\nDescription:\n\nPackage:            graphics\nVersion:            4.3.1\nPriority:           base\nTitle:              The R Graphics Package\nAuthor:             R Core Team and contributors worldwide\nMaintainer:         R Core Team &lt;do-use-Contact-address@r-project.org&gt;\nContact:            R-help mailing list &lt;r-help@r-project.org&gt;\nDescription:        R functions for base graphics.\nImports:            grDevices\nLicense:            Part of R 4.3.1\nNeedsCompilation:   yes\nBuilt:              R 4.3.1; aarch64-apple-darwin20; 2023-06-16\n                    21:53:01 UTC; unix\n\nIndex:\n\nAxis                    Generic Function to Add an Axis to a Plot\nabline                  Add Straight Lines to a Plot\narrows                  Add Arrows to a Plot\nassocplot               Association Plots\naxTicks                 Compute Axis Tickmark Locations\naxis                    Add an Axis to a Plot\naxis.POSIXct            Date and Date-time Plotting Functions\nbarplot                 Bar Plots\nbox                     Draw a Box around a Plot\nboxplot                 Box Plots\nboxplot.matrix          Draw a Boxplot for each Column (Row) of a\n                        Matrix\nbxp                     Draw Box Plots from Summaries\ncdplot                  Conditional Density Plots\nclip                    Set Clipping Region\ncontour                 Display Contours\ncoplot                  Conditioning Plots\ncurve                   Draw Function Plots\ndotchart                Cleveland's Dot Plots\nfilled.contour          Level (Contour) Plots\nfourfoldplot            Fourfold Plots\nframe                   Create / Start a New Plot Frame\ngraphics-package        The R Graphics Package\ngrconvertX              Convert between Graphics Coordinate Systems\ngrid                    Add Grid to a Plot\nhist                    Histograms\nhist.POSIXt             Histogram of a Date or Date-Time Object\nidentify                Identify Points in a Scatter Plot\nimage                   Display a Color Image\nlayout                  Specifying Complex Plot Arrangements\nlegend                  Add Legends to Plots\nlines                   Add Connected Line Segments to a Plot\nlocator                 Graphical Input\nmatplot                 Plot Columns of Matrices\nmosaicplot              Mosaic Plots\nmtext                   Write Text into the Margins of a Plot\npairs                   Scatterplot Matrices\npanel.smooth            Simple Panel Plot\npar                     Set or Query Graphical Parameters\npersp                   Perspective Plots\npie                     Pie Charts\nplot.data.frame         Plot Method for Data Frames\nplot.default            The Default Scatterplot Function\nplot.design             Plot Univariate Effects of a Design or Model\nplot.factor             Plotting Factor Variables\nplot.formula            Formula Notation for Scatterplots\nplot.histogram          Plot Histograms\nplot.raster             Plotting Raster Images\nplot.table              Plot Methods for 'table' Objects\nplot.window             Set up World Coordinates for Graphics Window\nplot.xy                 Basic Internal Plot Function\npoints                  Add Points to a Plot\npolygon                 Polygon Drawing\npolypath                Path Drawing\nrasterImage             Draw One or More Raster Images\nrect                    Draw One or More Rectangles\nrug                     Add a Rug to a Plot\nscreen                  Creating and Controlling Multiple Screens on a\n                        Single Device\nsegments                Add Line Segments to a Plot\nsmoothScatter           Scatterplots with Smoothed Densities Color\n                        Representation\nspineplot               Spine Plots and Spinograms\nstars                   Star (Spider/Radar) Plots and Segment Diagrams\nstem                    Stem-and-Leaf Plots\nstripchart              1-D Scatter Plots\nstrwidth                Plotting Dimensions of Character Strings and\n                        Math Expressions\nsunflowerplot           Produce a Sunflower Scatter Plot\nsymbols                 Draw Symbols (Circles, Squares, Stars,\n                        Thermometers, Boxplots)\ntext                    Add Text to a Plot\ntitle                   Plot Annotation\nxinch                   Graphical Units\nxspline                 Draw an X-spline"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#focus-on-a-handful-here-today",
    "href": "modules/Module10-DataVisualization.html#focus-on-a-handful-here-today",
    "title": "Module 10: Data Visualization",
    "section": "Focus on a handful here today",
    "text": "Focus on a handful here today\n\n  `hist()` displays histogram of one variable\n  `plot()` displays x-y plot of two variables\n  `boxplot()` displays boxplot \n  `barplot()` displays barplot"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#histogram-help-file",
    "href": "modules/Module10-DataVisualization.html#histogram-help-file",
    "title": "Module 10: Data Visualization",
    "section": "histogram() Help File",
    "text": "histogram() Help File\n\n?hist\n\nHistograms\nDescription:\n The generic function 'hist' computes a histogram of the given data\n values.  If 'plot = TRUE', the resulting object of class\n '\"histogram\"' is plotted by 'plot.histogram', before it is\n returned.\nUsage:\n hist(x, ...)\n \n ## Default S3 method:\n hist(x, breaks = \"Sturges\",\n      freq = NULL, probability = !freq,\n      include.lowest = TRUE, right = TRUE, fuzz = 1e-7,\n      density = NULL, angle = 45, col = \"lightgray\", border = NULL,\n      main = paste(\"Histogram of\" , xname),\n      xlim = range(breaks), ylim = NULL,\n      xlab = xname, ylab,\n      axes = TRUE, plot = TRUE, labels = FALSE,\n      nclass = NULL, warn.unused = TRUE, ...)\n \nArguments:\n   x: a vector of values for which the histogram is desired.\nbreaks: one of:\n        • a vector giving the breakpoints between histogram cells,\n\n        • a function to compute the vector of breakpoints,\n\n        • a single number giving the number of cells for the\n          histogram,\n\n        • a character string naming an algorithm to compute the\n          number of cells (see 'Details'),\n\n        • a function to compute the number of cells.\n\n      In the last three cases the number is a suggestion only; as\n      the breakpoints will be set to 'pretty' values, the number is\n      limited to '1e6' (with a warning if it was larger).  If\n      'breaks' is a function, the 'x' vector is supplied to it as\n      the only argument (and the number of breaks is only limited\n      by the amount of available memory).\n\nfreq: logical; if 'TRUE', the histogram graphic is a representation\n      of frequencies, the 'counts' component of the result; if\n      'FALSE', probability densities, component 'density', are\n      plotted (so that the histogram has a total area of one).\n      Defaults to 'TRUE' _if and only if_ 'breaks' are equidistant\n      (and 'probability' is not specified).\nprobability: an alias for ‘!freq’, for S compatibility.\ninclude.lowest: logical; if ‘TRUE’, an ‘x[i]’ equal to the ‘breaks’ value will be included in the first (or last, for ‘right = FALSE’) bar. This will be ignored (with a warning) unless ‘breaks’ is a vector.\nright: logical; if ‘TRUE’, the histogram cells are right-closed (left open) intervals.\nfuzz: non-negative number, for the case when the data is \"pretty\"\n      and some observations 'x[.]' are close but not exactly on a\n      'break'.  For counting fuzzy breaks proportional to 'fuzz'\n      are used.  The default is occasionally suboptimal.\ndensity: the density of shading lines, in lines per inch. The default value of ‘NULL’ means that no shading lines are drawn. Non-positive values of ‘density’ also inhibit the drawing of shading lines.\nangle: the slope of shading lines, given as an angle in degrees (counter-clockwise).\n col: a colour to be used to fill the bars.\nborder: the color of the border around the bars. The default is to use the standard foreground color.\nmain, xlab, ylab: main title and axis labels: these arguments to ‘title()’ get “smart” defaults here, e.g., the default ‘ylab’ is ‘“Frequency”’ iff ‘freq’ is true.\nxlim, ylim: the range of x and y values with sensible defaults. Note that ‘xlim’ is not used to define the histogram (breaks), but only for plotting (when ‘plot = TRUE’).\naxes: logical.  If 'TRUE' (default), axes are draw if the plot is\n      drawn.\n\nplot: logical.  If 'TRUE' (default), a histogram is plotted,\n      otherwise a list of breaks and counts is returned.  In the\n      latter case, a warning is used if (typically graphical)\n      arguments are specified that only apply to the 'plot = TRUE'\n      case.\nlabels: logical or character string. Additionally draw labels on top of bars, if not ‘FALSE’; see ‘plot.histogram’.\nnclass: numeric (integer). For S(-PLUS) compatibility only, ‘nclass’ is equivalent to ‘breaks’ for a scalar or character argument.\nwarn.unused: logical. If ‘plot = FALSE’ and ‘warn.unused = TRUE’, a warning will be issued when graphical parameters are passed to ‘hist.default()’.\n ...: further arguments and graphical parameters passed to\n      'plot.histogram' and thence to 'title' and 'axis' (if 'plot =\n      TRUE').\nDetails:\n The definition of _histogram_ differs by source (with\n country-specific biases).  R's default with equi-spaced breaks\n (also the default) is to plot the counts in the cells defined by\n 'breaks'.  Thus the height of a rectangle is proportional to the\n number of points falling into the cell, as is the area _provided_\n the breaks are equally-spaced.\n\n The default with non-equi-spaced breaks is to give a plot of area\n one, in which the _area_ of the rectangles is the fraction of the\n data points falling in the cells.\n\n If 'right = TRUE' (default), the histogram cells are intervals of\n the form (a, b], i.e., they include their right-hand endpoint, but\n not their left one, with the exception of the first cell when\n 'include.lowest' is 'TRUE'.\n\n For 'right = FALSE', the intervals are of the form [a, b), and\n 'include.lowest' means '_include highest_'.\n\n A numerical tolerance of 1e-7 times the median bin size (for more\n than four bins, otherwise the median is substituted) is applied\n when counting entries on the edges of bins.  This is not included\n in the reported 'breaks' nor in the calculation of 'density'.\n\n The default for 'breaks' is '\"Sturges\"': see 'nclass.Sturges'.\n Other names for which algorithms are supplied are '\"Scott\"' and\n '\"FD\"' / '\"Freedman-Diaconis\"' (with corresponding functions\n 'nclass.scott' and 'nclass.FD').  Case is ignored and partial\n matching is used.  Alternatively, a function can be supplied which\n will compute the intended number of breaks or the actual\n breakpoints as a function of 'x'.\nValue:\n an object of class '\"histogram\"' which is a list with components:\nbreaks: the n+1 cell boundaries (= ‘breaks’ if that was a vector). These are the nominal breaks, not with the boundary fuzz.\ncounts: n integers; for each cell, the number of ‘x[]’ inside.\ndensity: values f^(x[i]), as estimated density values. If ‘all(diff(breaks) == 1)’, they are the relative frequencies ‘counts/n’ and in general satisfy sum[i; f^(x[i]) (b[i+1]-b[i])] = 1, where b[i] = ‘breaks[i]’.\nmids: the n cell midpoints.\nxname: a character string with the actual ‘x’ argument name.\nequidist: logical, indicating if the distances between ‘breaks’ are all the same.\nReferences:\n Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S\n Language_.  Wadsworth & Brooks/Cole.\n\n Venables, W. N. and Ripley. B. D. (2002) _Modern Applied\n Statistics with S_.  Springer.\nSee Also:\n 'nclass.Sturges', 'stem', 'density', 'truehist' in package 'MASS'.\n\n Typical plots with vertical bars are _not_ histograms.  Consider\n 'barplot' or 'plot(*, type = \"h\")' for such bar plots.\nExamples:\n op &lt;- par(mfrow = c(2, 2))\n hist(islands)\n utils::str(hist(islands, col = \"gray\", labels = TRUE))\n \n hist(sqrt(islands), breaks = 12, col = \"lightblue\", border = \"pink\")\n ##-- For non-equidistant breaks, counts should NOT be graphed unscaled:\n r &lt;- hist(sqrt(islands), breaks = c(4*0:5, 10*3:5, 70, 100, 140),\n           col = \"blue1\")\n text(r$mids, r$density, r$counts, adj = c(.5, -.5), col = \"blue3\")\n sapply(r[2:3], sum)\n sum(r$density * diff(r$breaks)) # == 1\n lines(r, lty = 3, border = \"purple\") # -&gt; lines.histogram(*)\n par(op)\n \n require(utils) # for str\n str(hist(islands, breaks = 12, plot =  FALSE)) #-&gt; 10 (~= 12) breaks\n str(hist(islands, breaks = c(12,20,36,80,200,1000,17000), plot = FALSE))\n \n hist(islands, breaks = c(12,20,36,80,200,1000,17000), freq = TRUE,\n      main = \"WRONG histogram\") # and warning\n \n ## Extreme outliers; the \"FD\" rule would take very large number of 'breaks':\n XXL &lt;- c(1:9, c(-1,1)*1e300)\n hh &lt;- hist(XXL, \"FD\") # did not work in R &lt;= 3.4.1; now gives warning\n ## pretty() determines how many counts are used (platform dependently!):\n length(hh$breaks) ## typically 1 million -- though 1e6 was \"a suggestion only\"\n \n ## R &gt;= 4.2.0: no \"*.5\" labels on y-axis:\n hist(c(2,3,3,5,5,6,6,6,7))\n \n require(stats)\n set.seed(14)\n x &lt;- rchisq(100, df = 4)\n \n ## Histogram with custom x-axis:\n hist(x, xaxt = \"n\")\n axis(1, at = 0:17)\n \n \n ## Comparing data with a model distribution should be done with qqplot()!\n qqplot(x, qchisq(ppoints(x), df = 4)); abline(0, 1, col = 2, lty = 2)\n \n ## if you really insist on using hist() ... :\n hist(x, freq = FALSE, ylim = c(0, 0.2))\n curve(dchisq(x, df = 4), col = 2, lty = 2, lwd = 2, add = TRUE)"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#histogram-example",
    "href": "modules/Module10-DataVisualization.html#histogram-example",
    "title": "Module 10: Data Visualization",
    "section": "histogram() example",
    "text": "histogram() example\nReminder\nhist(x, breaks = \"Sturges\",\n     freq = NULL, probability = !freq,\n     include.lowest = TRUE, right = TRUE, fuzz = 1e-7,\n     density = NULL, angle = 45, col = \"lightgray\", border = NULL,\n     main = paste(\"Histogram of\" , xname),\n     xlim = range(breaks), ylim = NULL,\n     xlab = xname, ylab,\n     axes = TRUE, plot = TRUE, labels = FALSE,\n     nclass = NULL, warn.unused = TRUE, ...)\nLet’s practice\n\nhist(df$age)\n\n\n\n\n\n\n\nhist(\n    df$age, \n    freq=FALSE, \n    main=\"Histogram\", \n    xlab=\"Age (years)\"\n    )"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#plot-help-file",
    "href": "modules/Module10-DataVisualization.html#plot-help-file",
    "title": "Module 10: Data Visualization",
    "section": "plot() Help File",
    "text": "plot() Help File\n\n?plot\n\nGeneric X-Y Plotting\nDescription:\n Generic function for plotting of R objects.\n\n For simple scatter plots, 'plot.default' will be used.  However,\n there are 'plot' methods for many R objects, including\n 'function's, 'data.frame's, 'density' objects, etc.  Use\n 'methods(plot)' and the documentation for these. Most of these\n methods are implemented using traditional graphics (the 'graphics'\n package), but this is not mandatory.\n\n For more details about graphical parameter arguments used by\n traditional graphics, see 'par'.\nUsage:\n plot(x, y, ...)\n \nArguments:\n   x: the coordinates of points in the plot. Alternatively, a\n      single plotting structure, function or _any R object with a\n      'plot' method_ can be provided.\n\n   y: the y coordinates of points in the plot, _optional_ if 'x' is\n      an appropriate structure.\n\n ...: Arguments to be passed to methods, such as graphical\n      parameters (see 'par').  Many methods will accept the\n      following arguments:\n\n      'type' what type of plot should be drawn.  Possible types are\n\n            • '\"p\"' for *p*oints,\n\n            • '\"l\"' for *l*ines,\n\n            • '\"b\"' for *b*oth,\n\n            • '\"c\"' for the lines part alone of '\"b\"',\n\n            • '\"o\"' for both '*o*verplotted',\n\n            • '\"h\"' for '*h*istogram' like (or 'high-density')\n              vertical lines,\n\n            • '\"s\"' for stair *s*teps,\n\n            • '\"S\"' for other *s*teps, see 'Details' below,\n\n            • '\"n\"' for no plotting.\n\n          All other 'type's give a warning or an error; using,\n          e.g., 'type = \"punkte\"' being equivalent to 'type = \"p\"'\n          for S compatibility.  Note that some methods, e.g.\n          'plot.factor', do not accept this.\n\n      'main' an overall title for the plot: see 'title'.\n\n      'sub' a subtitle for the plot: see 'title'.\n\n      'xlab' a title for the x axis: see 'title'.\n\n      'ylab' a title for the y axis: see 'title'.\n\n      'asp' the y/x aspect ratio, see 'plot.window'.\nDetails:\n The two step types differ in their x-y preference: Going from\n (x1,y1) to (x2,y2) with x1 &lt; x2, 'type = \"s\"' moves first\n horizontal, then vertical, whereas 'type = \"S\"' moves the other\n way around.\nNote:\n The 'plot' generic was moved from the 'graphics' package to the\n 'base' package in R 4.0.0. It is currently re-exported from the\n 'graphics' namespace to allow packages importing it from there to\n continue working, but this may change in future versions of R.\nSee Also:\n 'plot.default', 'plot.formula' and other methods; 'points',\n 'lines', 'par'.  For thousands of points, consider using\n 'smoothScatter()' instead of 'plot()'.\n\n For X-Y-Z plotting see 'contour', 'persp' and 'image'.\nExamples:\n require(stats) # for lowess, rpois, rnorm\n require(graphics) # for plot methods\n plot(cars)\n lines(lowess(cars))\n \n plot(sin, -pi, 2*pi) # see ?plot.function\n \n ## Discrete Distribution Plot:\n plot(table(rpois(100, 5)), type = \"h\", col = \"red\", lwd = 10,\n      main = \"rpois(100, lambda = 5)\")\n \n ## Simple quantiles/ECDF, see ecdf() {library(stats)} for a better one:\n plot(x &lt;- sort(rnorm(47)), type = \"s\", main = \"plot(x, type = \\\"s\\\")\")\n points(x, cex = .5, col = \"dark red\")"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#plot-help-file-2-par",
    "href": "modules/Module10-DataVisualization.html#plot-help-file-2-par",
    "title": "Module 10: Data Visualization",
    "section": "plot() Help File 2 – par",
    "text": "plot() Help File 2 – par\npar can be used to set or query graphical parameters - basically the plot options\n\n?par\n\nSet or Query Graphical Parameters\nDescription:\n 'par' can be used to set or query graphical parameters.\n Parameters can be set by specifying them as arguments to 'par' in\n 'tag = value' form, or by passing them as a list of tagged values.\nUsage:\n par(..., no.readonly = FALSE)\n \n &lt;highlevel plot&gt; (...., &lt;tag&gt; = &lt;value&gt;)\n \nArguments:\n ...: arguments in 'tag = value' form, a single list of tagged\n      values, or character vectors of parameter names. Supported\n      parameters are described in the 'Graphical Parameters'\n      section.\nno.readonly: logical; if ‘TRUE’ and there are no other arguments, only parameters are returned which can be set by a subsequent ‘par()’ call on the same device.\nDetails:\n Each device has its own set of graphical parameters.  If the\n current device is the null device, 'par' will open a new device\n before querying/setting parameters.  (What device is controlled by\n 'options(\"device\")'.)\n\n Parameters are queried by giving one or more character vectors of\n parameter names to 'par'.\n\n 'par()' (no arguments) or 'par(no.readonly = TRUE)' is used to get\n _all_ the graphical parameters (as a named list).  Their names are\n currently taken from the unexported variable 'graphics:::.Pars'.\n\n _*R.O.*_ indicates _*read-only arguments*_: These may only be used\n in queries and cannot be set.  ('\"cin\"', '\"cra\"', '\"csi\"',\n '\"cxy\"', '\"din\"' and '\"page\"' are always read-only.)\n\n Several parameters can only be set by a call to 'par()':\n\n    • '\"ask\"',\n\n    • '\"fig\"', '\"fin\"',\n\n    • '\"lheight\"',\n\n    • '\"mai\"', '\"mar\"', '\"mex\"', '\"mfcol\"', '\"mfrow\"', '\"mfg\"',\n\n    • '\"new\"',\n\n    • '\"oma\"', '\"omd\"', '\"omi\"',\n\n    • '\"pin\"', '\"plt\"', '\"ps\"', '\"pty\"',\n\n    • '\"usr\"',\n\n    • '\"xlog\"', '\"ylog\"',\n\n    • '\"ylbias\"'\n\n The remaining parameters can also be set as arguments (often via\n '...') to high-level plot functions such as 'plot.default',\n 'plot.window', 'points', 'lines', 'abline', 'axis', 'title',\n 'text', 'mtext', 'segments', 'symbols', 'arrows', 'polygon',\n 'rect', 'box', 'contour', 'filled.contour' and 'image'.  Such\n settings will be active during the execution of the function,\n only.  However, see the comments on 'bg', 'cex', 'col', 'lty',\n 'lwd' and 'pch' which may be taken as _arguments_ to certain plot\n functions rather than as graphical parameters.\n\n The meaning of 'character size' is not well-defined: this is set\n up for the device taking 'pointsize' into account but often not\n the actual font family in use.  Internally the corresponding pars\n ('cra', 'cin', 'cxy' and 'csi') are used only to set the\n inter-line spacing used to convert 'mar' and 'oma' to physical\n margins.  (The same inter-line spacing multiplied by 'lheight' is\n used for multi-line strings in 'text' and 'strheight'.)\n\n Note that graphical parameters are suggestions: plotting functions\n and devices need not make use of them (and this is particularly\n true of non-default methods for e.g. 'plot').\nValue:\n When parameters are set, their previous values are returned in an\n invisible named list.  Such a list can be passed as an argument to\n 'par' to restore the parameter values.  Use 'par(no.readonly =\n TRUE)' for the full list of parameters that can be restored.\n However, restoring all of these is not wise: see the 'Note'\n section.\n\n When just one parameter is queried, the value of that parameter is\n returned as (atomic) vector.  When two or more parameters are\n queried, their values are returned in a list, with the list names\n giving the parameters.\n\n Note the inconsistency: setting one parameter returns a list, but\n querying one parameter returns a vector.\nGraphical Parameters:\n 'adj' The value of 'adj' determines the way in which text strings\n      are justified in 'text', 'mtext' and 'title'.  A value of '0'\n      produces left-justified text, '0.5' (the default) centered\n      text and '1' right-justified text.  (Any value in [0, 1] is\n      allowed, and on most devices values outside that interval\n      will also work.)\n\n      Note that the 'adj' _argument_ of 'text' also allows 'adj =\n      c(x, y)' for different adjustment in x- and y- directions.\n      Note that whereas for 'text' it refers to positioning of text\n      about a point, for 'mtext' and 'title' it controls placement\n      within the plot or device region.\n\n 'ann' If set to 'FALSE', high-level plotting functions calling\n      'plot.default' do not annotate the plots they produce with\n      axis titles and overall titles.  The default is to do\n      annotation.\n\n 'ask' logical.  If 'TRUE' (and the R session is interactive) the\n      user is asked for input, before a new figure is drawn.  As\n      this applies to the device, it also affects output by\n      packages 'grid' and 'lattice'.  It can be set even on\n      non-screen devices but may have no effect there.\n\n      This not really a graphics parameter, and its use is\n      deprecated in favour of 'devAskNewPage'.\n\n 'bg' The color to be used for the background of the device region.\n      When called from 'par()' it also sets 'new = FALSE'. See\n      section 'Color Specification' for suitable values.  For many\n      devices the initial value is set from the 'bg' argument of\n      the device, and for the rest it is normally '\"white\"'.\n\n      Note that some graphics functions such as 'plot.default' and\n      'points' have an _argument_ of this name with a different\n      meaning.\n\n 'bty' A character string which determined the type of 'box' which\n      is drawn about plots.  If 'bty' is one of '\"o\"' (the\n      default), '\"l\"', '\"7\"', '\"c\"', '\"u\"', or '\"]\"' the resulting\n      box resembles the corresponding upper case letter.  A value\n      of '\"n\"' suppresses the box.\n\n 'cex' A numerical value giving the amount by which plotting text\n      and symbols should be magnified relative to the default.\n      This starts as '1' when a device is opened, and is reset when\n      the layout is changed, e.g. by setting 'mfrow'.\n\n      Note that some graphics functions such as 'plot.default' have\n      an _argument_ of this name which _multiplies_ this graphical\n      parameter, and some functions such as 'points' and 'text'\n      accept a vector of values which are recycled.\n\n 'cex.axis' The magnification to be used for axis annotation\n      relative to the current setting of 'cex'.\n\n 'cex.lab' The magnification to be used for x and y labels relative\n      to the current setting of 'cex'.\n\n 'cex.main' The magnification to be used for main titles relative\n      to the current setting of 'cex'.\n\n 'cex.sub' The magnification to be used for sub-titles relative to\n      the current setting of 'cex'.\n\n 'cin' _*R.O.*_; character size '(width, height)' in inches.  These\n      are the same measurements as 'cra', expressed in different\n      units.\n\n 'col' A specification for the default plotting color.  See section\n      'Color Specification'.\n\n      Some functions such as 'lines' and 'text' accept a vector of\n      values which are recycled and may be interpreted slightly\n      differently.\n\n 'col.axis' The color to be used for axis annotation.  Defaults to\n      '\"black\"'.\n\n 'col.lab' The color to be used for x and y labels.  Defaults to\n      '\"black\"'.\n\n 'col.main' The color to be used for plot main titles.  Defaults to\n      '\"black\"'.\n\n 'col.sub' The color to be used for plot sub-titles.  Defaults to\n      '\"black\"'.\n\n 'cra' _*R.O.*_; size of default character '(width, height)' in\n      'rasters' (pixels).  Some devices have no concept of pixels\n      and so assume an arbitrary pixel size, usually 1/72 inch.\n      These are the same measurements as 'cin', expressed in\n      different units.\n\n 'crt' A numerical value specifying (in degrees) how single\n      characters should be rotated.  It is unwise to expect values\n      other than multiples of 90 to work.  Compare with 'srt' which\n      does string rotation.\n\n 'csi' _*R.O.*_; height of (default-sized) characters in inches.\n      The same as 'par(\"cin\")[2]'.\n\n 'cxy' _*R.O.*_; size of default character '(width, height)' in\n      user coordinate units.  'par(\"cxy\")' is\n      'par(\"cin\")/par(\"pin\")' scaled to user coordinates.  Note\n      that 'c(strwidth(ch), strheight(ch))' for a given string 'ch'\n      is usually much more precise.\n\n 'din' _*R.O.*_; the device dimensions, '(width, height)', in\n      inches.  See also 'dev.size', which is updated immediately\n      when an on-screen device windows is re-sized.\n\n 'err' (_Unimplemented_; R is silent when points outside the plot\n      region are _not_ plotted.)  The degree of error reporting\n      desired.\n\n 'family' The name of a font family for drawing text.  The maximum\n      allowed length is 200 bytes.  This name gets mapped by each\n      graphics device to a device-specific font description.  The\n      default value is '\"\"' which means that the default device\n      fonts will be used (and what those are should be listed on\n      the help page for the device).  Standard values are\n      '\"serif\"', '\"sans\"' and '\"mono\"', and the Hershey font\n      families are also available.  (Devices may define others, and\n      some devices will ignore this setting completely.  Names\n      starting with '\"Hershey\"' are treated specially and should\n      only be used for the built-in Hershey font families.)  This\n      can be specified inline for 'text'.\n\n 'fg' The color to be used for the foreground of plots.  This is\n      the default color used for things like axes and boxes around\n      plots.  When called from 'par()' this also sets parameter\n      'col' to the same value.  See section 'Color Specification'.\n      A few devices have an argument to set the initial value,\n      which is otherwise '\"black\"'.\n\n 'fig' A numerical vector of the form 'c(x1, x2, y1, y2)' which\n      gives the (NDC) coordinates of the figure region in the\n      display region of the device. If you set this, unlike S, you\n      start a new plot, so to add to an existing plot use 'new =\n      TRUE' as well.\n\n 'fin' The figure region dimensions, '(width, height)', in inches.\n      If you set this, unlike S, you start a new plot.\n\n 'font' An integer which specifies which font to use for text.  If\n      possible, device drivers arrange so that 1 corresponds to\n      plain text (the default), 2 to bold face, 3 to italic and 4\n      to bold italic.  Also, font 5 is expected to be the symbol\n      font, in Adobe symbol encoding.  On some devices font\n      families can be selected by 'family' to choose different sets\n      of 5 fonts.\n\n 'font.axis' The font to be used for axis annotation.\n\n 'font.lab' The font to be used for x and y labels.\n\n 'font.main' The font to be used for plot main titles.\n\n 'font.sub' The font to be used for plot sub-titles.\n\n 'lab' A numerical vector of the form 'c(x, y, len)' which modifies\n      the default way that axes are annotated.  The values of 'x'\n      and 'y' give the (approximate) number of tickmarks on the x\n      and y axes and 'len' specifies the label length.  The default\n      is 'c(5, 5, 7)'.  'len' _is unimplemented_ in R.\n\n 'las' numeric in {0,1,2,3}; the style of axis labels.\n\n      0: always parallel to the axis [_default_],\n\n      1: always horizontal,\n\n      2: always perpendicular to the axis,\n\n      3: always vertical.\n\n      Also supported by 'mtext'.  Note that string/character\n      rotation _via_ argument 'srt' to 'par' does _not_ affect the\n      axis labels.\n\n 'lend' The line end style.  This can be specified as an integer or\n      string:\n\n      '0' and '\"round\"' mean rounded line caps [_default_];\n\n      '1' and '\"butt\"' mean butt line caps;\n\n      '2' and '\"square\"' mean square line caps.\n\n 'lheight' The line height multiplier.  The height of a line of\n      text (used to vertically space multi-line text) is found by\n      multiplying the character height both by the current\n      character expansion and by the line height multiplier.\n      Default value is 1.  Used in 'text' and 'strheight'.\n\n 'ljoin' The line join style.  This can be specified as an integer\n      or string:\n\n      '0' and '\"round\"' mean rounded line joins [_default_];\n\n      '1' and '\"mitre\"' mean mitred line joins;\n\n      '2' and '\"bevel\"' mean bevelled line joins.\n\n 'lmitre' The line mitre limit.  This controls when mitred line\n      joins are automatically converted into bevelled line joins.\n      The value must be larger than 1 and the default is 10.  Not\n      all devices will honour this setting.\n\n 'lty' The line type.  Line types can either be specified as an\n      integer (0=blank, 1=solid (default), 2=dashed, 3=dotted,\n      4=dotdash, 5=longdash, 6=twodash) or as one of the character\n      strings '\"blank\"', '\"solid\"', '\"dashed\"', '\"dotted\"',\n      '\"dotdash\"', '\"longdash\"', or '\"twodash\"', where '\"blank\"'\n      uses 'invisible lines' (i.e., does not draw them).\n\n      Alternatively, a string of up to 8 characters (from 'c(1:9,\n      \"A\":\"F\")') may be given, giving the length of line segments\n      which are alternatively drawn and skipped.  See section 'Line\n      Type Specification'.\n\n      Functions such as 'lines' and 'segments' accept a vector of\n      values which are recycled.\n\n 'lwd' The line width, a _positive_ number, defaulting to '1'.  The\n      interpretation is device-specific, and some devices do not\n      implement line widths less than one.  (See the help on the\n      device for details of the interpretation.)\n\n      Functions such as 'lines' and 'segments' accept a vector of\n      values which are recycled: in such uses lines corresponding\n      to values 'NA' or 'NaN' are omitted.  The interpretation of\n      '0' is device-specific.\n\n 'mai' A numerical vector of the form 'c(bottom, left, top, right)'\n      which gives the margin size specified in inches.\n\n 'mar' A numerical vector of the form 'c(bottom, left, top, right)'\n      which gives the number of lines of margin to be specified on\n      the four sides of the plot.  The default is 'c(5, 4, 4, 2) +\n      0.1'.\n\n 'mex' 'mex' is a character size expansion factor which is used to\n      describe coordinates in the margins of plots. Note that this\n      does not change the font size, rather specifies the size of\n      font (as a multiple of 'csi') used to convert between 'mar'\n      and 'mai', and between 'oma' and 'omi'.\n\n      This starts as '1' when the device is opened, and is reset\n      when the layout is changed (alongside resetting 'cex').\n\n 'mfcol, mfrow' A vector of the form 'c(nr, nc)'.  Subsequent\n      figures will be drawn in an 'nr'-by-'nc' array on the device\n      by _columns_ ('mfcol'), or _rows_ ('mfrow'), respectively.\n\n      In a layout with exactly two rows and columns the base value\n      of '\"cex\"' is reduced by a factor of 0.83: if there are three\n      or more of either rows or columns, the reduction factor is\n      0.66.\n\n      Setting a layout resets the base value of 'cex' and that of\n      'mex' to '1'.\n\n      If either of these is queried it will give the current\n      layout, so querying cannot tell you the order in which the\n      array will be filled.\n\n      Consider the alternatives, 'layout' and 'split.screen'.\n\n 'mfg' A numerical vector of the form 'c(i, j)' where 'i' and 'j'\n      indicate which figure in an array of figures is to be drawn\n      next (if setting) or is being drawn (if enquiring).  The\n      array must already have been set by 'mfcol' or 'mfrow'.\n\n      For compatibility with S, the form 'c(i, j, nr, nc)' is also\n      accepted, when 'nr' and 'nc' should be the current number of\n      rows and number of columns.  Mismatches will be ignored, with\n      a warning.\n\n 'mgp' The margin line (in 'mex' units) for the axis title, axis\n      labels and axis line.  Note that 'mgp[1]' affects 'title'\n      whereas 'mgp[2:3]' affect 'axis'.  The default is 'c(3, 1,\n      0)'.\n\n 'mkh' The height in inches of symbols to be drawn when the value\n      of 'pch' is an integer. _Completely ignored in R_.\n\n 'new' logical, defaulting to 'FALSE'.  If set to 'TRUE', the next\n      high-level plotting command (actually 'plot.new') should _not\n      clean_ the frame before drawing _as if it were on a *_new_*\n      device_.  It is an error (ignored with a warning) to try to\n      use 'new = TRUE' on a device that does not currently contain\n      a high-level plot.\n\n 'oma' A vector of the form 'c(bottom, left, top, right)' giving\n      the size of the outer margins in lines of text.\n\n 'omd' A vector of the form 'c(x1, x2, y1, y2)' giving the region\n      _inside_ outer margins in NDC (= normalized device\n      coordinates), i.e., as a fraction (in [0, 1]) of the device\n      region.\n\n 'omi' A vector of the form 'c(bottom, left, top, right)' giving\n      the size of the outer margins in inches.\n\n 'page' _*R.O.*_; A boolean value indicating whether the next call\n      to 'plot.new' is going to start a new page.  This value may\n      be 'FALSE' if there are multiple figures on the page.\n\n 'pch' Either an integer specifying a symbol or a single character\n      to be used as the default in plotting points.  See 'points'\n      for possible values and their interpretation.  Note that only\n      integers and single-character strings can be set as a\n      graphics parameter (and not 'NA' nor 'NULL').\n\n      Some functions such as 'points' accept a vector of values\n      which are recycled.\n\n 'pin' The current plot dimensions, '(width, height)', in inches.\n\n 'plt' A vector of the form 'c(x1, x2, y1, y2)' giving the\n      coordinates of the plot region as fractions of the current\n      figure region.\n\n 'ps' integer; the point size of text (but not symbols).  Unlike\n      the 'pointsize' argument of most devices, this does not\n      change the relationship between 'mar' and 'mai' (nor 'oma'\n      and 'omi').\n\n      What is meant by 'point size' is device-specific, but most\n      devices mean a multiple of 1bp, that is 1/72 of an inch.\n\n 'pty' A character specifying the type of plot region to be used;\n      '\"s\"' generates a square plotting region and '\"m\"' generates\n      the maximal plotting region.\n\n 'smo' (_Unimplemented_) a value which indicates how smooth circles\n      and circular arcs should be.\n\n 'srt' The string rotation in degrees.  See the comment about\n      'crt'.  Only supported by 'text'.\n\n 'tck' The length of tick marks as a fraction of the smaller of the\n      width or height of the plotting region.  If 'tck &gt;= 0.5' it\n      is interpreted as a fraction of the relevant side, so if 'tck\n      = 1' grid lines are drawn.  The default setting ('tck = NA')\n      is to use 'tcl = -0.5'.\n\n 'tcl' The length of tick marks as a fraction of the height of a\n      line of text.  The default value is '-0.5'; setting 'tcl =\n      NA' sets 'tck = -0.01' which is S' default.\n\n 'usr' A vector of the form 'c(x1, x2, y1, y2)' giving the extremes\n      of the user coordinates of the plotting region.  When a\n      logarithmic scale is in use (i.e., 'par(\"xlog\")' is true, see\n      below), then the x-limits will be '10 ^ par(\"usr\")[1:2]'.\n      Similarly for the y-axis.\n\n 'xaxp' A vector of the form 'c(x1, x2, n)' giving the coordinates\n      of the extreme tick marks and the number of intervals between\n      tick-marks when 'par(\"xlog\")' is false.  Otherwise, when\n      _log_ coordinates are active, the three values have a\n      different meaning: For a small range, 'n' is _negative_, and\n      the ticks are as in the linear case, otherwise, 'n' is in\n      '1:3', specifying a case number, and 'x1' and 'x2' are the\n      lowest and highest power of 10 inside the user coordinates,\n      '10 ^ par(\"usr\")[1:2]'. (The '\"usr\"' coordinates are\n      log10-transformed here!)\n\n      n = 1 will produce tick marks at 10^j for integer j,\n\n      n = 2 gives marks k 10^j with k in {1,5},\n\n      n = 3 gives marks k 10^j with k in {1,2,5}.\n\n      See 'axTicks()' for a pure R implementation of this.\n\n      This parameter is reset when a user coordinate system is set\n      up, for example by starting a new page or by calling\n      'plot.window' or setting 'par(\"usr\")': 'n' is taken from\n      'par(\"lab\")'.  It affects the default behaviour of subsequent\n      calls to 'axis' for sides 1 or 3.\n\n      It is only relevant to default numeric axis systems, and not\n      for example to dates.\n\n 'xaxs' The style of axis interval calculation to be used for the\n      x-axis.  Possible values are '\"r\"', '\"i\"', '\"e\"', '\"s\"',\n      '\"d\"'.  The styles are generally controlled by the range of\n      data or 'xlim', if given.\n      Style '\"r\"' (regular) first extends the data range by 4\n      percent at each end and then finds an axis with pretty labels\n      that fits within the extended range.\n      Style '\"i\"' (internal) just finds an axis with pretty labels\n      that fits within the original data range.\n      Style '\"s\"' (standard) finds an axis with pretty labels\n      within which the original data range fits.\n      Style '\"e\"' (extended) is like style '\"s\"', except that it is\n      also ensures that there is room for plotting symbols within\n      the bounding box.\n      Style '\"d\"' (direct) specifies that the current axis should\n      be used on subsequent plots.\n      (_Only '\"r\"' and '\"i\"' styles have been implemented in R._)\n\n 'xaxt' A character which specifies the x axis type.  Specifying\n      '\"n\"' suppresses plotting of the axis.  The standard value is\n      '\"s\"': for compatibility with S values '\"l\"' and '\"t\"' are\n      accepted but are equivalent to '\"s\"': any value other than\n      '\"n\"' implies plotting.\n\n 'xlog' A logical value (see 'log' in 'plot.default').  If 'TRUE',\n      a logarithmic scale is in use (e.g., after 'plot(*, log =\n      \"x\")').  For a new device, it defaults to 'FALSE', i.e.,\n      linear scale.\n\n 'xpd' A logical value or 'NA'.  If 'FALSE', all plotting is\n      clipped to the plot region, if 'TRUE', all plotting is\n      clipped to the figure region, and if 'NA', all plotting is\n      clipped to the device region.  See also 'clip'.\n\n 'yaxp' A vector of the form 'c(y1, y2, n)' giving the coordinates\n      of the extreme tick marks and the number of intervals between\n      tick-marks unless for log coordinates, see 'xaxp' above.\n\n 'yaxs' The style of axis interval calculation to be used for the\n      y-axis.  See 'xaxs' above.\n\n 'yaxt' A character which specifies the y axis type.  Specifying\n      '\"n\"' suppresses plotting.\n\n 'ylbias' A positive real value used in the positioning of text in\n      the margins by 'axis' and 'mtext'.  The default is in\n      principle device-specific, but currently '0.2' for all of R's\n      own devices.  Set this to '0.2' for compatibility with R &lt;\n      2.14.0 on 'x11' and 'windows()' devices.\n\n 'ylog' A logical value; see 'xlog' above.\nColor Specification:\n Colors can be specified in several different ways. The simplest\n way is with a character string giving the color name (e.g.,\n '\"red\"').  A list of the possible colors can be obtained with the\n function 'colors'.  Alternatively, colors can be specified\n directly in terms of their RGB components with a string of the\n form '\"#RRGGBB\"' where each of the pairs 'RR', 'GG', 'BB' consist\n of two hexadecimal digits giving a value in the range '00' to\n 'FF'.  Colors can also be specified by giving an index into a\n small table of colors, the 'palette': indices wrap round so with\n the default palette of size 8, '10' is the same as '2'.  This\n provides compatibility with S.  Index '0' corresponds to the\n background color.  Note that the palette (apart from '0' which is\n per-device) is a per-session setting.\n\n Negative integer colours are errors.\n\n Additionally, '\"transparent\"' is _transparent_, useful for filled\n areas (such as the background!), and just invisible for things\n like lines or text.  In most circumstances (integer) 'NA' is\n equivalent to '\"transparent\"' (but not for 'text' and 'mtext').\n\n Semi-transparent colors are available for use on devices that\n support them.\n\n The functions 'rgb', 'hsv', 'hcl', 'gray' and 'rainbow' provide\n additional ways of generating colors.\nLine Type Specification:\n Line types can either be specified by giving an index into a small\n built-in table of line types (1 = solid, 2 = dashed, etc, see\n 'lty' above) or directly as the lengths of on/off stretches of\n line.  This is done with a string of an even number (up to eight)\n of characters, namely _non-zero_ (hexadecimal) digits which give\n the lengths in consecutive positions in the string.  For example,\n the string '\"33\"' specifies three units on followed by three off\n and '\"3313\"' specifies three units on followed by three off\n followed by one on and finally three off.  The 'units' here are\n (on most devices) proportional to 'lwd', and with 'lwd = 1' are in\n pixels or points or 1/96 inch.\n\n The five standard dash-dot line types ('lty = 2:6') correspond to\n 'c(\"44\", \"13\", \"1343\", \"73\", \"2262\")'.\n\n Note that 'NA' is not a valid value for 'lty'.\nNote:\n The effect of restoring all the (settable) graphics parameters as\n in the examples is hard to predict if the device has been resized.\n Several of them are attempting to set the same things in different\n ways, and those last in the alphabet will win.  In particular, the\n settings of 'mai', 'mar', 'pin', 'plt' and 'pty' interact, as do\n the outer margin settings, the figure layout and figure region\n size.\nReferences:\n Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S\n Language_.  Wadsworth & Brooks/Cole.\n\n Murrell, P. (2005) _R Graphics_. Chapman & Hall/CRC Press.\nSee Also:\n 'plot.default' for some high-level plotting parameters; 'colors';\n 'clip'; 'options' for other setup parameters; graphic devices\n 'x11', 'postscript' and setting up device regions by 'layout' and\n 'split.screen'.\nExamples:\n op &lt;- par(mfrow = c(2, 2), # 2 x 2 pictures on one plot\n           pty = \"s\")       # square plotting region,\n                            # independent of device size\n \n ## At end of plotting, reset to previous settings:\n par(op)\n \n ## Alternatively,\n op &lt;- par(no.readonly = TRUE) # the whole list of settable par's.\n ## do lots of plotting and par(.) calls, then reset:\n par(op)\n ## Note this is not in general good practice\n \n par(\"ylog\") # FALSE\n plot(1 : 12, log = \"y\")\n par(\"ylog\") # TRUE\n \n plot(1:2, xaxs = \"i\") # 'inner axis' w/o extra space\n par(c(\"usr\", \"xaxp\"))\n \n ( nr.prof &lt;-\n c(prof.pilots = 16, lawyers = 11, farmers = 10, salesmen = 9, physicians = 9,\n   mechanics = 6, policemen = 6, managers = 6, engineers = 5, teachers = 4,\n   housewives = 3, students = 3, armed.forces = 1))\n par(las = 3)\n barplot(rbind(nr.prof)) # R 0.63.2: shows alignment problem\n par(las = 0)  # reset to default\n \n require(grDevices) # for gray\n ## 'fg' use:\n plot(1:12, type = \"b\", main = \"'fg' : axes, ticks and box in gray\",\n      fg = gray(0.7), bty = \"7\" , sub = R.version.string)\n \n ex &lt;- function() {\n    old.par &lt;- par(no.readonly = TRUE) # all par settings which\n                                       # could be changed.\n    on.exit(par(old.par))\n    ## ...\n    ## ... do lots of par() settings and plots\n    ## ...\n    invisible() #-- now,  par(old.par)  will be executed\n }\n ex()\n \n ## Line types\n showLty &lt;- function(ltys, xoff = 0, ...) {\n    stopifnot((n &lt;- length(ltys)) &gt;= 1)\n    op &lt;- par(mar = rep(.5,4)); on.exit(par(op))\n    plot(0:1, 0:1, type = \"n\", axes = FALSE, ann = FALSE)\n    y &lt;- (n:1)/(n+1)\n    clty &lt;- as.character(ltys)\n    mytext &lt;- function(x, y, txt)\n       text(x, y, txt, adj = c(0, -.3), cex = 0.8, ...)\n    abline(h = y, lty = ltys, ...); mytext(xoff, y, clty)\n    y &lt;- y - 1/(3*(n+1))\n    abline(h = y, lty = ltys, lwd = 2, ...)\n    mytext(1/8+xoff, y, paste(clty,\" lwd = 2\"))\n }\n showLty(c(\"solid\", \"dashed\", \"dotted\", \"dotdash\", \"longdash\", \"twodash\"))\n par(new = TRUE)  # the same:\n showLty(c(\"solid\", \"44\", \"13\", \"1343\", \"73\", \"2262\"), xoff = .2, col = 2)\n showLty(c(\"11\", \"22\", \"33\", \"44\",   \"12\", \"13\", \"14\",   \"21\", \"31\"))"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#plot-example",
    "href": "modules/Module10-DataVisualization.html#plot-example",
    "title": "Module 10: Data Visualization",
    "section": "plot() example",
    "text": "plot() example\n\nplot(df$age, df$IgG_concentration)\n\n\n\n\n\n\n\nplot(\n    df$age, \n    df$IgG_concentration, \n    type=\"p\", \n    main=\"Age by IgG Concentrations\", \n    xlab=\"Age (years)\", \n    ylab=\"IgG Concentration (mIU/mL)\", \n    pch=16, \n    cex=0.9,\n    col=\"lightblue\")"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#boxplot-help-file",
    "href": "modules/Module10-DataVisualization.html#boxplot-help-file",
    "title": "Module 10: Data Visualization",
    "section": "boxplot() Help File",
    "text": "boxplot() Help File\n\n?boxplot\n\nBox Plots\nDescription:\n Produce box-and-whisker plot(s) of the given (grouped) values.\nUsage:\n boxplot(x, ...)\n \n ## S3 method for class 'formula'\n boxplot(formula, data = NULL, ..., subset, na.action = NULL,\n         xlab = mklab(y_var = horizontal),\n         ylab = mklab(y_var =!horizontal),\n         add = FALSE, ann = !add, horizontal = FALSE,\n         drop = FALSE, sep = \".\", lex.order = FALSE)\n \n ## Default S3 method:\n boxplot(x, ..., range = 1.5, width = NULL, varwidth = FALSE,\n         notch = FALSE, outline = TRUE, names, plot = TRUE,\n         border = par(\"fg\"), col = \"lightgray\", log = \"\",\n         pars = list(boxwex = 0.8, staplewex = 0.5, outwex = 0.5),\n          ann = !add, horizontal = FALSE, add = FALSE, at = NULL)\n \nArguments:\nformula: a formula, such as ‘y ~ grp’, where ‘y’ is a numeric vector of data values to be split into groups according to the grouping variable ‘grp’ (usually a factor). Note that ‘~ g1 + g2’ is equivalent to ‘g1:g2’.\ndata: a data.frame (or list) from which the variables in 'formula'\n      should be taken.\nsubset: an optional vector specifying a subset of observations to be used for plotting.\nna.action: a function which indicates what should happen when the data contain ’NA’s. The default is to ignore missing values in either the response or the group.\nxlab, ylab: x- and y-axis annotation, since R 3.6.0 with a non-empty default. Can be suppressed by ‘ann=FALSE’.\n ann: 'logical' indicating if axes should be annotated (by 'xlab'\n      and 'ylab').\ndrop, sep, lex.order: passed to ‘split.default’, see there.\n   x: for specifying data from which the boxplots are to be\n      produced. Either a numeric vector, or a single list\n      containing such vectors. Additional unnamed arguments specify\n      further data as separate vectors (each corresponding to a\n      component boxplot).  'NA's are allowed in the data.\n\n ...: For the 'formula' method, named arguments to be passed to the\n      default method.\n\n      For the default method, unnamed arguments are additional data\n      vectors (unless 'x' is a list when they are ignored), and\n      named arguments are arguments and graphical parameters to be\n      passed to 'bxp' in addition to the ones given by argument\n      'pars' (and override those in 'pars'). Note that 'bxp' may or\n      may not make use of graphical parameters it is passed: see\n      its documentation.\nrange: this determines how far the plot whiskers extend out from the box. If ‘range’ is positive, the whiskers extend to the most extreme data point which is no more than ‘range’ times the interquartile range from the box. A value of zero causes the whiskers to extend to the data extremes.\nwidth: a vector giving the relative widths of the boxes making up the plot.\nvarwidth: if ‘varwidth’ is ‘TRUE’, the boxes are drawn with widths proportional to the square-roots of the number of observations in the groups.\nnotch: if ‘notch’ is ‘TRUE’, a notch is drawn in each side of the boxes. If the notches of two plots do not overlap this is ‘strong evidence’ that the two medians differ (Chambers et al, 1983, p. 62). See ‘boxplot.stats’ for the calculations used.\noutline: if ‘outline’ is not true, the outliers are not drawn (as points whereas S+ uses lines).\nnames: group labels which will be printed under each boxplot. Can be a character vector or an expression (see plotmath).\nboxwex: a scale factor to be applied to all boxes. When there are only a few groups, the appearance of the plot can be improved by making the boxes narrower.\nstaplewex: staple line width expansion, proportional to box width.\noutwex: outlier line width expansion, proportional to box width.\nplot: if 'TRUE' (the default) then a boxplot is produced.  If not,\n      the summaries which the boxplots are based on are returned.\nborder: an optional vector of colors for the outlines of the boxplots. The values in ‘border’ are recycled if the length of ‘border’ is less than the number of plots.\n col: if 'col' is non-null it is assumed to contain colors to be\n      used to colour the bodies of the box plots. By default they\n      are in the background colour.\n\n log: character indicating if x or y or both coordinates should be\n      plotted in log scale.\n\npars: a list of (potentially many) more graphical parameters, e.g.,\n      'boxwex' or 'outpch'; these are passed to 'bxp' (if 'plot' is\n      true); for details, see there.\nhorizontal: logical indicating if the boxplots should be horizontal; default ‘FALSE’ means vertical boxes.\n add: logical, if true _add_ boxplot to current plot.\n\n  at: numeric vector giving the locations where the boxplots should\n      be drawn, particularly when 'add = TRUE'; defaults to '1:n'\n      where 'n' is the number of boxes.\nDetails:\n The generic function 'boxplot' currently has a default method\n ('boxplot.default') and a formula interface ('boxplot.formula').\n\n If multiple groups are supplied either as multiple arguments or\n via a formula, parallel boxplots will be plotted, in the order of\n the arguments or the order of the levels of the factor (see\n 'factor').\n\n Missing values are ignored when forming boxplots.\nValue:\n List with the following components:\nstats: a matrix, each column contains the extreme of the lower whisker, the lower hinge, the median, the upper hinge and the extreme of the upper whisker for one group/plot. If all the inputs have the same class attribute, so will this component.\n   n: a vector with the number of (non-'NA') observations in each\n      group.\n\nconf: a matrix where each column contains the lower and upper\n      extremes of the notch.\n\n out: the values of any data points which lie beyond the extremes\n      of the whiskers.\ngroup: a vector of the same length as ‘out’ whose elements indicate to which group the outlier belongs.\nnames: a vector of names for the groups.\nReferences:\n Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988).  _The New\n S Language_.  Wadsworth & Brooks/Cole.\n\n Chambers, J. M., Cleveland, W. S., Kleiner, B. and Tukey, P. A.\n (1983).  _Graphical Methods for Data Analysis_.  Wadsworth &\n Brooks/Cole.\n\n Murrell, P. (2005).  _R Graphics_.  Chapman & Hall/CRC Press.\n\n See also 'boxplot.stats'.\nSee Also:\n 'boxplot.stats' which does the computation, 'bxp' for the plotting\n and more examples; and 'stripchart' for an alternative (with small\n data sets).\nExamples:\n ## boxplot on a formula:\n boxplot(count ~ spray, data = InsectSprays, col = \"lightgray\")\n # *add* notches (somewhat funny here &lt;--&gt; warning \"notches .. outside hinges\"):\n boxplot(count ~ spray, data = InsectSprays,\n         notch = TRUE, add = TRUE, col = \"blue\")\n \n boxplot(decrease ~ treatment, data = OrchardSprays, col = \"bisque\",\n         log = \"y\")\n ## horizontal=TRUE, switching  y &lt;--&gt; x :\n boxplot(decrease ~ treatment, data = OrchardSprays, col = \"bisque\",\n         log = \"x\", horizontal=TRUE)\n \n rb &lt;- boxplot(decrease ~ treatment, data = OrchardSprays, col = \"bisque\")\n title(\"Comparing boxplot()s and non-robust mean +/- SD\")\n mn.t &lt;- tapply(OrchardSprays$decrease, OrchardSprays$treatment, mean)\n sd.t &lt;- tapply(OrchardSprays$decrease, OrchardSprays$treatment, sd)\n xi &lt;- 0.3 + seq(rb$n)\n points(xi, mn.t, col = \"orange\", pch = 18)\n arrows(xi, mn.t - sd.t, xi, mn.t + sd.t,\n        code = 3, col = \"pink\", angle = 75, length = .1)\n \n ## boxplot on a matrix:\n mat &lt;- cbind(Uni05 = (1:100)/21, Norm = rnorm(100),\n              `5T` = rt(100, df = 5), Gam2 = rgamma(100, shape = 2))\n boxplot(mat) # directly, calling boxplot.matrix()\n \n ## boxplot on a data frame:\n df. &lt;- as.data.frame(mat)\n par(las = 1) # all axis labels horizontal\n boxplot(df., main = \"boxplot(*, horizontal = TRUE)\", horizontal = TRUE)\n \n ## Using 'at = ' and adding boxplots -- example idea by Roger Bivand :\n boxplot(len ~ dose, data = ToothGrowth,\n         boxwex = 0.25, at = 1:3 - 0.2,\n         subset = supp == \"VC\", col = \"yellow\",\n         main = \"Guinea Pigs' Tooth Growth\",\n         xlab = \"Vitamin C dose mg\",\n         ylab = \"tooth length\",\n         xlim = c(0.5, 3.5), ylim = c(0, 35), yaxs = \"i\")\n boxplot(len ~ dose, data = ToothGrowth, add = TRUE,\n         boxwex = 0.25, at = 1:3 + 0.2,\n         subset = supp == \"OJ\", col = \"orange\")\n legend(2, 9, c(\"Ascorbic acid\", \"Orange juice\"),\n        fill = c(\"yellow\", \"orange\"))\n \n ## With less effort (slightly different) using factor *interaction*:\n boxplot(len ~ dose:supp, data = ToothGrowth,\n         boxwex = 0.5, col = c(\"orange\", \"yellow\"),\n         main = \"Guinea Pigs' Tooth Growth\",\n         xlab = \"Vitamin C dose mg\", ylab = \"tooth length\",\n         sep = \":\", lex.order = TRUE, ylim = c(0, 35), yaxs = \"i\")\n \n ## more examples in  help(bxp)"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#boxplot-example",
    "href": "modules/Module10-DataVisualization.html#boxplot-example",
    "title": "Module 10: Data Visualization",
    "section": "boxplot() example",
    "text": "boxplot() example\nReminder\nboxplot(formula, data = NULL, ..., subset, na.action = NULL,\n        xlab = mklab(y_var = horizontal),\n        ylab = mklab(y_var =!horizontal),\n        add = FALSE, ann = !add, horizontal = FALSE,\n        drop = FALSE, sep = \".\", lex.order = FALSE)\nLet’s practice\n\nboxplot(IgG_concentration~age_group, data=df)\n\n\n\n\n\n\n\nboxplot(\n    log(df$IgG_concentration)~df$age_group, \n    main=\"Age by IgG Concentrations\", \n    xlab=\"Age Group (years)\", \n    ylab=\"log IgG Concentration (mIU/mL)\", \n    names=c(\"1-5\",\"6-10\", \"11-15\"), \n    varwidth=T\n    )"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#barplot-help-file",
    "href": "modules/Module10-DataVisualization.html#barplot-help-file",
    "title": "Module 10: Data Visualization",
    "section": "barplot() Help File",
    "text": "barplot() Help File\n\n?barplot\n\nBox Plots\nDescription:\n Produce box-and-whisker plot(s) of the given (grouped) values.\nUsage:\n boxplot(x, ...)\n \n ## S3 method for class 'formula'\n boxplot(formula, data = NULL, ..., subset, na.action = NULL,\n         xlab = mklab(y_var = horizontal),\n         ylab = mklab(y_var =!horizontal),\n         add = FALSE, ann = !add, horizontal = FALSE,\n         drop = FALSE, sep = \".\", lex.order = FALSE)\n \n ## Default S3 method:\n boxplot(x, ..., range = 1.5, width = NULL, varwidth = FALSE,\n         notch = FALSE, outline = TRUE, names, plot = TRUE,\n         border = par(\"fg\"), col = \"lightgray\", log = \"\",\n         pars = list(boxwex = 0.8, staplewex = 0.5, outwex = 0.5),\n          ann = !add, horizontal = FALSE, add = FALSE, at = NULL)\n \nArguments:\nformula: a formula, such as ‘y ~ grp’, where ‘y’ is a numeric vector of data values to be split into groups according to the grouping variable ‘grp’ (usually a factor). Note that ‘~ g1 + g2’ is equivalent to ‘g1:g2’.\ndata: a data.frame (or list) from which the variables in 'formula'\n      should be taken.\nsubset: an optional vector specifying a subset of observations to be used for plotting.\nna.action: a function which indicates what should happen when the data contain ’NA’s. The default is to ignore missing values in either the response or the group.\nxlab, ylab: x- and y-axis annotation, since R 3.6.0 with a non-empty default. Can be suppressed by ‘ann=FALSE’.\n ann: 'logical' indicating if axes should be annotated (by 'xlab'\n      and 'ylab').\ndrop, sep, lex.order: passed to ‘split.default’, see there.\n   x: for specifying data from which the boxplots are to be\n      produced. Either a numeric vector, or a single list\n      containing such vectors. Additional unnamed arguments specify\n      further data as separate vectors (each corresponding to a\n      component boxplot).  'NA's are allowed in the data.\n\n ...: For the 'formula' method, named arguments to be passed to the\n      default method.\n\n      For the default method, unnamed arguments are additional data\n      vectors (unless 'x' is a list when they are ignored), and\n      named arguments are arguments and graphical parameters to be\n      passed to 'bxp' in addition to the ones given by argument\n      'pars' (and override those in 'pars'). Note that 'bxp' may or\n      may not make use of graphical parameters it is passed: see\n      its documentation.\nrange: this determines how far the plot whiskers extend out from the box. If ‘range’ is positive, the whiskers extend to the most extreme data point which is no more than ‘range’ times the interquartile range from the box. A value of zero causes the whiskers to extend to the data extremes.\nwidth: a vector giving the relative widths of the boxes making up the plot.\nvarwidth: if ‘varwidth’ is ‘TRUE’, the boxes are drawn with widths proportional to the square-roots of the number of observations in the groups.\nnotch: if ‘notch’ is ‘TRUE’, a notch is drawn in each side of the boxes. If the notches of two plots do not overlap this is ‘strong evidence’ that the two medians differ (Chambers et al, 1983, p. 62). See ‘boxplot.stats’ for the calculations used.\noutline: if ‘outline’ is not true, the outliers are not drawn (as points whereas S+ uses lines).\nnames: group labels which will be printed under each boxplot. Can be a character vector or an expression (see plotmath).\nboxwex: a scale factor to be applied to all boxes. When there are only a few groups, the appearance of the plot can be improved by making the boxes narrower.\nstaplewex: staple line width expansion, proportional to box width.\noutwex: outlier line width expansion, proportional to box width.\nplot: if 'TRUE' (the default) then a boxplot is produced.  If not,\n      the summaries which the boxplots are based on are returned.\nborder: an optional vector of colors for the outlines of the boxplots. The values in ‘border’ are recycled if the length of ‘border’ is less than the number of plots.\n col: if 'col' is non-null it is assumed to contain colors to be\n      used to colour the bodies of the box plots. By default they\n      are in the background colour.\n\n log: character indicating if x or y or both coordinates should be\n      plotted in log scale.\n\npars: a list of (potentially many) more graphical parameters, e.g.,\n      'boxwex' or 'outpch'; these are passed to 'bxp' (if 'plot' is\n      true); for details, see there.\nhorizontal: logical indicating if the boxplots should be horizontal; default ‘FALSE’ means vertical boxes.\n add: logical, if true _add_ boxplot to current plot.\n\n  at: numeric vector giving the locations where the boxplots should\n      be drawn, particularly when 'add = TRUE'; defaults to '1:n'\n      where 'n' is the number of boxes.\nDetails:\n The generic function 'boxplot' currently has a default method\n ('boxplot.default') and a formula interface ('boxplot.formula').\n\n If multiple groups are supplied either as multiple arguments or\n via a formula, parallel boxplots will be plotted, in the order of\n the arguments or the order of the levels of the factor (see\n 'factor').\n\n Missing values are ignored when forming boxplots.\nValue:\n List with the following components:\nstats: a matrix, each column contains the extreme of the lower whisker, the lower hinge, the median, the upper hinge and the extreme of the upper whisker for one group/plot. If all the inputs have the same class attribute, so will this component.\n   n: a vector with the number of (non-'NA') observations in each\n      group.\n\nconf: a matrix where each column contains the lower and upper\n      extremes of the notch.\n\n out: the values of any data points which lie beyond the extremes\n      of the whiskers.\ngroup: a vector of the same length as ‘out’ whose elements indicate to which group the outlier belongs.\nnames: a vector of names for the groups.\nReferences:\n Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988).  _The New\n S Language_.  Wadsworth & Brooks/Cole.\n\n Chambers, J. M., Cleveland, W. S., Kleiner, B. and Tukey, P. A.\n (1983).  _Graphical Methods for Data Analysis_.  Wadsworth &\n Brooks/Cole.\n\n Murrell, P. (2005).  _R Graphics_.  Chapman & Hall/CRC Press.\n\n See also 'boxplot.stats'.\nSee Also:\n 'boxplot.stats' which does the computation, 'bxp' for the plotting\n and more examples; and 'stripchart' for an alternative (with small\n data sets).\nExamples:\n ## boxplot on a formula:\n boxplot(count ~ spray, data = InsectSprays, col = \"lightgray\")\n # *add* notches (somewhat funny here &lt;--&gt; warning \"notches .. outside hinges\"):\n boxplot(count ~ spray, data = InsectSprays,\n         notch = TRUE, add = TRUE, col = \"blue\")\n \n boxplot(decrease ~ treatment, data = OrchardSprays, col = \"bisque\",\n         log = \"y\")\n ## horizontal=TRUE, switching  y &lt;--&gt; x :\n boxplot(decrease ~ treatment, data = OrchardSprays, col = \"bisque\",\n         log = \"x\", horizontal=TRUE)\n \n rb &lt;- boxplot(decrease ~ treatment, data = OrchardSprays, col = \"bisque\")\n title(\"Comparing boxplot()s and non-robust mean +/- SD\")\n mn.t &lt;- tapply(OrchardSprays$decrease, OrchardSprays$treatment, mean)\n sd.t &lt;- tapply(OrchardSprays$decrease, OrchardSprays$treatment, sd)\n xi &lt;- 0.3 + seq(rb$n)\n points(xi, mn.t, col = \"orange\", pch = 18)\n arrows(xi, mn.t - sd.t, xi, mn.t + sd.t,\n        code = 3, col = \"pink\", angle = 75, length = .1)\n \n ## boxplot on a matrix:\n mat &lt;- cbind(Uni05 = (1:100)/21, Norm = rnorm(100),\n              `5T` = rt(100, df = 5), Gam2 = rgamma(100, shape = 2))\n boxplot(mat) # directly, calling boxplot.matrix()\n \n ## boxplot on a data frame:\n df. &lt;- as.data.frame(mat)\n par(las = 1) # all axis labels horizontal\n boxplot(df., main = \"boxplot(*, horizontal = TRUE)\", horizontal = TRUE)\n \n ## Using 'at = ' and adding boxplots -- example idea by Roger Bivand :\n boxplot(len ~ dose, data = ToothGrowth,\n         boxwex = 0.25, at = 1:3 - 0.2,\n         subset = supp == \"VC\", col = \"yellow\",\n         main = \"Guinea Pigs' Tooth Growth\",\n         xlab = \"Vitamin C dose mg\",\n         ylab = \"tooth length\",\n         xlim = c(0.5, 3.5), ylim = c(0, 35), yaxs = \"i\")\n boxplot(len ~ dose, data = ToothGrowth, add = TRUE,\n         boxwex = 0.25, at = 1:3 + 0.2,\n         subset = supp == \"OJ\", col = \"orange\")\n legend(2, 9, c(\"Ascorbic acid\", \"Orange juice\"),\n        fill = c(\"yellow\", \"orange\"))\n \n ## With less effort (slightly different) using factor *interaction*:\n boxplot(len ~ dose:supp, data = ToothGrowth,\n         boxwex = 0.5, col = c(\"orange\", \"yellow\"),\n         main = \"Guinea Pigs' Tooth Growth\",\n         xlab = \"Vitamin C dose mg\", ylab = \"tooth length\",\n         sep = \":\", lex.order = TRUE, ylim = c(0, 35), yaxs = \"i\")\n \n ## more examples in  help(bxp)"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#barplot-example",
    "href": "modules/Module10-DataVisualization.html#barplot-example",
    "title": "Module 10: Data Visualization",
    "section": "barplot() example",
    "text": "barplot() example\nThe function takes the a lot of arguments to control the way the way our data is plotted.\nReminder\nbarplot(height, width = 1, space = NULL,\n        names.arg = NULL, legend.text = NULL, beside = FALSE,\n        horiz = FALSE, density = NULL, angle = 45,\n        col = NULL, border = par(\"fg\"),\n        main = NULL, sub = NULL, xlab = NULL, ylab = NULL,\n        xlim = NULL, ylim = NULL, xpd = TRUE, log = \"\",\n        axes = TRUE, axisnames = TRUE,\n        cex.axis = par(\"cex.axis\"), cex.names = par(\"cex.axis\"),\n        inside = TRUE, plot = TRUE, axis.lty = 0, offset = 0,\n        add = FALSE, ann = !add && par(\"ann\"), args.legend = NULL, ...)\n\nfreq &lt;- table(df$seropos, df$age_group)\nbarplot(freq)\n\n\n\n\n\n\n\nprop &lt;- prop.table(freq)\nbarplot(prop)"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#legend",
    "href": "modules/Module10-DataVisualization.html#legend",
    "title": "Module 10: Data Visualization",
    "section": "3. Legend!",
    "text": "3. Legend!\nIn Base R plotting the legend is not automatically generated. This is nice because it gives you a huge amount of control over how your legend looks, but it is also easy to mislabel your colors, symbols, line types, etc. So, basically be careful.\n\n?legend\n\n\n\nAdd Legends to Plots\n\nDescription:\n\n     This function can be used to add legends to plots.  Note that a\n     call to the function 'locator(1)' can be used in place of the 'x'\n     and 'y' arguments.\n\nUsage:\n\n     legend(x, y = NULL, legend, fill = NULL, col = par(\"col\"),\n            border = \"black\", lty, lwd, pch,\n            angle = 45, density = NULL, bty = \"o\", bg = par(\"bg\"),\n            box.lwd = par(\"lwd\"), box.lty = par(\"lty\"), box.col = par(\"fg\"),\n            pt.bg = NA, cex = 1, pt.cex = cex, pt.lwd = lwd,\n            xjust = 0, yjust = 1, x.intersp = 1, y.intersp = 1,\n            adj = c(0, 0.5), text.width = NULL, text.col = par(\"col\"),\n            text.font = NULL, merge = do.lines && has.pch, trace = FALSE,\n            plot = TRUE, ncol = 1, horiz = FALSE, title = NULL,\n            inset = 0, xpd, title.col = text.col[1], title.adj = 0.5,\n            title.cex = cex[1], title.font = text.font[1],\n            seg.len = 2)\n     \nArguments:\n\n    x, y: the x and y co-ordinates to be used to position the legend.\n          They can be specified by keyword or in any way which is\n          accepted by 'xy.coords': See 'Details'.\n\n  legend: a character or expression vector of length &gt;= 1 to appear in\n          the legend.  Other objects will be coerced by\n          'as.graphicsAnnot'.\n\n    fill: if specified, this argument will cause boxes filled with the\n          specified colors (or shaded in the specified colors) to\n          appear beside the legend text.\n\n     col: the color of points or lines appearing in the legend.\n\n  border: the border color for the boxes (used only if 'fill' is\n          specified).\n\nlty, lwd: the line types and widths for lines appearing in the legend.\n          One of these two _must_ be specified for line drawing.\n\n     pch: the plotting symbols appearing in the legend, as numeric\n          vector or a vector of 1-character strings (see 'points').\n          Unlike 'points', this can all be specified as a single\n          multi-character string.  _Must_ be specified for symbol\n          drawing.\n\n   angle: angle of shading lines.\n\n density: the density of shading lines, if numeric and positive. If\n          'NULL' or negative or 'NA' color filling is assumed.\n\n     bty: the type of box to be drawn around the legend.  The allowed\n          values are '\"o\"' (the default) and '\"n\"'.\n\n      bg: the background color for the legend box.  (Note that this is\n          only used if 'bty != \"n\"'.)\n\nbox.lty, box.lwd, box.col: the line type, width and color for the\n          legend box (if 'bty = \"o\"').\n\n   pt.bg: the background color for the 'points', corresponding to its\n          argument 'bg'.\n\n     cex: character expansion factor *relative* to current\n          'par(\"cex\")'.  Used for text, and provides the default for\n          'pt.cex'.\n\n  pt.cex: expansion factor(s) for the points.\n\n  pt.lwd: line width for the points, defaults to the one for lines, or\n          if that is not set, to 'par(\"lwd\")'.\n\n   xjust: how the legend is to be justified relative to the legend x\n          location.  A value of 0 means left justified, 0.5 means\n          centered and 1 means right justified.\n\n   yjust: the same as 'xjust' for the legend y location.\n\nx.intersp: character interspacing factor for horizontal (x) spacing\n          between symbol and legend text.\n\ny.intersp: vertical (y) distances (in lines of text shared above/below\n          each legend entry).  A vector with one element for each row\n          of the legend can be used.\n\n     adj: numeric of length 1 or 2; the string adjustment for legend\n          text.  Useful for y-adjustment when 'labels' are plotmath\n          expressions.\n\ntext.width: the width of the legend text in x ('\"user\"') coordinates.\n          (Should be positive even for a reversed x axis.)  Can be a\n          single positive numeric value (same width for each column of\n          the legend), a vector (one element for each column of the\n          legend), 'NULL' (default) for computing a proper maximum\n          value of 'strwidth(legend)'), or 'NA' for computing a proper\n          column wise maximum value of 'strwidth(legend)').\n\ntext.col: the color used for the legend text.\n\ntext.font: the font used for the legend text, see 'text'.\n\n   merge: logical; if 'TRUE', merge points and lines but not filled\n          boxes.  Defaults to 'TRUE' if there are points and lines.\n\n   trace: logical; if 'TRUE', shows how 'legend' does all its magical\n          computations.\n\n    plot: logical.  If 'FALSE', nothing is plotted but the sizes are\n          returned.\n\n    ncol: the number of columns in which to set the legend items\n          (default is 1, a vertical legend).\n\n   horiz: logical; if 'TRUE', set the legend horizontally rather than\n          vertically (specifying 'horiz' overrides the 'ncol'\n          specification).\n\n   title: a character string or length-one expression giving a title to\n          be placed at the top of the legend.  Other objects will be\n          coerced by 'as.graphicsAnnot'.\n\n   inset: inset distance(s) from the margins as a fraction of the plot\n          region when legend is placed by keyword.\n\n     xpd: if supplied, a value of the graphical parameter 'xpd' to be\n          used while the legend is being drawn.\n\ntitle.col: color for 'title', defaults to 'text.col[1]'.\n\ntitle.adj: horizontal adjustment for 'title': see the help for\n          'par(\"adj\")'.\n\ntitle.cex: expansion factor(s) for the title, defaults to 'cex[1]'.\n\ntitle.font: the font used for the legend title, defaults to\n          'text.font[1]', see 'text'.\n\n seg.len: the length of lines drawn to illustrate 'lty' and/or 'lwd'\n          (in units of character widths).\n\nDetails:\n\n     Arguments 'x', 'y', 'legend' are interpreted in a non-standard way\n     to allow the coordinates to be specified _via_ one or two\n     arguments.  If 'legend' is missing and 'y' is not numeric, it is\n     assumed that the second argument is intended to be 'legend' and\n     that the first argument specifies the coordinates.\n\n     The coordinates can be specified in any way which is accepted by\n     'xy.coords'.  If this gives the coordinates of one point, it is\n     used as the top-left coordinate of the rectangle containing the\n     legend.  If it gives the coordinates of two points, these specify\n     opposite corners of the rectangle (either pair of corners, in any\n     order).\n\n     The location may also be specified by setting 'x' to a single\n     keyword from the list '\"bottomright\"', '\"bottom\"', '\"bottomleft\"',\n     '\"left\"', '\"topleft\"', '\"top\"', '\"topright\"', '\"right\"' and\n     '\"center\"'. This places the legend on the inside of the plot frame\n     at the given location. Partial argument matching is used.  The\n     optional 'inset' argument specifies how far the legend is inset\n     from the plot margins.  If a single value is given, it is used for\n     both margins; if two values are given, the first is used for 'x'-\n     distance, the second for 'y'-distance.\n\n     Attribute arguments such as 'col', 'pch', 'lty', etc, are recycled\n     if necessary: 'merge' is not.  Set entries of 'lty' to '0' or set\n     entries of 'lwd' to 'NA' to suppress lines in corresponding legend\n     entries; set 'pch' values to 'NA' to suppress points.\n\n     Points are drawn _after_ lines in order that they can cover the\n     line with their background color 'pt.bg', if applicable.\n\n     See the examples for how to right-justify labels.\n\n     Since they are not used for Unicode code points, values '-31:-1'\n     are silently omitted, as are 'NA' and '\"\"' values.\n\nValue:\n\n     A list with list components\n\n    rect: a list with components\n\n          'w', 'h' positive numbers giving *w*idth and *h*eight of the\n              legend's box.\n\n          'left', 'top' x and y coordinates of upper left corner of the\n              box.\n\n    text: a list with components\n\n          'x, y' numeric vectors of length 'length(legend)', giving the\n              x and y coordinates of the legend's text(s).\n\n     returned invisibly.\n\nReferences:\n\n     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S\n     Language_.  Wadsworth & Brooks/Cole.\n\n     Murrell, P. (2005) _R Graphics_. Chapman & Hall/CRC Press.\n\nSee Also:\n\n     'plot', 'barplot' which uses 'legend()', and 'text' for more\n     examples of math expressions.\n\nExamples:\n\n     ## Run the example in '?matplot' or the following:\n     leg.txt &lt;- c(\"Setosa     Petals\", \"Setosa     Sepals\",\n                  \"Versicolor Petals\", \"Versicolor Sepals\")\n     y.leg &lt;- c(4.5, 3, 2.1, 1.4, .7)\n     cexv  &lt;- c(1.2, 1, 4/5, 2/3, 1/2)\n     matplot(c(1, 8), c(0, 4.5), type = \"n\", xlab = \"Length\", ylab = \"Width\",\n             main = \"Petal and Sepal Dimensions in Iris Blossoms\")\n     for (i in seq(cexv)) {\n       text  (1, y.leg[i] - 0.1, paste(\"cex=\", formatC(cexv[i])), cex = 0.8, adj = 0)\n       legend(3, y.leg[i], leg.txt, pch = \"sSvV\", col = c(1, 3), cex = cexv[i])\n     }\n     ## cex *vector* [in R &lt;= 3.5.1 has 'if(xc &lt; 0)' w/ length(xc) == 2]\n     legend(\"right\", leg.txt, pch = \"sSvV\", col = c(1, 3),\n            cex = 1+(-1:2)/8, trace = TRUE)# trace: show computed lengths & coords\n     \n     ## 'merge = TRUE' for merging lines & points:\n     x &lt;- seq(-pi, pi, length.out = 65)\n     for(reverse in c(FALSE, TRUE)) {  ## normal *and* reverse axes:\n       F &lt;- if(reverse) rev else identity\n       plot(x, sin(x), type = \"l\", col = 3, lty = 2,\n            xlim = F(range(x)), ylim = F(c(-1.2, 1.8)))\n       points(x, cos(x), pch = 3, col = 4)\n       lines(x, tan(x), type = \"b\", lty = 1, pch = 4, col = 6)\n       title(\"legend('top', lty = c(2, -1, 1), pch = c(NA, 3, 4), merge = TRUE)\",\n             cex.main = 1.1)\n       legend(\"top\", c(\"sin\", \"cos\", \"tan\"), col = c(3, 4, 6),\n            text.col = \"green4\", lty = c(2, -1, 1), pch = c(NA, 3, 4),\n            merge = TRUE, bg = \"gray90\", trace=TRUE)\n       \n     } # for(..)\n     \n     ## right-justifying a set of labels: thanks to Uwe Ligges\n     x &lt;- 1:5; y1 &lt;- 1/x; y2 &lt;- 2/x\n     plot(rep(x, 2), c(y1, y2), type = \"n\", xlab = \"x\", ylab = \"y\")\n     lines(x, y1); lines(x, y2, lty = 2)\n     temp &lt;- legend(\"topright\", legend = c(\" \", \" \"),\n                    text.width = strwidth(\"1,000,000\"),\n                    lty = 1:2, xjust = 1, yjust = 1, inset = 1/10,\n                    title = \"Line Types\", title.cex = 0.5, trace=TRUE)\n     text(temp$rect$left + temp$rect$w, temp$text$y,\n          c(\"1,000\", \"1,000,000\"), pos = 2)\n     \n     \n     ##--- log scaled Examples ------------------------------\n     leg.txt &lt;- c(\"a one\", \"a two\")\n     \n     par(mfrow = c(2, 2))\n     for(ll in c(\"\",\"x\",\"y\",\"xy\")) {\n       plot(2:10, log = ll, main = paste0(\"log = '\", ll, \"'\"))\n       abline(1, 1)\n       lines(2:3, 3:4, col = 2)\n       points(2, 2, col = 3)\n       rect(2, 3, 3, 2, col = 4)\n       text(c(3,3), 2:3, c(\"rect(2,3,3,2, col=4)\",\n                           \"text(c(3,3),2:3,\\\"c(rect(...)\\\")\"), adj = c(0, 0.3))\n       legend(list(x = 2,y = 8), legend = leg.txt, col = 2:3, pch = 1:2,\n              lty = 1)  #, trace = TRUE)\n     } #      ^^^^^^^ to force lines -&gt; automatic merge=TRUE\n     par(mfrow = c(1,1))\n     \n     ##-- Math expressions:  ------------------------------\n     x &lt;- seq(-pi, pi, length.out = 65)\n     plot(x, sin(x), type = \"l\", col = 2, xlab = expression(phi),\n          ylab = expression(f(phi)))\n     abline(h = -1:1, v = pi/2*(-6:6), col = \"gray90\")\n     lines(x, cos(x), col = 3, lty = 2)\n     ex.cs1 &lt;- expression(plain(sin) * phi,  paste(\"cos\", phi))  # 2 ways\n     utils::str(legend(-3, .9, ex.cs1, lty = 1:2, plot = FALSE,\n                adj = c(0, 0.6)))  # adj y !\n     legend(-3, 0.9, ex.cs1, lty = 1:2, col = 2:3,  adj = c(0, 0.6))\n     \n     require(stats)\n     x &lt;- rexp(100, rate = .5)\n     hist(x, main = \"Mean and Median of a Skewed Distribution\")\n     abline(v = mean(x),   col = 2, lty = 2, lwd = 2)\n     abline(v = median(x), col = 3, lty = 3, lwd = 2)\n     ex12 &lt;- expression(bar(x) == sum(over(x[i], n), i == 1, n),\n                        hat(x) == median(x[i], i == 1, n))\n     utils::str(legend(4.1, 30, ex12, col = 2:3, lty = 2:3, lwd = 2))\n     \n     ## 'Filled' boxes -- see also example(barplot) which may call legend(*, fill=)\n     barplot(VADeaths)\n     legend(\"topright\", rownames(VADeaths), fill = gray.colors(nrow(VADeaths)))\n     \n     ## Using 'ncol'\n     x &lt;- 0:64/64\n     for(R in c(identity, rev)) { # normal *and* reverse x-axis works fine:\n       xl &lt;- R(range(x)); x1 &lt;- xl[1]\n     matplot(x, outer(x, 1:7, function(x, k) sin(k * pi * x)), xlim=xl,\n             type = \"o\", col = 1:7, ylim = c(-1, 1.5), pch = \"*\")\n     op &lt;- par(bg = \"antiquewhite1\")\n     legend(x1, 1.5, paste(\"sin(\", 1:7, \"pi * x)\"), col = 1:7, lty = 1:7,\n            pch = \"*\", ncol = 4, cex = 0.8)\n     legend(\"bottomright\", paste(\"sin(\", 1:7, \"pi * x)\"), col = 1:7, lty = 1:7,\n            pch = \"*\", cex = 0.8)\n     legend(x1, -.1, paste(\"sin(\", 1:4, \"pi * x)\"), col = 1:4, lty = 1:4,\n            ncol = 2, cex = 0.8)\n     legend(x1, -.4, paste(\"sin(\", 5:7, \"pi * x)\"), col = 4:6,  pch = 24,\n            ncol = 2, cex = 1.5, lwd = 2, pt.bg = \"pink\", pt.cex = 1:3)\n     par(op)\n       \n     } # for(..)\n     \n     ## point covering line :\n     y &lt;- sin(3*pi*x)\n     plot(x, y, type = \"l\", col = \"blue\",\n         main = \"points with bg & legend(*, pt.bg)\")\n     points(x, y, pch = 21, bg = \"white\")\n     legend(.4,1, \"sin(c x)\", pch = 21, pt.bg = \"white\", lty = 1, col = \"blue\")\n     \n     ## legends with titles at different locations\n     plot(x, y, type = \"n\")\n     legend(\"bottomright\", \"(x,y)\", pch=1, title= \"bottomright\")\n     legend(\"bottom\",      \"(x,y)\", pch=1, title= \"bottom\")\n     legend(\"bottomleft\",  \"(x,y)\", pch=1, title= \"bottomleft\")\n     legend(\"left\",        \"(x,y)\", pch=1, title= \"left\")\n     legend(\"topleft\",     \"(x,y)\", pch=1, title= \"topleft, inset = .05\", inset = .05)\n     legend(\"top\",         \"(x,y)\", pch=1, title= \"top\")\n     legend(\"topright\",    \"(x,y)\", pch=1, title= \"topright, inset = .02\",inset = .02)\n     legend(\"right\",       \"(x,y)\", pch=1, title= \"right\")\n     legend(\"center\",      \"(x,y)\", pch=1, title= \"center\")\n     \n     # using text.font (and text.col):\n     op &lt;- par(mfrow = c(2, 2), mar = rep(2.1, 4))\n     c6 &lt;- terrain.colors(10)[1:6]\n     for(i in 1:4) {\n        plot(1, type = \"n\", axes = FALSE, ann = FALSE); title(paste(\"text.font =\",i))\n        legend(\"top\", legend = LETTERS[1:6], col = c6,\n               ncol = 2, cex = 2, lwd = 3, text.font = i, text.col = c6)\n     }\n     par(op)\n     \n     # using text.width for several columns\n     plot(1, type=\"n\")\n     legend(\"topleft\", c(\"This legend\", \"has\", \"equally sized\", \"columns.\"),\n            pch = 1:4, ncol = 4)\n     legend(\"bottomleft\", c(\"This legend\", \"has\", \"optimally sized\", \"columns.\"),\n            pch = 1:4, ncol = 4, text.width = NA)\n     legend(\"right\", letters[1:4], pch = 1:4, ncol = 4,\n            text.width = 1:4 / 50)"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#barplot-example-1",
    "href": "modules/Module10-DataVisualization.html#barplot-example-1",
    "title": "Module 10: Data Visualization",
    "section": "barplot() example",
    "text": "barplot() example\nGetting closer, but what I really want is column proportions (i.e., the proportions should sum to one for each age group). Also, the age groups need more meaningful names.\n\nfreq &lt;- table(df$seropos, df$age_group)\ntot.per.age.group &lt;- colSums(freq)\nage.seropos.matrix &lt;- t(t(freq)/tot.per.age.group)\ncolnames(age.seropos.matrix) &lt;- c(\"1-5 yo\", \"6-10 yo\", \"11-15 yo\")\n\nbarplot(age.seropos.matrix, col=c(\"darkblue\",\"red\"), ylim=c(0,1.35), main=\"Seropositivity by Age Group\")\naxis(2, at = c(0.2, 0.4, 0.6, 0.8,1))\nlegend(x=2.8, y=1.35,\n             fill=c(\"darkblue\",\"red\"), \n             legend = c(\"seronegative\", \"seropositive\"))"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#summary",
    "href": "modules/Module10-DataVisualization.html#summary",
    "title": "Module 10: Data Visualization",
    "section": "Summary",
    "text": "Summary"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#acknowledgements",
    "href": "modules/Module10-DataVisualization.html#acknowledgements",
    "title": "Module 10: Data Visualization",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nThese are the materials I looked through, modified, or extracted to complete this module’s lecture.\n\n“Base Plotting in R” by Medium\n  [\"Base R margins: a cheatsheet\"](https://r-graph-gallery.com/74-margin-and-oma-cheatsheet.html)"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#base-r-plotting",
    "href": "modules/Module10-DataVisualization.html#base-r-plotting",
    "title": "Module 10: Data Visualization",
    "section": "Base R Plotting",
    "text": "Base R Plotting\nTo make a plot you often need to specify the following features:\n\nParameters\nPlot attributes\nThe legend"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#parameters",
    "href": "modules/Module10-DataVisualization.html#parameters",
    "title": "Module 10: Data Visualization",
    "section": "1. Parameters",
    "text": "1. Parameters\nThe parameter section fixes the settings for all your plots, basically the plot options. Adding attributes via par() before you call the plot creates ‘global’ settings for your plot.\nIn the example below, we have set two commonly used optional attributes in the global plot settings. - The mfrow specifies that we have one row and two columns of plots — that is, two plots side by side. - The mar attribute is a vector of our margin widths, with the first value indicating the margin below the plot (5), the second indicating the margin to the left of the plot (5), the third, the top of the plot(4), and the fourth to the left (1).\npar(mfrow = c(1,2), mar = c(5,5,4,1))"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#plot-attributes",
    "href": "modules/Module10-DataVisualization.html#plot-attributes",
    "title": "Module 10: Data Visualization",
    "section": "2. Plot Attributes",
    "text": "2. Plot Attributes\nPlot attributes are those that map your data to the plot. This mean this is where you specify what variables in the data frame you want to plot.\nWe will only look at four types of plots today:\n\nhist() displays histogram of one variable\nplot() displays x-y plot of two variables\nboxplot() displays boxplot\nbarplot() displays barplot"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#barplot-example-2",
    "href": "modules/Module10-DataVisualization.html#barplot-example-2",
    "title": "Module 10: Data Visualization",
    "section": "barplot() example",
    "text": "barplot() example\nNow, let look at seropositivity by two individual level characteristics in the same plot.\n\npar(mfrow = c(1,2))\nbarplot(age.seropos.matrix, col=c(\"darkblue\",\"red\"), ylim=c(0,1.35), main=\"Seropositivity by Age Group\")\naxis(2, at = c(0.2, 0.4, 0.6, 0.8,1))\nlegend(x=1, y=1.35, fill=c(\"darkblue\",\"red\"), legend = c(\"seronegative\", \"seropositive\"))\n\nbarplot(slum.seropos.matrix, col=c(\"darkblue\",\"red\"), ylim=c(0,1.35), main=\"Seropositivity by Residence\")\naxis(2, at = c(0.2, 0.4, 0.6, 0.8,1))\nlegend(x=1, y=1.35, fill=c(\"darkblue\",\"red\"),  legend = c(\"seronegative\", \"seropositive\"))"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#add-legend-to-the-plot",
    "href": "modules/Module10-DataVisualization.html#add-legend-to-the-plot",
    "title": "Module 10: Data Visualization",
    "section": "Add legend to the plot",
    "text": "Add legend to the plot\nReminder\nlegend(x, y = NULL, legend, fill = NULL, col = par(\"col\"),\n       border = \"black\", lty, lwd, pch,\n       angle = 45, density = NULL, bty = \"o\", bg = par(\"bg\"),\n       box.lwd = par(\"lwd\"), box.lty = par(\"lty\"), box.col = par(\"fg\"),\n       pt.bg = NA, cex = 1, pt.cex = cex, pt.lwd = lwd,\n       xjust = 0, yjust = 1, x.intersp = 1, y.intersp = 1,\n       adj = c(0, 0.5), text.width = NULL, text.col = par(\"col\"),\n       text.font = NULL, merge = do.lines && has.pch, trace = FALSE,\n       plot = TRUE, ncol = 1, horiz = FALSE, title = NULL,\n       inset = 0, xpd, title.col = text.col[1], title.adj = 0.5,\n       title.cex = cex[1], title.font = text.font[1],\n       seg.len = 2)\nLet’s practice\n\nbarplot(prop, col=c(\"darkblue\",\"red\"), ylim=c(0,0.7), main=\"Seropositivity by Age Group\")\nlegend(x=2.5, y=0.7,\n             fill=c(\"darkblue\",\"red\"), \n             legend = c(\"seronegative\", \"seropositive\"))"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#lots-of-parameters-options",
    "href": "modules/Module10-DataVisualization.html#lots-of-parameters-options",
    "title": "Module 10: Data Visualization",
    "section": "Lots of parameters options",
    "text": "Lots of parameters options\nHowever, there are many more parameter options that can be specified in the ‘global’ settings or specific to a certain plot option.\n\n?par\n\nSet or Query Graphical Parameters\nDescription:\n 'par' can be used to set or query graphical parameters.\n Parameters can be set by specifying them as arguments to 'par' in\n 'tag = value' form, or by passing them as a list of tagged values.\nUsage:\n par(..., no.readonly = FALSE)\n \n &lt;highlevel plot&gt; (...., &lt;tag&gt; = &lt;value&gt;)\n \nArguments:\n ...: arguments in 'tag = value' form, a single list of tagged\n      values, or character vectors of parameter names. Supported\n      parameters are described in the 'Graphical Parameters'\n      section.\nno.readonly: logical; if ‘TRUE’ and there are no other arguments, only parameters are returned which can be set by a subsequent ‘par()’ call on the same device.\nDetails:\n Each device has its own set of graphical parameters.  If the\n current device is the null device, 'par' will open a new device\n before querying/setting parameters.  (What device is controlled by\n 'options(\"device\")'.)\n\n Parameters are queried by giving one or more character vectors of\n parameter names to 'par'.\n\n 'par()' (no arguments) or 'par(no.readonly = TRUE)' is used to get\n _all_ the graphical parameters (as a named list).  Their names are\n currently taken from the unexported variable 'graphics:::.Pars'.\n\n _*R.O.*_ indicates _*read-only arguments*_: These may only be used\n in queries and cannot be set.  ('\"cin\"', '\"cra\"', '\"csi\"',\n '\"cxy\"', '\"din\"' and '\"page\"' are always read-only.)\n\n Several parameters can only be set by a call to 'par()':\n\n    • '\"ask\"',\n\n    • '\"fig\"', '\"fin\"',\n\n    • '\"lheight\"',\n\n    • '\"mai\"', '\"mar\"', '\"mex\"', '\"mfcol\"', '\"mfrow\"', '\"mfg\"',\n\n    • '\"new\"',\n\n    • '\"oma\"', '\"omd\"', '\"omi\"',\n\n    • '\"pin\"', '\"plt\"', '\"ps\"', '\"pty\"',\n\n    • '\"usr\"',\n\n    • '\"xlog\"', '\"ylog\"',\n\n    • '\"ylbias\"'\n\n The remaining parameters can also be set as arguments (often via\n '...') to high-level plot functions such as 'plot.default',\n 'plot.window', 'points', 'lines', 'abline', 'axis', 'title',\n 'text', 'mtext', 'segments', 'symbols', 'arrows', 'polygon',\n 'rect', 'box', 'contour', 'filled.contour' and 'image'.  Such\n settings will be active during the execution of the function,\n only.  However, see the comments on 'bg', 'cex', 'col', 'lty',\n 'lwd' and 'pch' which may be taken as _arguments_ to certain plot\n functions rather than as graphical parameters.\n\n The meaning of 'character size' is not well-defined: this is set\n up for the device taking 'pointsize' into account but often not\n the actual font family in use.  Internally the corresponding pars\n ('cra', 'cin', 'cxy' and 'csi') are used only to set the\n inter-line spacing used to convert 'mar' and 'oma' to physical\n margins.  (The same inter-line spacing multiplied by 'lheight' is\n used for multi-line strings in 'text' and 'strheight'.)\n\n Note that graphical parameters are suggestions: plotting functions\n and devices need not make use of them (and this is particularly\n true of non-default methods for e.g. 'plot').\nValue:\n When parameters are set, their previous values are returned in an\n invisible named list.  Such a list can be passed as an argument to\n 'par' to restore the parameter values.  Use 'par(no.readonly =\n TRUE)' for the full list of parameters that can be restored.\n However, restoring all of these is not wise: see the 'Note'\n section.\n\n When just one parameter is queried, the value of that parameter is\n returned as (atomic) vector.  When two or more parameters are\n queried, their values are returned in a list, with the list names\n giving the parameters.\n\n Note the inconsistency: setting one parameter returns a list, but\n querying one parameter returns a vector.\nGraphical Parameters:\n 'adj' The value of 'adj' determines the way in which text strings\n      are justified in 'text', 'mtext' and 'title'.  A value of '0'\n      produces left-justified text, '0.5' (the default) centered\n      text and '1' right-justified text.  (Any value in [0, 1] is\n      allowed, and on most devices values outside that interval\n      will also work.)\n\n      Note that the 'adj' _argument_ of 'text' also allows 'adj =\n      c(x, y)' for different adjustment in x- and y- directions.\n      Note that whereas for 'text' it refers to positioning of text\n      about a point, for 'mtext' and 'title' it controls placement\n      within the plot or device region.\n\n 'ann' If set to 'FALSE', high-level plotting functions calling\n      'plot.default' do not annotate the plots they produce with\n      axis titles and overall titles.  The default is to do\n      annotation.\n\n 'ask' logical.  If 'TRUE' (and the R session is interactive) the\n      user is asked for input, before a new figure is drawn.  As\n      this applies to the device, it also affects output by\n      packages 'grid' and 'lattice'.  It can be set even on\n      non-screen devices but may have no effect there.\n\n      This not really a graphics parameter, and its use is\n      deprecated in favour of 'devAskNewPage'.\n\n 'bg' The color to be used for the background of the device region.\n      When called from 'par()' it also sets 'new = FALSE'. See\n      section 'Color Specification' for suitable values.  For many\n      devices the initial value is set from the 'bg' argument of\n      the device, and for the rest it is normally '\"white\"'.\n\n      Note that some graphics functions such as 'plot.default' and\n      'points' have an _argument_ of this name with a different\n      meaning.\n\n 'bty' A character string which determined the type of 'box' which\n      is drawn about plots.  If 'bty' is one of '\"o\"' (the\n      default), '\"l\"', '\"7\"', '\"c\"', '\"u\"', or '\"]\"' the resulting\n      box resembles the corresponding upper case letter.  A value\n      of '\"n\"' suppresses the box.\n\n 'cex' A numerical value giving the amount by which plotting text\n      and symbols should be magnified relative to the default.\n      This starts as '1' when a device is opened, and is reset when\n      the layout is changed, e.g. by setting 'mfrow'.\n\n      Note that some graphics functions such as 'plot.default' have\n      an _argument_ of this name which _multiplies_ this graphical\n      parameter, and some functions such as 'points' and 'text'\n      accept a vector of values which are recycled.\n\n 'cex.axis' The magnification to be used for axis annotation\n      relative to the current setting of 'cex'.\n\n 'cex.lab' The magnification to be used for x and y labels relative\n      to the current setting of 'cex'.\n\n 'cex.main' The magnification to be used for main titles relative\n      to the current setting of 'cex'.\n\n 'cex.sub' The magnification to be used for sub-titles relative to\n      the current setting of 'cex'.\n\n 'cin' _*R.O.*_; character size '(width, height)' in inches.  These\n      are the same measurements as 'cra', expressed in different\n      units.\n\n 'col' A specification for the default plotting color.  See section\n      'Color Specification'.\n\n      Some functions such as 'lines' and 'text' accept a vector of\n      values which are recycled and may be interpreted slightly\n      differently.\n\n 'col.axis' The color to be used for axis annotation.  Defaults to\n      '\"black\"'.\n\n 'col.lab' The color to be used for x and y labels.  Defaults to\n      '\"black\"'.\n\n 'col.main' The color to be used for plot main titles.  Defaults to\n      '\"black\"'.\n\n 'col.sub' The color to be used for plot sub-titles.  Defaults to\n      '\"black\"'.\n\n 'cra' _*R.O.*_; size of default character '(width, height)' in\n      'rasters' (pixels).  Some devices have no concept of pixels\n      and so assume an arbitrary pixel size, usually 1/72 inch.\n      These are the same measurements as 'cin', expressed in\n      different units.\n\n 'crt' A numerical value specifying (in degrees) how single\n      characters should be rotated.  It is unwise to expect values\n      other than multiples of 90 to work.  Compare with 'srt' which\n      does string rotation.\n\n 'csi' _*R.O.*_; height of (default-sized) characters in inches.\n      The same as 'par(\"cin\")[2]'.\n\n 'cxy' _*R.O.*_; size of default character '(width, height)' in\n      user coordinate units.  'par(\"cxy\")' is\n      'par(\"cin\")/par(\"pin\")' scaled to user coordinates.  Note\n      that 'c(strwidth(ch), strheight(ch))' for a given string 'ch'\n      is usually much more precise.\n\n 'din' _*R.O.*_; the device dimensions, '(width, height)', in\n      inches.  See also 'dev.size', which is updated immediately\n      when an on-screen device windows is re-sized.\n\n 'err' (_Unimplemented_; R is silent when points outside the plot\n      region are _not_ plotted.)  The degree of error reporting\n      desired.\n\n 'family' The name of a font family for drawing text.  The maximum\n      allowed length is 200 bytes.  This name gets mapped by each\n      graphics device to a device-specific font description.  The\n      default value is '\"\"' which means that the default device\n      fonts will be used (and what those are should be listed on\n      the help page for the device).  Standard values are\n      '\"serif\"', '\"sans\"' and '\"mono\"', and the Hershey font\n      families are also available.  (Devices may define others, and\n      some devices will ignore this setting completely.  Names\n      starting with '\"Hershey\"' are treated specially and should\n      only be used for the built-in Hershey font families.)  This\n      can be specified inline for 'text'.\n\n 'fg' The color to be used for the foreground of plots.  This is\n      the default color used for things like axes and boxes around\n      plots.  When called from 'par()' this also sets parameter\n      'col' to the same value.  See section 'Color Specification'.\n      A few devices have an argument to set the initial value,\n      which is otherwise '\"black\"'.\n\n 'fig' A numerical vector of the form 'c(x1, x2, y1, y2)' which\n      gives the (NDC) coordinates of the figure region in the\n      display region of the device. If you set this, unlike S, you\n      start a new plot, so to add to an existing plot use 'new =\n      TRUE' as well.\n\n 'fin' The figure region dimensions, '(width, height)', in inches.\n      If you set this, unlike S, you start a new plot.\n\n 'font' An integer which specifies which font to use for text.  If\n      possible, device drivers arrange so that 1 corresponds to\n      plain text (the default), 2 to bold face, 3 to italic and 4\n      to bold italic.  Also, font 5 is expected to be the symbol\n      font, in Adobe symbol encoding.  On some devices font\n      families can be selected by 'family' to choose different sets\n      of 5 fonts.\n\n 'font.axis' The font to be used for axis annotation.\n\n 'font.lab' The font to be used for x and y labels.\n\n 'font.main' The font to be used for plot main titles.\n\n 'font.sub' The font to be used for plot sub-titles.\n\n 'lab' A numerical vector of the form 'c(x, y, len)' which modifies\n      the default way that axes are annotated.  The values of 'x'\n      and 'y' give the (approximate) number of tickmarks on the x\n      and y axes and 'len' specifies the label length.  The default\n      is 'c(5, 5, 7)'.  'len' _is unimplemented_ in R.\n\n 'las' numeric in {0,1,2,3}; the style of axis labels.\n\n      0: always parallel to the axis [_default_],\n\n      1: always horizontal,\n\n      2: always perpendicular to the axis,\n\n      3: always vertical.\n\n      Also supported by 'mtext'.  Note that string/character\n      rotation _via_ argument 'srt' to 'par' does _not_ affect the\n      axis labels.\n\n 'lend' The line end style.  This can be specified as an integer or\n      string:\n\n      '0' and '\"round\"' mean rounded line caps [_default_];\n\n      '1' and '\"butt\"' mean butt line caps;\n\n      '2' and '\"square\"' mean square line caps.\n\n 'lheight' The line height multiplier.  The height of a line of\n      text (used to vertically space multi-line text) is found by\n      multiplying the character height both by the current\n      character expansion and by the line height multiplier.\n      Default value is 1.  Used in 'text' and 'strheight'.\n\n 'ljoin' The line join style.  This can be specified as an integer\n      or string:\n\n      '0' and '\"round\"' mean rounded line joins [_default_];\n\n      '1' and '\"mitre\"' mean mitred line joins;\n\n      '2' and '\"bevel\"' mean bevelled line joins.\n\n 'lmitre' The line mitre limit.  This controls when mitred line\n      joins are automatically converted into bevelled line joins.\n      The value must be larger than 1 and the default is 10.  Not\n      all devices will honour this setting.\n\n 'lty' The line type.  Line types can either be specified as an\n      integer (0=blank, 1=solid (default), 2=dashed, 3=dotted,\n      4=dotdash, 5=longdash, 6=twodash) or as one of the character\n      strings '\"blank\"', '\"solid\"', '\"dashed\"', '\"dotted\"',\n      '\"dotdash\"', '\"longdash\"', or '\"twodash\"', where '\"blank\"'\n      uses 'invisible lines' (i.e., does not draw them).\n\n      Alternatively, a string of up to 8 characters (from 'c(1:9,\n      \"A\":\"F\")') may be given, giving the length of line segments\n      which are alternatively drawn and skipped.  See section 'Line\n      Type Specification'.\n\n      Functions such as 'lines' and 'segments' accept a vector of\n      values which are recycled.\n\n 'lwd' The line width, a _positive_ number, defaulting to '1'.  The\n      interpretation is device-specific, and some devices do not\n      implement line widths less than one.  (See the help on the\n      device for details of the interpretation.)\n\n      Functions such as 'lines' and 'segments' accept a vector of\n      values which are recycled: in such uses lines corresponding\n      to values 'NA' or 'NaN' are omitted.  The interpretation of\n      '0' is device-specific.\n\n 'mai' A numerical vector of the form 'c(bottom, left, top, right)'\n      which gives the margin size specified in inches.\n\n 'mar' A numerical vector of the form 'c(bottom, left, top, right)'\n      which gives the number of lines of margin to be specified on\n      the four sides of the plot.  The default is 'c(5, 4, 4, 2) +\n      0.1'.\n\n 'mex' 'mex' is a character size expansion factor which is used to\n      describe coordinates in the margins of plots. Note that this\n      does not change the font size, rather specifies the size of\n      font (as a multiple of 'csi') used to convert between 'mar'\n      and 'mai', and between 'oma' and 'omi'.\n\n      This starts as '1' when the device is opened, and is reset\n      when the layout is changed (alongside resetting 'cex').\n\n 'mfcol, mfrow' A vector of the form 'c(nr, nc)'.  Subsequent\n      figures will be drawn in an 'nr'-by-'nc' array on the device\n      by _columns_ ('mfcol'), or _rows_ ('mfrow'), respectively.\n\n      In a layout with exactly two rows and columns the base value\n      of '\"cex\"' is reduced by a factor of 0.83: if there are three\n      or more of either rows or columns, the reduction factor is\n      0.66.\n\n      Setting a layout resets the base value of 'cex' and that of\n      'mex' to '1'.\n\n      If either of these is queried it will give the current\n      layout, so querying cannot tell you the order in which the\n      array will be filled.\n\n      Consider the alternatives, 'layout' and 'split.screen'.\n\n 'mfg' A numerical vector of the form 'c(i, j)' where 'i' and 'j'\n      indicate which figure in an array of figures is to be drawn\n      next (if setting) or is being drawn (if enquiring).  The\n      array must already have been set by 'mfcol' or 'mfrow'.\n\n      For compatibility with S, the form 'c(i, j, nr, nc)' is also\n      accepted, when 'nr' and 'nc' should be the current number of\n      rows and number of columns.  Mismatches will be ignored, with\n      a warning.\n\n 'mgp' The margin line (in 'mex' units) for the axis title, axis\n      labels and axis line.  Note that 'mgp[1]' affects 'title'\n      whereas 'mgp[2:3]' affect 'axis'.  The default is 'c(3, 1,\n      0)'.\n\n 'mkh' The height in inches of symbols to be drawn when the value\n      of 'pch' is an integer. _Completely ignored in R_.\n\n 'new' logical, defaulting to 'FALSE'.  If set to 'TRUE', the next\n      high-level plotting command (actually 'plot.new') should _not\n      clean_ the frame before drawing _as if it were on a *_new_*\n      device_.  It is an error (ignored with a warning) to try to\n      use 'new = TRUE' on a device that does not currently contain\n      a high-level plot.\n\n 'oma' A vector of the form 'c(bottom, left, top, right)' giving\n      the size of the outer margins in lines of text.\n\n 'omd' A vector of the form 'c(x1, x2, y1, y2)' giving the region\n      _inside_ outer margins in NDC (= normalized device\n      coordinates), i.e., as a fraction (in [0, 1]) of the device\n      region.\n\n 'omi' A vector of the form 'c(bottom, left, top, right)' giving\n      the size of the outer margins in inches.\n\n 'page' _*R.O.*_; A boolean value indicating whether the next call\n      to 'plot.new' is going to start a new page.  This value may\n      be 'FALSE' if there are multiple figures on the page.\n\n 'pch' Either an integer specifying a symbol or a single character\n      to be used as the default in plotting points.  See 'points'\n      for possible values and their interpretation.  Note that only\n      integers and single-character strings can be set as a\n      graphics parameter (and not 'NA' nor 'NULL').\n\n      Some functions such as 'points' accept a vector of values\n      which are recycled.\n\n 'pin' The current plot dimensions, '(width, height)', in inches.\n\n 'plt' A vector of the form 'c(x1, x2, y1, y2)' giving the\n      coordinates of the plot region as fractions of the current\n      figure region.\n\n 'ps' integer; the point size of text (but not symbols).  Unlike\n      the 'pointsize' argument of most devices, this does not\n      change the relationship between 'mar' and 'mai' (nor 'oma'\n      and 'omi').\n\n      What is meant by 'point size' is device-specific, but most\n      devices mean a multiple of 1bp, that is 1/72 of an inch.\n\n 'pty' A character specifying the type of plot region to be used;\n      '\"s\"' generates a square plotting region and '\"m\"' generates\n      the maximal plotting region.\n\n 'smo' (_Unimplemented_) a value which indicates how smooth circles\n      and circular arcs should be.\n\n 'srt' The string rotation in degrees.  See the comment about\n      'crt'.  Only supported by 'text'.\n\n 'tck' The length of tick marks as a fraction of the smaller of the\n      width or height of the plotting region.  If 'tck &gt;= 0.5' it\n      is interpreted as a fraction of the relevant side, so if 'tck\n      = 1' grid lines are drawn.  The default setting ('tck = NA')\n      is to use 'tcl = -0.5'.\n\n 'tcl' The length of tick marks as a fraction of the height of a\n      line of text.  The default value is '-0.5'; setting 'tcl =\n      NA' sets 'tck = -0.01' which is S' default.\n\n 'usr' A vector of the form 'c(x1, x2, y1, y2)' giving the extremes\n      of the user coordinates of the plotting region.  When a\n      logarithmic scale is in use (i.e., 'par(\"xlog\")' is true, see\n      below), then the x-limits will be '10 ^ par(\"usr\")[1:2]'.\n      Similarly for the y-axis.\n\n 'xaxp' A vector of the form 'c(x1, x2, n)' giving the coordinates\n      of the extreme tick marks and the number of intervals between\n      tick-marks when 'par(\"xlog\")' is false.  Otherwise, when\n      _log_ coordinates are active, the three values have a\n      different meaning: For a small range, 'n' is _negative_, and\n      the ticks are as in the linear case, otherwise, 'n' is in\n      '1:3', specifying a case number, and 'x1' and 'x2' are the\n      lowest and highest power of 10 inside the user coordinates,\n      '10 ^ par(\"usr\")[1:2]'. (The '\"usr\"' coordinates are\n      log10-transformed here!)\n\n      n = 1 will produce tick marks at 10^j for integer j,\n\n      n = 2 gives marks k 10^j with k in {1,5},\n\n      n = 3 gives marks k 10^j with k in {1,2,5}.\n\n      See 'axTicks()' for a pure R implementation of this.\n\n      This parameter is reset when a user coordinate system is set\n      up, for example by starting a new page or by calling\n      'plot.window' or setting 'par(\"usr\")': 'n' is taken from\n      'par(\"lab\")'.  It affects the default behaviour of subsequent\n      calls to 'axis' for sides 1 or 3.\n\n      It is only relevant to default numeric axis systems, and not\n      for example to dates.\n\n 'xaxs' The style of axis interval calculation to be used for the\n      x-axis.  Possible values are '\"r\"', '\"i\"', '\"e\"', '\"s\"',\n      '\"d\"'.  The styles are generally controlled by the range of\n      data or 'xlim', if given.\n      Style '\"r\"' (regular) first extends the data range by 4\n      percent at each end and then finds an axis with pretty labels\n      that fits within the extended range.\n      Style '\"i\"' (internal) just finds an axis with pretty labels\n      that fits within the original data range.\n      Style '\"s\"' (standard) finds an axis with pretty labels\n      within which the original data range fits.\n      Style '\"e\"' (extended) is like style '\"s\"', except that it is\n      also ensures that there is room for plotting symbols within\n      the bounding box.\n      Style '\"d\"' (direct) specifies that the current axis should\n      be used on subsequent plots.\n      (_Only '\"r\"' and '\"i\"' styles have been implemented in R._)\n\n 'xaxt' A character which specifies the x axis type.  Specifying\n      '\"n\"' suppresses plotting of the axis.  The standard value is\n      '\"s\"': for compatibility with S values '\"l\"' and '\"t\"' are\n      accepted but are equivalent to '\"s\"': any value other than\n      '\"n\"' implies plotting.\n\n 'xlog' A logical value (see 'log' in 'plot.default').  If 'TRUE',\n      a logarithmic scale is in use (e.g., after 'plot(*, log =\n      \"x\")').  For a new device, it defaults to 'FALSE', i.e.,\n      linear scale.\n\n 'xpd' A logical value or 'NA'.  If 'FALSE', all plotting is\n      clipped to the plot region, if 'TRUE', all plotting is\n      clipped to the figure region, and if 'NA', all plotting is\n      clipped to the device region.  See also 'clip'.\n\n 'yaxp' A vector of the form 'c(y1, y2, n)' giving the coordinates\n      of the extreme tick marks and the number of intervals between\n      tick-marks unless for log coordinates, see 'xaxp' above.\n\n 'yaxs' The style of axis interval calculation to be used for the\n      y-axis.  See 'xaxs' above.\n\n 'yaxt' A character which specifies the y axis type.  Specifying\n      '\"n\"' suppresses plotting.\n\n 'ylbias' A positive real value used in the positioning of text in\n      the margins by 'axis' and 'mtext'.  The default is in\n      principle device-specific, but currently '0.2' for all of R's\n      own devices.  Set this to '0.2' for compatibility with R &lt;\n      2.14.0 on 'x11' and 'windows()' devices.\n\n 'ylog' A logical value; see 'xlog' above.\nColor Specification:\n Colors can be specified in several different ways. The simplest\n way is with a character string giving the color name (e.g.,\n '\"red\"').  A list of the possible colors can be obtained with the\n function 'colors'.  Alternatively, colors can be specified\n directly in terms of their RGB components with a string of the\n form '\"#RRGGBB\"' where each of the pairs 'RR', 'GG', 'BB' consist\n of two hexadecimal digits giving a value in the range '00' to\n 'FF'.  Colors can also be specified by giving an index into a\n small table of colors, the 'palette': indices wrap round so with\n the default palette of size 8, '10' is the same as '2'.  This\n provides compatibility with S.  Index '0' corresponds to the\n background color.  Note that the palette (apart from '0' which is\n per-device) is a per-session setting.\n\n Negative integer colours are errors.\n\n Additionally, '\"transparent\"' is _transparent_, useful for filled\n areas (such as the background!), and just invisible for things\n like lines or text.  In most circumstances (integer) 'NA' is\n equivalent to '\"transparent\"' (but not for 'text' and 'mtext').\n\n Semi-transparent colors are available for use on devices that\n support them.\n\n The functions 'rgb', 'hsv', 'hcl', 'gray' and 'rainbow' provide\n additional ways of generating colors.\nLine Type Specification:\n Line types can either be specified by giving an index into a small\n built-in table of line types (1 = solid, 2 = dashed, etc, see\n 'lty' above) or directly as the lengths of on/off stretches of\n line.  This is done with a string of an even number (up to eight)\n of characters, namely _non-zero_ (hexadecimal) digits which give\n the lengths in consecutive positions in the string.  For example,\n the string '\"33\"' specifies three units on followed by three off\n and '\"3313\"' specifies three units on followed by three off\n followed by one on and finally three off.  The 'units' here are\n (on most devices) proportional to 'lwd', and with 'lwd = 1' are in\n pixels or points or 1/96 inch.\n\n The five standard dash-dot line types ('lty = 2:6') correspond to\n 'c(\"44\", \"13\", \"1343\", \"73\", \"2262\")'.\n\n Note that 'NA' is not a valid value for 'lty'.\nNote:\n The effect of restoring all the (settable) graphics parameters as\n in the examples is hard to predict if the device has been resized.\n Several of them are attempting to set the same things in different\n ways, and those last in the alphabet will win.  In particular, the\n settings of 'mai', 'mar', 'pin', 'plt' and 'pty' interact, as do\n the outer margin settings, the figure layout and figure region\n size.\nReferences:\n Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S\n Language_.  Wadsworth & Brooks/Cole.\n\n Murrell, P. (2005) _R Graphics_. Chapman & Hall/CRC Press.\nSee Also:\n 'plot.default' for some high-level plotting parameters; 'colors';\n 'clip'; 'options' for other setup parameters; graphic devices\n 'x11', 'postscript' and setting up device regions by 'layout' and\n 'split.screen'.\nExamples:\n op &lt;- par(mfrow = c(2, 2), # 2 x 2 pictures on one plot\n           pty = \"s\")       # square plotting region,\n                            # independent of device size\n \n ## At end of plotting, reset to previous settings:\n par(op)\n \n ## Alternatively,\n op &lt;- par(no.readonly = TRUE) # the whole list of settable par's.\n ## do lots of plotting and par(.) calls, then reset:\n par(op)\n ## Note this is not in general good practice\n \n par(\"ylog\") # FALSE\n plot(1 : 12, log = \"y\")\n par(\"ylog\") # TRUE\n \n plot(1:2, xaxs = \"i\") # 'inner axis' w/o extra space\n par(c(\"usr\", \"xaxp\"))\n \n ( nr.prof &lt;-\n c(prof.pilots = 16, lawyers = 11, farmers = 10, salesmen = 9, physicians = 9,\n   mechanics = 6, policemen = 6, managers = 6, engineers = 5, teachers = 4,\n   housewives = 3, students = 3, armed.forces = 1))\n par(las = 3)\n barplot(rbind(nr.prof)) # R 0.63.2: shows alignment problem\n par(las = 0)  # reset to default\n \n require(grDevices) # for gray\n ## 'fg' use:\n plot(1:12, type = \"b\", main = \"'fg' : axes, ticks and box in gray\",\n      fg = gray(0.7), bty = \"7\" , sub = R.version.string)\n \n ex &lt;- function() {\n    old.par &lt;- par(no.readonly = TRUE) # all par settings which\n                                       # could be changed.\n    on.exit(par(old.par))\n    ## ...\n    ## ... do lots of par() settings and plots\n    ## ...\n    invisible() #-- now,  par(old.par)  will be executed\n }\n ex()\n \n ## Line types\n showLty &lt;- function(ltys, xoff = 0, ...) {\n    stopifnot((n &lt;- length(ltys)) &gt;= 1)\n    op &lt;- par(mar = rep(.5,4)); on.exit(par(op))\n    plot(0:1, 0:1, type = \"n\", axes = FALSE, ann = FALSE)\n    y &lt;- (n:1)/(n+1)\n    clty &lt;- as.character(ltys)\n    mytext &lt;- function(x, y, txt)\n       text(x, y, txt, adj = c(0, -.3), cex = 0.8, ...)\n    abline(h = y, lty = ltys, ...); mytext(xoff, y, clty)\n    y &lt;- y - 1/(3*(n+1))\n    abline(h = y, lty = ltys, lwd = 2, ...)\n    mytext(1/8+xoff, y, paste(clty,\" lwd = 2\"))\n }\n showLty(c(\"solid\", \"dashed\", \"dotted\", \"dotdash\", \"longdash\", \"twodash\"))\n par(new = TRUE)  # the same:\n showLty(c(\"solid\", \"44\", \"13\", \"1343\", \"73\", \"2262\"), xoff = .2, col = 2)\n showLty(c(\"11\", \"22\", \"33\", \"44\",   \"12\", \"13\", \"14\",   \"21\", \"31\"))"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#common-parameter-options",
    "href": "modules/Module10-DataVisualization.html#common-parameter-options",
    "title": "Module 10: Data Visualization",
    "section": "Common parameter options",
    "text": "Common parameter options\nSix useful parameter arguments help improve the readability of the plot:\n\nxlab: specifies the x-axis label of the plot\nylab: specifies the y-axis label\nmain: titles your graph\npch: specifies the symbology of your graph\nlty: specifies the line type of your graph\nlwd: specifies line thickness\ncex : specifies size\ncol: specifies the colors for your graph.\n\nWe will explore use of these arguments below."
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#common-parameter-options-1",
    "href": "modules/Module10-DataVisualization.html#common-parameter-options-1",
    "title": "Module 10: Data Visualization",
    "section": "Common parameter options",
    "text": "Common parameter options"
  }
]