[
  {
    "objectID": "schedule.html",
    "href": "schedule.html",
    "title": "Course Schedule",
    "section": "",
    "text": "Meeting times:\nLocation: Randal Rollins Building (RR) 201, Emory University",
    "crumbs": [
      "Course Schedule"
    ]
  },
  {
    "objectID": "schedule.html#day-01-monday",
    "href": "schedule.html#day-01-monday",
    "title": "Course Schedule",
    "section": "Day 01 – Monday",
    "text": "Day 01 – Monday\n\n\n\n\n\n\n\nTime\nSection\n\n\n\n\n08:30 am - 10:00 am\ncontent\n\n\n10:00 am - 10:15 am\nCoffee break\n\n\n10:30 am - 12:00 pm\ncontent\n\n\n12:00 pm - 01:30 pm\nLunch (2nd floor lobby)\n\n\n01:30 pm - 03:00 pm\ncontent\n\n\n03:00 pm - 03:15 pm\nCoffee break\n\n\n03:00 pm - 05:00 pm\ncontent\n\n\n05:00 pm - 07:00 pm\nNetworking night and poster session, Randal Rollins P01",
    "crumbs": [
      "Course Schedule"
    ]
  },
  {
    "objectID": "schedule.html#day-02-tuesday",
    "href": "schedule.html#day-02-tuesday",
    "title": "Course Schedule",
    "section": "Day 02 – Tuesday",
    "text": "Day 02 – Tuesday\n\n\n\n\n\n\n\nTime\nSection\n\n\n\n\n08:30 am - 10:00 am\ncontent\n\n\n10:00 am - 10:15 am\nCoffee break\n\n\n10:30 am - 12:00 pm\ncontent\n\n\n12:00 pm - 01:30 pm\nLunch (2nd floor lobby); Lunch and Learn!\n\n\n01:30 pm - 03:00 pm\ncontent\n\n\n03:00 pm - 03:15 pm\nCoffee break\n\n\n03:00 pm - 05:00 pm\ncontent\n\n\n05:00 pm - 07:00 pm\nNetworking night and poster session, Randal Rollins P01",
    "crumbs": [
      "Course Schedule"
    ]
  },
  {
    "objectID": "schedule.html#day-03-wednesday",
    "href": "schedule.html#day-03-wednesday",
    "title": "Course Schedule",
    "section": "Day 03 – Wednesday",
    "text": "Day 03 – Wednesday\n\n\n\n\n\n\n\nTime\nSection\n\n\n\n\n08:30 am - 10:00 am\ncontent\n\n\n10:00 am - 10:15 am\nCoffee break\n\n\n10:30 am - 12:00 pm\ncontent",
    "crumbs": [
      "Course Schedule"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#learning-goals",
    "href": "modules/ModuleXX-Iteration.html#learning-goals",
    "title": "Iteration in R",
    "section": "Learning goals",
    "text": "Learning goals\n\nReplace repetitive code with a for loop\nCompare and contrast for loops and *apply() functions\nUse vectorization to replace unnecessary loops",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "Welcome to “Introduction to R”!\nThis website contains all of the slides and exercises for the 2024 Summer Institute in Modeling for Infectious Diseases (SISMID) Module “Introduction to R”.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#prerequisities",
    "href": "index.html#prerequisities",
    "title": "Welcome",
    "section": "Prerequisities",
    "text": "Prerequisities\nFamiliary with basic statistical concepts on the level of an introductory statistics class is assumed for our course\nBefore the course begins, you should install R and RStudio on your laptop. If you are using an older version of R, you should update it before the course begins. You will need at least R version 4.3.0 for this course, but using the most recent version (4.4.1 at the time of writing) is always preferable.\n\nYou can install R from the CRAN website by clicking on the correct download link for your OS.\nYou can install RStudio from the Posit website.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#about-the-instructors",
    "href": "index.html#about-the-instructors",
    "title": "Welcome",
    "section": "About the instructors",
    "text": "About the instructors\n\n\n\nInstructor: Dr. Amy Winter\n\n\nDr. Winter is an Assistant Professor of Epidemiology at the University of Georgia. She has been coding in R for 10 years, and uses R day-to-day to conduct her research addressing policy-relevant questions on the transmission and control of infectious diseases in human populations, particularly VPDs. She teaches a semester-long course titled Introduction to Coding in R for Public Health to graduate students at the University of Georgia.\n\n\n\nTA: Zane Billings\n\n\nZane Billings is a PhD student in Epidemiology and Biostatistics at the University of Georgia, working with Andreas Handel. He has been using R since 2017, and uses R for nearly all of his statistics and data science practice. Zane’s research focuses on the immune response to influenza vaccination, and uses machine learning and multilevel regression modeling (in R!) to improve our understanding of influenza immunology.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "modules/Module01-Intro.html",
    "href": "modules/Module01-Intro.html",
    "title": "Intro to Modeling",
    "section": "",
    "text": "ReuseCC BY-NC 4.0",
    "crumbs": [
      "Day 1",
      "Intro to Modeling"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\nReferences\n\n\nMatloff, Norman. 2011. The Art of R Programming. San Francisco, CA: No Starch Press.\n\n\nWickham, Hadley, Mine Çetinkaya-Rundel, and Garrett Grolemund. 2023. R for Data Science. 2nd ed. Sebastopol, CA: O’Reilly Media.\n\n\n\n\n\n\n\n\nReuseCC BY-NC 4.0",
    "crumbs": [
      "More References"
    ]
  },
  {
    "objectID": "exercises/CaseStudy01.html#learning-goals",
    "href": "exercises/CaseStudy01.html#learning-goals",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Learning goals",
    "text": "Learning goals\n\nUse logical operators, subsetting functions, and math calculations in R\nTranslate human-understandable problem descriptions into instructions that R can understand."
  },
  {
    "objectID": "exercises/CaseStudy01.html#instructions",
    "href": "exercises/CaseStudy01.html#instructions",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Instructions",
    "text": "Instructions\n\nMake a new R script for this case study, and save it to your code folder.\nWe’ll use the diphtheria serosample data from Exercise 1 for this case study. Load it into R and use the functions we’ve learned to look at it."
  },
  {
    "objectID": "exercises/CaseStudy01.html#instructions-1",
    "href": "exercises/CaseStudy01.html#instructions-1",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Instructions",
    "text": "Instructions\n\nMake a new R script for this case study, and save it to your code folder.\nWe’ll use the diphtheria serosample data from Exercise 1 for this case study. Load it into R and use the functions we’ve learned to look at it.\nThe str() of your dataset should look like this.\n\n\n\ntibble [250 × 5] (S3: tbl_df/tbl/data.frame)\n $ age_months  : num [1:250] 15 44 103 88 88 118 85 19 78 112 ...\n $ group       : chr [1:250] \"urban\" \"rural\" \"urban\" \"urban\" ...\n $ DP_antibody : num [1:250] 0.481 0.657 1.368 1.218 0.333 ...\n $ DP_infection: num [1:250] 1 1 1 1 1 1 1 1 1 1 ...\n $ DP_vacc     : num [1:250] 0 1 1 1 1 1 1 1 1 1 ..."
  },
  {
    "objectID": "modules/Module01-Intro.html#welcome-to-class",
    "href": "modules/Module01-Intro.html#welcome-to-class",
    "title": "Intro to Modeling",
    "section": "Welcome to class!",
    "text": "Welcome to class!\n\n2 + 2\n\n[1] 4",
    "crumbs": [
      "Day 1",
      "Intro to Modeling"
    ]
  },
  {
    "objectID": "exercises/CaseStudy01.html#part-1",
    "href": "exercises/CaseStudy01.html#part-1",
    "title": "Case Study 1",
    "section": "Part 1",
    "text": "Part 1\n\n\n\nWas the overall prevalence higher in urban or rural areas?"
  },
  {
    "objectID": "exercises/CaseStudy01.html#what-is",
    "href": "exercises/CaseStudy01.html#what-is",
    "title": "Case Study 1",
    "section": "What is",
    "text": "What is\nWhat is"
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-was-the-overall-prevalence-higher-in-urban-or-rural-areas",
    "href": "exercises/CaseStudy01.html#q1-was-the-overall-prevalence-higher-in-urban-or-rural-areas",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: Was the overall prevalence higher in urban or rural areas?",
    "text": "Q1: Was the overall prevalence higher in urban or rural areas?\n\n\nHow do we calculate the prevalence from the data?\nHow do we calculate the prevalence separately for urban and rural areas?\nHow do we determine which prevalence is higher and if the difference is meaningful?"
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-how-do-we-calculate-the-prevalence-from-the-data",
    "href": "exercises/CaseStudy01.html#q1-how-do-we-calculate-the-prevalence-from-the-data",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: How do we calculate the prevalence from the data?",
    "text": "Q1: How do we calculate the prevalence from the data?\n\n\nThe variable DP_infection in our dataset is binary / dichotomous.\nThe prevalence is the number or percent of people who had the disease over some duration.\nThe average of a binary variable gives the prevalence!\n\n\n\n\nmean(diph$DP_infection)\n\n[1] 0.8"
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-how-do-we-calculate-the-prevalence-separately-for-urban-and-rural-areas",
    "href": "exercises/CaseStudy01.html#q1-how-do-we-calculate-the-prevalence-separately-for-urban-and-rural-areas",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: How do we calculate the prevalence separately for urban and rural areas?",
    "text": "Q1: How do we calculate the prevalence separately for urban and rural areas?\n\n\nmean(diph[diph$group == \"urban\", ]$DP_infection)\n\n[1] 0.8235294\n\nmean(diph[diph$group == \"rural\", ]$DP_infection)\n\n[1] 0.778626\n\n\n\n\n\nThere are many ways you could write this code! You can use subset() or you can write the indices many ways.\nUsing tbl_df objects from haven uses different [[ rules than a base R data frame."
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is",
    "href": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is",
    "title": "Case Study 1",
    "section": "Q1: How do we determine which prevalence is higher and if the difference is",
    "text": "Q1: How do we determine which prevalence is higher and if the difference is\nmeaningful?\n\n\nWe probably need to include a confidence interval in our calculation.\nThis is actually not so easy without more advanced tools that we will learn in upcoming modules.\nRight now the best options are to do it by hand or google a function."
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-1",
    "href": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-1",
    "title": "Case Study 1",
    "section": "Q1: How do we determine which prevalence is higher and if the difference is",
    "text": "Q1: How do we determine which prevalence is higher and if the difference is\nmeaningful? (By hand)\n\n\nUrban: 0.82; 95% CI: (0.78, 0.87)\nRural: 0.78; 95% CI: (0.73, 0.83)\n\n\n\nWe can see that the 95% CI’s overlap, so the groups are probably not that different. To be sure, we need to do a 2-sample test! But this is not a statistics class.\nSome people will tell you that coding like this is “bad”. But ‘bad’ code that gives you answers is better than broken code!\nWe will learn techniques for writing this with less work and less repetition in upcoming modules."
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-2",
    "href": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-2",
    "title": "Case Study 1",
    "section": "Q1: How do we determine which prevalence is higher and if the difference is",
    "text": "Q1: How do we determine which prevalence is higher and if the difference is\nmeaningful? (Google a package)\n\n\n  group DP_infection.mean DP_infection.lwr.ci DP_infection.upr.ci\n1 rural         0.7786260           0.7065872           0.8506647\n2 urban         0.8235294           0.7540334           0.8930254\n\n\n\nNotice that the results are slightly different from what we did manually! One advantage of writing your own code is that you know exactly what it does!\nFiguring out the details of how that function works might take a lot of time."
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-meaningful",
    "href": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-meaningful",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: How do we determine which prevalence is higher and if the difference is meaningful?",
    "text": "Q1: How do we determine which prevalence is higher and if the difference is meaningful?\n\n\nWe probably need to include a confidence interval in our calculation.\nThis is actually not so easy without more advanced tools that we will learn in upcoming modules.\nRight now the best options are to do it by hand or google a function."
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-meaningful-by-hand",
    "href": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-meaningful-by-hand",
    "title": "Case Study 1",
    "section": "Q1: How do we determine which prevalence is higher and if the difference is meaningful? (By hand)",
    "text": "Q1: How do we determine which prevalence is higher and if the difference is meaningful? (By hand)\n\np_urban &lt;- mean(diph[diph$group == \"urban\", ]$DP_infection)\np_rural &lt;- mean(diph[diph$group == \"rural\", ]$DP_infection)\nse_urban &lt;- sqrt(p_urban * (1 - p_urban) / nrow(diph))\nse_rural &lt;- sqrt(p_rural * (1 - p_rural) / nrow(diph))\n\nresult_urban &lt;- paste0(\n    \"Urban: \", round(p_urban, 2), \"; 95% CI: (\",\n    round(p_urban - 1.96 * se_urban, 2), \", \",\n    round(p_urban + 1.96 * se_urban, 2), \")\"\n)\n\nresult_rural &lt;- paste0(\n    \"Rural: \", round(p_rural, 2), \"; 95% CI: (\",\n    round(p_rural - 1.96 * se_rural, 2), \", \",\n    round(p_rural + 1.96 * se_rural, 2), \")\"\n)\n\ncat(result_urban, result_rural, sep = \"\\n\")\n\nUrban: 0.82; 95% CI: (0.78, 0.87)\nRural: 0.78; 95% CI: (0.73, 0.83)"
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-meaningful-google-a-package",
    "href": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-meaningful-google-a-package",
    "title": "Case Study 1",
    "section": "Q1: How do we determine which prevalence is higher and if the difference is meaningful? (Google a package)",
    "text": "Q1: How do we determine which prevalence is higher and if the difference is meaningful? (Google a package)\n\n# install.packages(\"DescTools\")\nlibrary(DescTools)\n\naggregate(DP_infection ~ group, data = diph, FUN = DescTools::MeanCI)\n\n  group DP_infection.mean DP_infection.lwr.ci DP_infection.upr.ci\n1 rural         0.7786260           0.7065872           0.8506647\n2 urban         0.8235294           0.7540334           0.8930254\n\n\n\nNotice that the results are slightly different from what we did manually! One advantage of writing your own code is that you know exactly what it does!\nFiguring out the details of how that function works might take a lot of time."
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-how-do-we-calculate-the-prevalence-separately-for-urban-and-rural-areas-1",
    "href": "exercises/CaseStudy01.html#q1-how-do-we-calculate-the-prevalence-separately-for-urban-and-rural-areas-1",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: How do we calculate the prevalence separately for urban and rural areas?",
    "text": "Q1: How do we calculate the prevalence separately for urban and rural areas?\n\nOne easy way is to use the aggregate() function.\n\n\naggregate(DP_infection ~ group, data = diph, FUN = mean)\n\n  group DP_infection\n1 rural    0.7786260\n2 urban    0.8235294"
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-meaningful-by-hand-1",
    "href": "exercises/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-meaningful-by-hand-1",
    "title": "Case Study 1",
    "section": "Q1: How do we determine which prevalence is higher and if the difference is meaningful? (By hand)",
    "text": "Q1: How do we determine which prevalence is higher and if the difference is meaningful? (By hand)\n\nWe can see that the 95% CI’s overlap, so the groups are probably not that different. To be sure, we need to do a 2-sample test! But this is not a statistics class.\nSome people will tell you that coding like this is “bad”. But ‘bad’ code that gives you answers is better than broken code! We will learn techniques for writing this with less work and less repetition in upcoming modules."
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-googling-a-package",
    "href": "exercises/CaseStudy01.html#q1-googling-a-package",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: Googling a package",
    "text": "Q1: Googling a package\n\n# install.packages(\"DescTools\")\nlibrary(DescTools)\n\naggregate(DP_infection ~ group, data = diph, FUN = DescTools::MeanCI)\n\n  group DP_infection.mean DP_infection.lwr.ci DP_infection.upr.ci\n1 rural         0.7786260           0.7065872           0.8506647\n2 urban         0.8235294           0.7540334           0.8930254"
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-by-hand",
    "href": "exercises/CaseStudy01.html#q1-by-hand",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: By hand",
    "text": "Q1: By hand\n\np_urban &lt;- mean(diph[diph$group == \"urban\", ]$DP_infection)\np_rural &lt;- mean(diph[diph$group == \"rural\", ]$DP_infection)\nse_urban &lt;- sqrt(p_urban * (1 - p_urban) / nrow(diph[diph$group == \"urban\", ]))\nse_rural &lt;- sqrt(p_rural * (1 - p_rural) / nrow(diph[diph$group == \"rural\", ])) \n\nresult_urban &lt;- paste0(\n    \"Urban: \", round(p_urban, 2), \"; 95% CI: (\",\n    round(p_urban - 1.96 * se_urban, 2), \", \",\n    round(p_urban + 1.96 * se_urban, 2), \")\"\n)\n\nresult_rural &lt;- paste0(\n    \"Rural: \", round(p_rural, 2), \"; 95% CI: (\",\n    round(p_rural - 1.96 * se_rural, 2), \", \",\n    round(p_rural + 1.96 * se_rural, 2), \")\"\n)\n\ncat(result_urban, result_rural, sep = \"\\n\")\n\nUrban: 0.82; 95% CI: (0.76, 0.89)\nRural: 0.78; 95% CI: (0.71, 0.85)"
  },
  {
    "objectID": "exercises/CaseStudy01.html#q1-by-hand-1",
    "href": "exercises/CaseStudy01.html#q1-by-hand-1",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: By hand",
    "text": "Q1: By hand\n\nWe can see that the 95% CI’s overlap, so the groups are probably not that different. To be sure, we need to do a 2-sample test! But this is not a statistics class.\nSome people will tell you that coding like this is “bad”. But ‘bad’ code that gives you answers is better than broken code! We will learn techniques for writing this with less work and less repetition in upcoming modules."
  },
  {
    "objectID": "exercises/CaseStudy01.html#congratulations-for-finishing-the-first-case-study",
    "href": "exercises/CaseStudy01.html#congratulations-for-finishing-the-first-case-study",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Congratulations for finishing the first case study!",
    "text": "Congratulations for finishing the first case study!\n\nWhat R functions and skills did you practice?\nWhat other questions could you answer about the same dataset with the skills you know now?"
  },
  {
    "objectID": "modules/CaseStudy01.html#learning-goals",
    "href": "modules/CaseStudy01.html#learning-goals",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Learning goals",
    "text": "Learning goals\n\nUse logical operators, subsetting functions, and math calculations in R\nTranslate human-understandable problem descriptions into instructions that R can understand.",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/CaseStudy01.html#instructions",
    "href": "modules/CaseStudy01.html#instructions",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Instructions",
    "text": "Instructions\n\nMake a new R script for this case study, and save it to your code folder.\nWe’ll use the diphtheria serosample data from Exercise 1 for this case study. Load it into R and use the functions we’ve learned to look at it.",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/CaseStudy01.html#instructions-1",
    "href": "modules/CaseStudy01.html#instructions-1",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Instructions",
    "text": "Instructions\n\nMake a new R script for this case study, and save it to your code folder.\nWe’ll use the diphtheria serosample data from Exercise 1 for this case study. Load it into R and use the functions we’ve learned to look at it.\nThe str() of your dataset should look like this.\n\n\n\ntibble [250 × 5] (S3: tbl_df/tbl/data.frame)\n $ age_months  : num [1:250] 15 44 103 88 88 118 85 19 78 112 ...\n $ group       : chr [1:250] \"urban\" \"rural\" \"urban\" \"urban\" ...\n $ DP_antibody : num [1:250] 0.481 0.657 1.368 1.218 0.333 ...\n $ DP_infection: num [1:250] 1 1 1 1 1 1 1 1 1 1 ...\n $ DP_vacc     : num [1:250] 0 1 1 1 1 1 1 1 1 1 ...",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/CaseStudy01.html#q1-was-the-overall-prevalence-higher-in-urban-or-rural-areas",
    "href": "modules/CaseStudy01.html#q1-was-the-overall-prevalence-higher-in-urban-or-rural-areas",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: Was the overall prevalence higher in urban or rural areas?",
    "text": "Q1: Was the overall prevalence higher in urban or rural areas?\n\n\nHow do we calculate the prevalence from the data?\nHow do we calculate the prevalence separately for urban and rural areas?\nHow do we determine which prevalence is higher and if the difference is meaningful?",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/CaseStudy01.html#q1-how-do-we-calculate-the-prevalence-from-the-data",
    "href": "modules/CaseStudy01.html#q1-how-do-we-calculate-the-prevalence-from-the-data",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: How do we calculate the prevalence from the data?",
    "text": "Q1: How do we calculate the prevalence from the data?\n\n\nThe variable DP_infection in our dataset is binary / dichotomous.\nThe prevalence is the number or percent of people who had the disease over some duration.\nThe average of a binary variable gives the prevalence!\n\n\n\n\nmean(diph$DP_infection)\n\n[1] 0.8",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/CaseStudy01.html#q1-how-do-we-calculate-the-prevalence-separately-for-urban-and-rural-areas",
    "href": "modules/CaseStudy01.html#q1-how-do-we-calculate-the-prevalence-separately-for-urban-and-rural-areas",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: How do we calculate the prevalence separately for urban and rural areas?",
    "text": "Q1: How do we calculate the prevalence separately for urban and rural areas?\n\n\nmean(diph[diph$group == \"urban\", ]$DP_infection)\n\n[1] 0.8235294\n\nmean(diph[diph$group == \"rural\", ]$DP_infection)\n\n[1] 0.778626\n\n\n\n\n\nThere are many ways you could write this code! You can use subset() or you can write the indices many ways.\nUsing tbl_df objects from haven uses different [[ rules than a base R data frame.",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/CaseStudy01.html#q1-how-do-we-calculate-the-prevalence-separately-for-urban-and-rural-areas-1",
    "href": "modules/CaseStudy01.html#q1-how-do-we-calculate-the-prevalence-separately-for-urban-and-rural-areas-1",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: How do we calculate the prevalence separately for urban and rural areas?",
    "text": "Q1: How do we calculate the prevalence separately for urban and rural areas?\n\nOne easy way is to use the aggregate() function.\n\n\naggregate(DP_infection ~ group, data = diph, FUN = mean)\n\n  group DP_infection\n1 rural    0.7786260\n2 urban    0.8235294",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-meaningful",
    "href": "modules/CaseStudy01.html#q1-how-do-we-determine-which-prevalence-is-higher-and-if-the-difference-is-meaningful",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: How do we determine which prevalence is higher and if the difference is meaningful?",
    "text": "Q1: How do we determine which prevalence is higher and if the difference is meaningful?\n\n\nWe probably need to include a confidence interval in our calculation.\nThis is actually not so easy without more advanced tools that we will learn in upcoming modules.\nRight now the best options are to do it by hand or google a function.",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/CaseStudy01.html#q1-by-hand",
    "href": "modules/CaseStudy01.html#q1-by-hand",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: By hand",
    "text": "Q1: By hand\n\np_urban &lt;- mean(diph[diph$group == \"urban\", ]$DP_infection)\np_rural &lt;- mean(diph[diph$group == \"rural\", ]$DP_infection)\nse_urban &lt;- sqrt(p_urban * (1 - p_urban) / nrow(diph[diph$group == \"urban\", ]))\nse_rural &lt;- sqrt(p_rural * (1 - p_rural) / nrow(diph[diph$group == \"rural\", ])) \n\nresult_urban &lt;- paste0(\n    \"Urban: \", round(p_urban, 2), \"; 95% CI: (\",\n    round(p_urban - 1.96 * se_urban, 2), \", \",\n    round(p_urban + 1.96 * se_urban, 2), \")\"\n)\n\nresult_rural &lt;- paste0(\n    \"Rural: \", round(p_rural, 2), \"; 95% CI: (\",\n    round(p_rural - 1.96 * se_rural, 2), \", \",\n    round(p_rural + 1.96 * se_rural, 2), \")\"\n)\n\ncat(result_urban, result_rural, sep = \"\\n\")\n\nUrban: 0.82; 95% CI: (0.76, 0.89)\nRural: 0.78; 95% CI: (0.71, 0.85)",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/CaseStudy01.html#q1-by-hand-1",
    "href": "modules/CaseStudy01.html#q1-by-hand-1",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: By hand",
    "text": "Q1: By hand\n\nWe can see that the 95% CI’s overlap, so the groups are probably not that different. To be sure, we need to do a 2-sample test! But this is not a statistics class.\nSome people will tell you that coding like this is “bad”. But ‘bad’ code that gives you answers is better than broken code! We will learn techniques for writing this with less work and less repetition in upcoming modules.",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/CaseStudy01.html#q1-googling-a-package",
    "href": "modules/CaseStudy01.html#q1-googling-a-package",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Q1: Googling a package",
    "text": "Q1: Googling a package\n\n\n# install.packages(\"DescTools\")\nlibrary(DescTools)\n\naggregate(DP_infection ~ group, data = diph, FUN = DescTools::MeanCI)\n\n  group DP_infection.mean DP_infection.lwr.ci DP_infection.upr.ci\n1 rural         0.7786260           0.7065872           0.8506647\n2 urban         0.8235294           0.7540334           0.8930254",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/CaseStudy01.html#you-try-it",
    "href": "modules/CaseStudy01.html#you-try-it",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "You try it!",
    "text": "You try it!\n\nUsing any of the approaches you can think of, answer this question!\nHow many children under 5 were vaccinated? In children under 5, did vaccination lower the prevalence of infection?",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/CaseStudy01.html#you-try-it-1",
    "href": "modules/CaseStudy01.html#you-try-it-1",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "You try it!",
    "text": "You try it!\n\n# How many children under 5 were vaccinated\nsum(diph$DP_vacc[diph$age_months &lt; 60])\n\n[1] 91\n\n# Prevalence in both vaccine groups for children under 5\naggregate(\n    DP_infection ~ DP_vacc,\n    data = subset(diph, age_months &lt; 60),\n    FUN = DescTools::MeanCI\n)\n\n  DP_vacc DP_infection.mean DP_infection.lwr.ci DP_infection.upr.ci\n1       0         0.4285714           0.1977457           0.6593972\n2       1         0.6373626           0.5366845           0.7380407\n\n\nIt appears that prevalence was HIGHER in the vaccine group? That is counterintuitive, but the sample size for the unvaccinated group is too small to be sure.",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/CaseStudy01.html#congratulations-for-finishing-the-first-case-study",
    "href": "modules/CaseStudy01.html#congratulations-for-finishing-the-first-case-study",
    "title": "Algorithmic Thinking Case Study 1",
    "section": "Congratulations for finishing the first case study!",
    "text": "Congratulations for finishing the first case study!\n\nWhat R functions and skills did you practice?\nWhat other questions could you answer about the same dataset with the skills you know now?",
    "crumbs": [
      "Day 1",
      "Algorithmic Thinking Case Study 1"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#what-is-iteration",
    "href": "modules/ModuleXX-Iteration.html#what-is-iteration",
    "title": "Iteration in R",
    "section": "What is iteration?",
    "text": "What is iteration?\n\nWhenever you repeat something, that’s iteration.\nIn R, this means running the same code multiple times in a row.\n\n\ndata(\"penguins\", package = \"palmerpenguins\")\nfor (this_island in levels(penguins$island)) {\n    island_mean &lt;-\n        penguins$bill_depth_mm[penguins$island == this_island] |&gt;\n        mean(na.rm = TRUE) |&gt;\n        round(digits = 2)\n    \n    cat(paste(\"The mean bill depth on\", this_island, \"Island was\", island_mean,\n                            \"mm.\\n\"))\n}\n\nThe mean bill depth on Biscoe Island was 15.87 mm.\nThe mean bill depth on Dream Island was 18.34 mm.\nThe mean bill depth on Torgersen Island was 18.43 mm.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#parts-of-a-loop",
    "href": "modules/ModuleXX-Iteration.html#parts-of-a-loop",
    "title": "Iteration in R",
    "section": "Parts of a loop",
    "text": "Parts of a loop\n\nfor (this_island in levels(penguins$island)) {\n    island_mean &lt;-\n        penguins$bill_depth_mm[penguins$island == this_island] |&gt;\n        mean(na.rm = TRUE) |&gt;\n        round(digits = 2)\n    \n    cat(paste(\"The mean bill depth on\", this_island, \"Island was\", island_mean,\n                            \"mm.\\n\"))\n}\n\nThe header declares how many times we will repeat the same code. The header contains a control variable that changes in each repetition and a sequence of values for the control variable to take.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#parts-of-a-loop-1",
    "href": "modules/ModuleXX-Iteration.html#parts-of-a-loop-1",
    "title": "Iteration in R",
    "section": "Parts of a loop",
    "text": "Parts of a loop\n\nfor (this_island in levels(penguins$island)) {\n    island_mean &lt;-\n        penguins$bill_depth_mm[penguins$island == this_island] |&gt;\n        mean(na.rm = TRUE) |&gt;\n        round(digits = 2)\n    \n    cat(paste(\"The mean bill depth on\", this_island, \"Island was\", island_mean,\n                            \"mm.\\n\"))\n}\n\nThe body of the loop contains code that will be repeated a number of times based on the header instructions. In R, the body has to be surrounded by curly braces.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#header-parts",
    "href": "modules/ModuleXX-Iteration.html#header-parts",
    "title": "Iteration in R",
    "section": "Header parts",
    "text": "Header parts\n\nfor (this_island in levels(penguins$island)) {...}\n\n\nfor: keyword that declares we are doing a for loop.\n(...): parentheses after for declare the control variable and sequence.\nthis_island: the control variable.\nin: keyword that separates the control varibale and sequence.\nlevels(penguins$island): the sequence.\n{}: curly braces will contain the body code.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#header-parts-1",
    "href": "modules/ModuleXX-Iteration.html#header-parts-1",
    "title": "Iteration in R",
    "section": "Header parts",
    "text": "Header parts\n\nfor (this_island in levels(penguins$island)) {...}\n\n\nSince levels(penguins$island) evaluates to c(\"Biscoe\", \"Dream\", \"Torgersen\"), our loop will repeat 3 times.\n\n\n\n\nIteration\nthis_island\n\n\n\n\n1\n“Biscoe”\n\n\n2\n“Dream”\n\n\n3\n“Torgersen”\n\n\n\n\nEverything inside of {...} will be repeated three times.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#loop-iteration-1",
    "href": "modules/ModuleXX-Iteration.html#loop-iteration-1",
    "title": "Iteration in R",
    "section": "Loop iteration 1",
    "text": "Loop iteration 1\n\nisland_mean &lt;-\n    penguins$bill_depth_mm[penguins$island == \"Biscoe\"] |&gt;\n    mean(na.rm = TRUE) |&gt;\n    round(digits = 2)\n\ncat(paste(\"The mean bill depth on\", \"Biscoe\", \"Island was\", island_mean,\n                    \"mm.\\n\"))\n\nThe mean bill depth on Biscoe Island was 15.87 mm.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#loop-iteration-2",
    "href": "modules/ModuleXX-Iteration.html#loop-iteration-2",
    "title": "Iteration in R",
    "section": "Loop iteration 2",
    "text": "Loop iteration 2\n\nisland_mean &lt;-\n    penguins$bill_depth_mm[penguins$island == \"Dream\"] |&gt;\n    mean(na.rm = TRUE) |&gt;\n    round(digits = 2)\n\ncat(paste(\"The mean bill depth on\", \"Dream\", \"Island was\", island_mean,\n                    \"mm.\\n\"))\n\nThe mean bill depth on Dream Island was 18.34 mm.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#loop-iteration-3",
    "href": "modules/ModuleXX-Iteration.html#loop-iteration-3",
    "title": "Iteration in R",
    "section": "Loop iteration 3",
    "text": "Loop iteration 3\n\nisland_mean &lt;-\n    penguins$bill_depth_mm[penguins$island == \"Torgersen\"] |&gt;\n    mean(na.rm = TRUE) |&gt;\n    round(digits = 2)\n\ncat(paste(\"The mean bill depth on\", \"Torgersen\", \"Island was\", island_mean,\n                    \"mm.\\n\"))\n\nThe mean bill depth on Torgersen Island was 18.43 mm.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#the-loop-structure-automates-this-process-for-us-so-we-dont-have-to-copy",
    "href": "modules/ModuleXX-Iteration.html#the-loop-structure-automates-this-process-for-us-so-we-dont-have-to-copy",
    "title": "Iteration in R",
    "section": "The loop structure automates this process for us so we don’t have to copy",
    "text": "The loop structure automates this process for us so we don’t have to copy\nand paste our code!\n\nfor (this_island in levels(penguins$island)) {\n    island_mean &lt;-\n        penguins$bill_depth_mm[penguins$island == this_island] |&gt;\n        mean(na.rm = TRUE) |&gt;\n        round(digits = 2)\n    \n    cat(paste(\"The mean bill depth on\", this_island, \"Island was\", island_mean,\n                            \"mm.\\n\"))\n}\n\nThe mean bill depth on Biscoe Island was 15.87 mm.\nThe mean bill depth on Dream Island was 18.34 mm.\nThe mean bill depth on Torgersen Island was 18.43 mm.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#the-loop-structure-automates-this-process-for-us-so-we-dont-have-to-copy-and-paste-our-code",
    "href": "modules/ModuleXX-Iteration.html#the-loop-structure-automates-this-process-for-us-so-we-dont-have-to-copy-and-paste-our-code",
    "title": "Iteration in R",
    "section": "The loop structure automates this process for us so we don’t have to copy and paste our code!",
    "text": "The loop structure automates this process for us so we don’t have to copy and paste our code!\n\nfor (this_island in levels(penguins$island)) {\n    island_mean &lt;-\n        penguins$bill_depth_mm[penguins$island == this_island] |&gt;\n        mean(na.rm = TRUE) |&gt;\n        round(digits = 2)\n    \n    cat(paste(\"The mean bill depth on\", this_island, \"Island was\", island_mean,\n                            \"mm.\\n\"))\n}\n\nThe mean bill depth on Biscoe Island was 15.87 mm.\nThe mean bill depth on Dream Island was 18.34 mm.\nThe mean bill depth on Torgersen Island was 18.43 mm.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#remember-write-dry-code",
    "href": "modules/ModuleXX-Iteration.html#remember-write-dry-code",
    "title": "Iteration in R",
    "section": "Remember: write DRY code!",
    "text": "Remember: write DRY code!\n\nDRY = “Don’t Repeat Yourself”\nInstead of copying and pasting, write loops and functions.\nEasier to debug and change in the future!\n\n\n\nOf course, we all copy and paste code sometimes. If you are running on a tight deadline or can’t get a loop or function to work, you might need to. DRY code is good, but working code is best!",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#tweet-slide",
    "href": "modules/ModuleXX-Iteration.html#tweet-slide",
    "title": "Iteration in R",
    "section": "",
    "text": "quart",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#you-try-it",
    "href": "modules/ModuleXX-Iteration.html#you-try-it",
    "title": "Iteration in R",
    "section": "You try it!",
    "text": "You try it!\nWrite a loop that goes from 1 to 10, squares each of the numbers, and prints the squared number.\n\n\nfor (i in 1:10) {\n    cat(i ^ 2, \"\\n\")\n}\n\n1 \n4 \n9 \n16 \n25 \n36 \n49 \n64 \n81 \n100",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#wait-did-we-need-to-do-that",
    "href": "modules/ModuleXX-Iteration.html#wait-did-we-need-to-do-that",
    "title": "Iteration in R",
    "section": "Wait, did we need to do that?",
    "text": "Wait, did we need to do that?\n\nWell, yes, because you need to practice loops!\nBut technically no, because we can use vectorization.\nAlmost all basic operations in R are vectorized: they work on a vector of arguments all at the same time.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#wait-did-we-need-to-do-that-1",
    "href": "modules/ModuleXX-Iteration.html#wait-did-we-need-to-do-that-1",
    "title": "Iteration in R",
    "section": "Wait, did we need to do that?",
    "text": "Wait, did we need to do that?\n\nWell, yes, because you need to practice loops!\nBut technically no, because we can use vectorization.\nAlmost all basic operations in R are vectorized: they work on a vector of arguments all at the same time.\n\n\n# No loop needed!\n(1:10)^2\n\n [1]   1   4   9  16  25  36  49  64  81 100",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#wait-did-we-need-to-do-that-2",
    "href": "modules/ModuleXX-Iteration.html#wait-did-we-need-to-do-that-2",
    "title": "Iteration in R",
    "section": "Wait, did we need to do that?",
    "text": "Wait, did we need to do that?\n\nWell, yes, because you need to practice loops!\nBut technically no, because we can use vectorization.\nAlmost all basic operations in R are vectorized: they work on a vector of arguments all at the same time.\n\n\n# No loop needed!\n(1:10)^2\n\n [1]   1   4   9  16  25  36  49  64  81 100\n\n\n\n# Get the first 10 odd numbers, a common CS 101 loop problem on exams\n(1:20)[which((1:20 %% 2) == 1)]\n\n [1]  1  3  5  7  9 11 13 15 17 19\n\n\n\nSo you should really try vectorization first, then use loops only when you can’t use vectorization.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#loop-walkthrough",
    "href": "modules/ModuleXX-Iteration.html#loop-walkthrough",
    "title": "Iteration in R",
    "section": "Loop walkthrough",
    "text": "Loop walkthrough\n\nLet’s walk through a complex but useful example where we can’t use vectorization.\nLoad the cleaned measles dataset, and subset it so you only have MCV1 records.\n\n\n\nmeas &lt;- readRDS(here::here(\"data\", \"measles_final.Rds\")) |&gt;\n    subset(vaccine_antigen == \"MCV1\")\nstr(meas)\n\n'data.frame':   7972 obs. of  7 variables:\n $ iso3c           : chr  \"AFG\" \"AFG\" \"AFG\" \"AFG\" ...\n $ time            : int  1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 ...\n $ country         : chr  \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" ...\n $ Cases           : int  2792 5166 2900 640 353 2012 1511 638 1154 492 ...\n $ vaccine_antigen : chr  \"MCV1\" \"MCV1\" \"MCV1\" \"MCV1\" ...\n $ vaccine_coverage: int  11 NA 8 9 14 14 14 31 34 22 ...\n $ total_pop       : chr  \"12486631\" \"11155195\" \"10088289\" \"9951449\" ...",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#loop-walkthrough-1",
    "href": "modules/ModuleXX-Iteration.html#loop-walkthrough-1",
    "title": "Iteration in R",
    "section": "Loop walkthrough",
    "text": "Loop walkthrough\n\nFirst, make an empty list. This is where we’ll store our results. Make it the same length as the number of countries in the dataset.\n\n\n\nres &lt;- vector(mode = \"list\", length = length(unique(meas$country)))\n\n\nThis is called preallocation and it can make your loops much faster.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#loop-walkthrough-2",
    "href": "modules/ModuleXX-Iteration.html#loop-walkthrough-2",
    "title": "Iteration in R",
    "section": "Loop walkthrough",
    "text": "Loop walkthrough\n\nLoop through every country in the dataset, and get the median, first and third quartiles, and range for each country. Store those summary statistics in a data frame.\nWhat should the header look like?\n\n\n\ncountries &lt;- unique(meas$country)\nfor (i in 1:length(countries)) {...}\n\n\n\n\nNote that we use the index as the control variable. When you need to do complex operations inside a loop, this is easier than the for-each construction we used earlier.",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#loop-walkthrough-3",
    "href": "modules/ModuleXX-Iteration.html#loop-walkthrough-3",
    "title": "Iteration in R",
    "section": "Loop walkthrough",
    "text": "Loop walkthrough\n\nNow write out the body of the code. First we need to subset the data, to get only the data for the current country.\n\n\n\nfor (i in 1:length(countries)) {\n    # Get the data for the current country only\n    country_data &lt;- subset(meas, country == countries[i])\n}\n\n\n\n\nNext we need to get the summary of the cases for that country.\n\n\n\n\nfor (i in 1:length(countries)) {\n    # Get the data for the current country only\n    country_data &lt;- subset(meas, country == countries[i])\n    \n    # Get the summary statistics for this country\n    country_cases &lt;- country_data$Cases\n    country_med &lt;- median(country_cases, na.rm = TRUE)\n    country_iqr &lt;- IQR(country_cases, na.rm = TRUE)\n    country_range &lt;- range(country_cases, na.rm = TRUE)\n}\n\n\n\n\nNext we save the summary statistics into a data frame.\n\n\nfor (i in 1:length(countries)) {\n    # Get the data for the current country only\n    country_data &lt;- subset(meas, country == countries[i])\n    \n    # Get the summary statistics for this country\n    country_cases &lt;- country_data$Cases\n    country_quart &lt;- quantile(\n        country_cases, na.rm = TRUE, probs = c(0.25, 0.5, 0.75)\n    )\n    country_range &lt;- range(country_cases, na.rm = TRUE)\n    \n    # Save the summary statistics into a data frame\n    country_summary &lt;- data.frame(\n        country = countries[[i]],\n        min = country_range[[1]],\n        Q1 = country_quart[[1]],\n        median = country_quart[[2]],\n        Q3 = country_quart[[3]],\n        max = country_range[[2]]\n    )\n}\n\n\n\n\nAnd finally, we save the data frame as the next element in our storage list.\n\n\nfor (i in 1:length(countries)) {\n    # Get the data for the current country only\n    country_data &lt;- subset(meas, country == countries[i])\n    \n    # Get the summary statistics for this country\n    country_cases &lt;- country_data$Cases\n    country_quart &lt;- quantile(\n        country_cases, na.rm = TRUE, probs = c(0.25, 0.5, 0.75)\n    )\n    country_range &lt;- range(country_cases, na.rm = TRUE)\n    \n    # Save the summary statistics into a data frame\n    country_summary &lt;- data.frame(\n        country = countries[[i]],\n        min = country_range[[1]],\n        Q1 = country_quart[[1]],\n        median = country_quart[[2]],\n        Q3 = country_quart[[3]],\n        max = country_range[[2]]\n    )\n    \n    # Save the results to our container\n    res[[i]] &lt;- country_summary\n}\n\nWarning in min(x): no non-missing arguments to min; returning Inf\n\n\nWarning in max(x): no non-missing arguments to max; returning -Inf\n\n\nWarning in min(x): no non-missing arguments to min; returning Inf\n\n\nWarning in max(x): no non-missing arguments to max; returning -Inf\n\n\nWarning in min(x): no non-missing arguments to min; returning Inf\n\n\nWarning in max(x): no non-missing arguments to max; returning -Inf\n\n\n\n\n\nLet’s take a look at the results.\n\n\nhead(res)\n\n[[1]]\n      country min   Q1 median   Q3   max\n1 Afghanistan 353 1154   2205 5166 31107\n\n[[2]]\n  country min  Q1 median    Q3   max\n1  Angola  29 700   3271 14474 30067\n\n[[3]]\n  country min Q1 median Q3    max\n1 Albania   0  1     12 29 136034\n\n[[4]]\n  country min Q1 median Q3 max\n1 Andorra   0  0      1  2   5\n\n[[5]]\n               country min    Q1 median   Q3  max\n1 United Arab Emirates  22 89.75    320 1128 2913\n\n[[6]]\n    country min Q1 median     Q3   max\n1 Argentina   0  0     17 4591.5 42093\n\n\n\nHow do we deal with this to get it into a nice form?\n\n\n\n\nWe can use a vectorization trick: the function do.call() seems like ancient computer science magic. And it is. But it will actually help us a lot.\n\n\nres_df &lt;- do.call(rbind, res)\nhead(res_df)\n\n\n\n\ncountry\nmin\nQ1\nmedian\nQ3\nmax\n\n\n\n\nAfghanistan\n353\n1154.00\n2205\n5166.0\n31107\n\n\nAngola\n29\n700.00\n3271\n14474.0\n30067\n\n\nAlbania\n0\n1.00\n12\n29.0\n136034\n\n\nAndorra\n0\n0.00\n1\n2.0\n5\n\n\nUnited Arab Emirates\n22\n89.75\n320\n1128.0\n2913\n\n\nArgentina\n0\n0.00\n17\n4591.5\n42093\n\n\n\n\n\n\nIt combined our data frames together! Let’s take a look at the rbind and do.call() help packages to see what happened.\n\n\n\n\n?rbind\n\nCombine R Objects by Rows or Columns\n\nDescription:\n\n     Take a sequence of vector, matrix or data-frame arguments and\n     combine by _c_olumns or _r_ows, respectively.  These are generic\n     functions with methods for other R classes.\n\nUsage:\n\n     cbind(..., deparse.level = 1)\n     rbind(..., deparse.level = 1)\n     ## S3 method for class 'data.frame'\n     rbind(..., deparse.level = 1, make.row.names = TRUE,\n           stringsAsFactors = FALSE, factor.exclude = TRUE)\n     \nArguments:\n\n     ...: (generalized) vectors or matrices.  These can be given as\n          named arguments.  Other R objects may be coerced as\n          appropriate, or S4 methods may be used: see sections\n          'Details' and 'Value'.  (For the '\"data.frame\"' method of\n          'cbind' these can be further arguments to 'data.frame' such\n          as 'stringsAsFactors'.)\n\ndeparse.level: integer controlling the construction of labels in the\n          case of non-matrix-like arguments (for the default method):\n          'deparse.level = 0' constructs no labels;\n          the default 'deparse.level = 1' typically and 'deparse.level\n          = 2' always construct labels from the argument names, see the\n          'Value' section below.\n\nmake.row.names: (only for data frame method:) logical indicating if\n          unique and valid 'row.names' should be constructed from the\n          arguments.\n\nstringsAsFactors: logical, passed to 'as.data.frame'; only has an\n          effect when the '...' arguments contain a (non-'data.frame')\n          'character'.\n\nfactor.exclude: if the data frames contain factors, the default 'TRUE'\n          ensures that 'NA' levels of factors are kept, see PR#17562\n          and the 'Data frame methods'.  In R versions up to 3.6.x,\n          'factor.exclude = NA' has been implicitly hardcoded (R &lt;=\n          3.6.0) or the default (R = 3.6.x, x &gt;= 1).\n\nDetails:\n\n     The functions 'cbind' and 'rbind' are S3 generic, with methods for\n     data frames.  The data frame method will be used if at least one\n     argument is a data frame and the rest are vectors or matrices.\n     There can be other methods; in particular, there is one for time\n     series objects.  See the section on 'Dispatch' for how the method\n     to be used is selected.  If some of the arguments are of an S4\n     class, i.e., 'isS4(.)' is true, S4 methods are sought also, and\n     the hidden 'cbind' / 'rbind' functions from package 'methods'\n     maybe called, which in turn build on 'cbind2' or 'rbind2',\n     respectively.  In that case, 'deparse.level' is obeyed, similarly\n     to the default method.\n\n     In the default method, all the vectors/matrices must be atomic\n     (see 'vector') or lists.  Expressions are not allowed.  Language\n     objects (such as formulae and calls) and pairlists will be coerced\n     to lists: other objects (such as names and external pointers) will\n     be included as elements in a list result.  Any classes the inputs\n     might have are discarded (in particular, factors are replaced by\n     their internal codes).\n\n     If there are several matrix arguments, they must all have the same\n     number of columns (or rows) and this will be the number of columns\n     (or rows) of the result.  If all the arguments are vectors, the\n     number of columns (rows) in the result is equal to the length of\n     the longest vector.  Values in shorter arguments are recycled to\n     achieve this length (with a 'warning' if they are recycled only\n     _fractionally_).\n\n     When the arguments consist of a mix of matrices and vectors the\n     number of columns (rows) of the result is determined by the number\n     of columns (rows) of the matrix arguments.  Any vectors have their\n     values recycled or subsetted to achieve this length.\n\n     For 'cbind' ('rbind'), vectors of zero length (including 'NULL')\n     are ignored unless the result would have zero rows (columns), for\n     S compatibility.  (Zero-extent matrices do not occur in S3 and are\n     not ignored in R.)\n\n     Matrices are restricted to less than 2^31 rows and columns even on\n     64-bit systems.  So input vectors have the same length\n     restriction: as from R 3.2.0 input matrices with more elements\n     (but meeting the row and column restrictions) are allowed.\n\nValue:\n\n     For the default method, a matrix combining the '...' arguments\n     column-wise or row-wise.  (Exception: if there are no inputs or\n     all the inputs are 'NULL', the value is 'NULL'.)\n\n     The type of a matrix result determined from the highest type of\n     any of the inputs in the hierarchy raw &lt; logical &lt; integer &lt;\n     double &lt; complex &lt; character &lt; list .\n\n     For 'cbind' ('rbind') the column (row) names are taken from the\n     'colnames' ('rownames') of the arguments if these are matrix-like.\n     Otherwise from the names of the arguments or where those are not\n     supplied and 'deparse.level &gt; 0', by deparsing the expressions\n     given, for 'deparse.level = 1' only if that gives a sensible name\n     (a 'symbol', see 'is.symbol').\n\n     For 'cbind' row names are taken from the first argument with\n     appropriate names: rownames for a matrix, or names for a vector of\n     length the number of rows of the result.\n\n     For 'rbind' column names are taken from the first argument with\n     appropriate names: colnames for a matrix, or names for a vector of\n     length the number of columns of the result.\n\nData frame methods:\n\n     The 'cbind' data frame method is just a wrapper for\n     'data.frame(..., check.names = FALSE)'.  This means that it will\n     split matrix columns in data frame arguments, and convert\n     character columns to factors unless 'stringsAsFactors = FALSE' is\n     specified.\n\n     The 'rbind' data frame method first drops all zero-column and\n     zero-row arguments.  (If that leaves none, it returns the first\n     argument with columns otherwise a zero-column zero-row data\n     frame.)  It then takes the classes of the columns from the first\n     data frame, and matches columns by name (rather than by position).\n     Factors have their levels expanded as necessary (in the order of\n     the levels of the level sets of the factors encountered) and the\n     result is an ordered factor if and only if all the components were\n     ordered factors.  Old-style categories (integer vectors with\n     levels) are promoted to factors.\n\n     Note that for result column 'j', 'factor(., exclude = X(j))' is\n     applied, where\n\n       X(j) := if(isTRUE(factor.exclude)) {\n                  if(!NA.lev[j]) NA # else NULL\n               } else factor.exclude\n     \n     where 'NA.lev[j]' is true iff any contributing data frame has had\n     a 'factor' in column 'j' with an explicit 'NA' level.\n\nDispatch:\n\n     The method dispatching is _not_ done via 'UseMethod()', but by\n     C-internal dispatching.  Therefore there is no need for, e.g.,\n     'rbind.default'.\n\n     The dispatch algorithm is described in the source file\n     ('.../src/main/bind.c') as\n\n       1. For each argument we get the list of possible class\n          memberships from the class attribute.\n\n       2. We inspect each class in turn to see if there is an\n          applicable method.\n\n       3. If we find a method, we use it.  Otherwise, if there was an\n          S4 object among the arguments, we try S4 dispatch; otherwise,\n          we use the default code.\n\n     If you want to combine other objects with data frames, it may be\n     necessary to coerce them to data frames first.  (Note that this\n     algorithm can result in calling the data frame method if all the\n     arguments are either data frames or vectors, and this will result\n     in the coercion of character vectors to factors.)\n\nReferences:\n\n     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S\n     Language_.  Wadsworth & Brooks/Cole.\n\nSee Also:\n\n     'c' to combine vectors (and lists) as vectors, 'data.frame' to\n     combine vectors and matrices as a data frame.\n\nExamples:\n\n     m &lt;- cbind(1, 1:7) # the '1' (= shorter vector) is recycled\n     m\n     m &lt;- cbind(m, 8:14)[, c(1, 3, 2)] # insert a column\n     m\n     cbind(1:7, diag(3)) # vector is subset -&gt; warning\n     \n     cbind(0, rbind(1, 1:3))\n     cbind(I = 0, X = rbind(a = 1, b = 1:3))  # use some names\n     xx &lt;- data.frame(I = rep(0,2))\n     cbind(xx, X = rbind(a = 1, b = 1:3))   # named differently\n     \n     cbind(0, matrix(1, nrow = 0, ncol = 4)) #&gt; Warning (making sense)\n     dim(cbind(0, matrix(1, nrow = 2, ncol = 0))) #-&gt; 2 x 1\n     \n     ## deparse.level\n     dd &lt;- 10\n     rbind(1:4, c = 2, \"a++\" = 10, dd, deparse.level = 0) # middle 2 rownames\n     rbind(1:4, c = 2, \"a++\" = 10, dd, deparse.level = 1) # 3 rownames (default)\n     rbind(1:4, c = 2, \"a++\" = 10, dd, deparse.level = 2) # 4 rownames\n     \n     ## cheap row names:\n     b0 &lt;- gl(3,4, labels=letters[1:3])\n     bf &lt;- setNames(b0, paste0(\"o\", seq_along(b0)))\n     df  &lt;- data.frame(a = 1, B = b0, f = gl(4,3))\n     df. &lt;- data.frame(a = 1, B = bf, f = gl(4,3))\n     new &lt;- data.frame(a = 8, B =\"B\", f = \"1\")\n     (df1  &lt;- rbind(df , new))\n     (df.1 &lt;- rbind(df., new))\n     stopifnot(identical(df1, rbind(df,  new, make.row.names=FALSE)),\n               identical(df1, rbind(df., new, make.row.names=FALSE)))\n\n\n\n\n\n?do.call\n\nExecute a Function Call\n\nDescription:\n\n     'do.call' constructs and executes a function call from a name or a\n     function and a list of arguments to be passed to it.\n\nUsage:\n\n     do.call(what, args, quote = FALSE, envir = parent.frame())\n     \nArguments:\n\n    what: either a function or a non-empty character string naming the\n          function to be called.\n\n    args: a _list_ of arguments to the function call.  The 'names'\n          attribute of 'args' gives the argument names.\n\n   quote: a logical value indicating whether to quote the arguments.\n\n   envir: an environment within which to evaluate the call.  This will\n          be most useful if 'what' is a character string and the\n          arguments are symbols or quoted expressions.\n\nDetails:\n\n     If 'quote' is 'FALSE', the default, then the arguments are\n     evaluated (in the calling environment, not in 'envir').  If\n     'quote' is 'TRUE' then each argument is quoted (see 'quote') so\n     that the effect of argument evaluation is to remove the quotes -\n     leaving the original arguments unevaluated when the call is\n     constructed.\n\n     The behavior of some functions, such as 'substitute', will not be\n     the same for functions evaluated using 'do.call' as if they were\n     evaluated from the interpreter.  The precise semantics are\n     currently undefined and subject to change.\n\nValue:\n\n     The result of the (evaluated) function call.\n\nWarning:\n\n     This should not be used to attempt to evade restrictions on the\n     use of '.Internal' and other non-API calls.\n\nReferences:\n\n     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S\n     Language_.  Wadsworth & Brooks/Cole.\n\nSee Also:\n\n     'call' which creates an unevaluated call.\n\nExamples:\n\n     do.call(\"complex\", list(imaginary = 1:3))\n     \n     ## if we already have a list (e.g., a data frame)\n     ## we need c() to add further arguments\n     tmp &lt;- expand.grid(letters[1:2], 1:3, c(\"+\", \"-\"))\n     do.call(\"paste\", c(tmp, sep = \"\"))\n     \n     do.call(paste, list(as.name(\"A\"), as.name(\"B\")), quote = TRUE)\n     \n     ## examples of where objects will be found.\n     A &lt;- 2\n     f &lt;- function(x) print(x^2)\n     env &lt;- new.env()\n     assign(\"A\", 10, envir = env)\n     assign(\"f\", f, envir = env)\n     f &lt;- function(x) print(x)\n     f(A)                                      # 2\n     do.call(\"f\", list(A))                     # 2\n     do.call(\"f\", list(A), envir = env)        # 4\n     do.call( f,  list(A), envir = env)        # 2\n     do.call(\"f\", list(quote(A)), envir = env) # 100\n     do.call( f,  list(quote(A)), envir = env) # 10\n     do.call(\"f\", list(as.name(\"A\")), envir = env) # 100\n     \n     eval(call(\"f\", A))                      # 2\n     eval(call(\"f\", quote(A)))               # 2\n     eval(call(\"f\", A), envir = env)         # 4\n     eval(call(\"f\", quote(A)), envir = env)  # 100\n\n\n\n\n\nOK, so basically what happened is that\n\n\ndo.call(rbind, list)\n\n\nGets transformed into\n\n\nrbind(list[[1]], list[[2]], list[[3]], ..., list[[length(list)]])\n\n\nThat’s vectorization magic!",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#you-try-it-if-we-have-time",
    "href": "modules/ModuleXX-Iteration.html#you-try-it-if-we-have-time",
    "title": "Iteration in R",
    "section": "You try it! (if we have time)",
    "text": "You try it! (if we have time)\n\nUse the code you wrote before the get the incidence per 1000 people on the entire measles data set (add a column for incidence to the full data).\nUse the code plot(NULL, NULL, ...) to make a blank plot. You will need to set the xlim and ylim arguments to sensible values, and specify the axis titles as “Year” and “Incidence per 1000 people”.\nUsing a for loop and the lines() function, make a plot that shows all of the incidence curves over time, overlapping on the plot.\nHINT: use col = adjustcolor(black, alpha.f = 0.25) to make the curves transparent, so you can see the others.\nBONUS PROBLEM: using the function cumsum(), make a plot of the cumulative incidence per 1000 people over time for all of the countries. (Dealing with the NA’s here is tricky!!)",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#main-problem-solution",
    "href": "modules/ModuleXX-Iteration.html#main-problem-solution",
    "title": "Iteration in R",
    "section": "Main problem solution",
    "text": "Main problem solution\n\nmeas$cases_per_thousand &lt;- meas$Cases / as.numeric(meas$total_pop) * 1000\ncountries &lt;- unique(meas$country)\n\nplot(\n    NULL, NULL,\n    xlim = c(1980, 2022),\n    ylim = c(0, 50),\n    xlab = \"Year\",\n    ylab = \"Incidence per 1000 people\"\n)\n\nfor (i in 1:length(countries)) {\n    country_data &lt;- subset(meas, country == countries[[i]])\n    lines(\n        x = country_data$time,\n        y = country_data$cases_per_thousand,\n        col = adjustcolor(\"black\", alpha.f = 0.25)\n    )\n}",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#bonus-problem-solution",
    "href": "modules/ModuleXX-Iteration.html#bonus-problem-solution",
    "title": "Iteration in R",
    "section": "Bonus problem solution",
    "text": "Bonus problem solution\n\n# First calculate the cumulative cases, treating NA as zeroes\ncumulative_cases &lt;- ave(\n    x = ifelse(is.na(meas$Cases), 0, meas$Cases),\n    meas$country,\n    FUN = cumsum\n)\n\n# Now put the NAs back where they should be\nmeas$cumulative_cases &lt;- cumulative_cases + (meas$Cases * 0)\n\nplot(\n    NULL, NULL,\n    xlim = c(1980, 2022),\n    ylim = c(1, 6.2e6),\n    xlab = \"Year\",\n    ylab = \"Cumulative cases per 1000 people\"\n)\n\nfor (i in 1:length(countries)) {\n    country_data &lt;- subset(meas, country == countries[[i]])\n    lines(\n        x = country_data$time,\n        y = country_data$cumulative_cases,\n        col = adjustcolor(\"black\", alpha.f = 0.25)\n    )\n}\n\ntext(\n    x = 2020,\n    y = 6e6,\n    labels = \"China →\"\n)",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#main-problem-solution-1",
    "href": "modules/ModuleXX-Iteration.html#main-problem-solution-1",
    "title": "Iteration in R",
    "section": "Main problem solution",
    "text": "Main problem solution",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#bonus-problem-solution-1",
    "href": "modules/ModuleXX-Iteration.html#bonus-problem-solution-1",
    "title": "Iteration in R",
    "section": "Bonus problem solution",
    "text": "Bonus problem solution",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/ModuleXX-Iteration.html#more-practice-on-your-own",
    "href": "modules/ModuleXX-Iteration.html#more-practice-on-your-own",
    "title": "Iteration in R",
    "section": "More practice on your own",
    "text": "More practice on your own\n\nMerge the countries-regions.csv data with the measles_final.Rds data. Reshape the measles data so that MCV1 and MCV2 vaccine coverage are two separate columns. Then use a loop to fit a poisson regression model for each continent where Cases is the outcome, and MCV1 coverage and MCV2 coverage are the predictors. Discuss your findings, and try adding an interation term.\nAssess the impact of age_months as a confounder in the Diphtheria serology data. First, write code to transform age_months into age ranges for each year. Then, using a loop, calculate the crude odds ratio for the effect of vaccination on infection for each of the age ranges. How does the odds ratio change as age increases? Can you formalize this analysis by fitting a logistic regression model with age_months and vaccination as predictors?",
    "crumbs": [
      "Day 2",
      "Iteration in R"
    ]
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#learning-objectives",
    "href": "modules/Module07-VarCreationClassesSummaries.html#learning-objectives",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nAfter module 7, you should be able to…\n\nCreate new variables\nCharacterize variable classes\nManipulate the classes of variables\nConduct 1 variable data summaries"
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#import-data-for-this-module",
    "href": "modules/Module07-VarCreationClassesSummaries.html#import-data-for-this-module",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "Import data for this module",
    "text": "Import data for this module\nLet’s first read in the data from the previous module and look at it briefly with a new function head().\n\ndf &lt;- read.csv(file = \"data/serodata.csv\") #relative path\nhead(x=df, n=3)\n\n  observation_id IgG_concentration age gender     slum\n1           5772         0.3176895   2 Female Non slum\n2           8095         3.4368231   4 Female Non slum\n3           9784         0.3000000   4   Male Non slum\n\n\nRegistered S3 method overwritten by 'printr':\n  method                from     \n  knit_print.data.frame rmarkdown\nReturn the First or Last Parts of an Object\nDescription:\n Returns the first or last parts of a vector, matrix, table, data\n frame or function.  Since 'head()' and 'tail()' are generic\n functions, they may also have been extended to other classes.\nUsage:\n head(x, ...)\n ## Default S3 method:\n head(x, n = 6L, ...)\n \n ## S3 method for class 'matrix'\n head(x, n = 6L, ...) # is exported as head.matrix()\n ## NB: The methods for 'data.frame' and 'array'  are identical to the 'matrix' one\n \n ## S3 method for class 'ftable'\n head(x, n = 6L, ...)\n ## S3 method for class 'function'\n head(x, n = 6L, ...)\n \n \n tail(x, ...)\n ## Default S3 method:\n tail(x, n = 6L, keepnums = FALSE, addrownums, ...)\n ## S3 method for class 'matrix'\n tail(x, n = 6L, keepnums = TRUE, addrownums, ...) # exported as tail.matrix()\n ## NB: The methods for 'data.frame', 'array', and 'table'\n ##     are identical to the  'matrix'  one\n \n ## S3 method for class 'ftable'\n tail(x, n = 6L, keepnums = FALSE, addrownums, ...)\n ## S3 method for class 'function'\n tail(x, n = 6L, ...)\n \nArguments:\n   x: an object\n\n   n: an integer vector of length up to 'dim(x)' (or 1, for\n      non-dimensioned objects).  A 'logical' is silently coerced to\n      integer.  Values specify the indices to be selected in the\n      corresponding dimension (or along the length) of the object.\n      A positive value of 'n[i]' includes the first/last 'n[i]'\n      indices in that dimension, while a negative value excludes\n      the last/first 'abs(n[i])', including all remaining indices.\n      'NA' or non-specified values (when 'length(n) &lt;\n      length(dim(x))') select all indices in that dimension. Must\n      contain at least one non-missing value.\nkeepnums: in each dimension, if no names in that dimension are present, create them using the indices included in that dimension. Ignored if ‘dim(x)’ is ‘NULL’ or its length 1.\naddrownums: deprecated - ‘keepnums’ should be used instead. Taken as the value of ‘keepnums’ if it is explicitly set when ‘keepnums’ is not.\n ...: arguments to be passed to or from other methods.\nDetails:\n For vector/array based objects, 'head()' ('tail()') returns a\n subset of the same dimensionality as 'x', usually of the same\n class. For historical reasons, by default they select the first\n (last) 6 indices in the first dimension (\"rows\") or along the\n length of a non-dimensioned vector, and the full extent (all\n indices) in any remaining dimensions. 'head.matrix()' and\n 'tail.matrix()' are exported.\n\n The default and array(/matrix) methods for 'head()' and 'tail()'\n are quite general. They will work as is for any class which has a\n 'dim()' method, a 'length()' method (only required if 'dim()'\n returns 'NULL'), and a '[' method (that accepts the 'drop'\n argument and can subset in all dimensions in the dimensioned\n case).\n\n For functions, the lines of the deparsed function are returned as\n character strings.\n\n When 'x' is an array(/matrix) of dimensionality two and more,\n 'tail()' will add dimnames similar to how they would appear in a\n full printing of 'x' for all dimensions 'k' where 'n[k]' is\n specified and non-missing and 'dimnames(x)[[k]]' (or 'dimnames(x)'\n itself) is 'NULL'.  Specifically, the form of the added dimnames\n will vary for different dimensions as follows:\n\n 'k=1' (rows): '\"[n,]\"' (right justified with whitespace padding)\n\n 'k=2' (columns): '\"[,n]\"' (with _no_ whitespace padding)\n\n 'k&gt;2' (higher dims): '\"n\"', i.e., the indices as _character_\n      values\n\n Setting 'keepnums = FALSE' suppresses this behaviour.\n\n As 'data.frame' subsetting ('indexing') keeps 'attributes', so do\n the 'head()' and 'tail()' methods for data frames.\nValue:\n An object (usually) like 'x' but generally smaller.  Hence, for\n 'array's, the result corresponds to 'x[.., drop=FALSE]'.  For\n 'ftable' objects 'x', a transformed 'format(x)'.\nNote:\n For array inputs the output of 'tail' when 'keepnums' is 'TRUE',\n any dimnames vectors added for dimensions '&gt;2' are the original\n numeric indices in that dimension _as character vectors_.  This\n means that, e.g., for 3-dimensional array 'arr', 'tail(arr,\n c(2,2,-1))[ , , 2]' and 'tail(arr, c(2,2,-1))[ , , \"2\"]' may both\n be valid but have completely different meanings.\nAuthor(s):\n Patrick Burns, improved and corrected by R-Core. Negative argument\n added by Vincent Goulet.  Multi-dimension support added by Gabriel\n Becker.\nExamples:\n head(letters)\n head(letters, n = -6L)\n \n head(freeny.x, n = 10L)\n head(freeny.y)\n \n head(iris3)\n head(iris3, c(6L, 2L))\n head(iris3, c(6L, -1L, 2L))\n \n tail(letters)\n tail(letters, n = -6L)\n \n tail(freeny.x)\n ## the bottom-right \"corner\" :\n tail(freeny.x, n = c(4, 2))\n tail(freeny.y)\n \n tail(iris3)\n tail(iris3, c(6L, 2L))\n tail(iris3, c(6L, -1L, 2L))\n \n ## iris with dimnames stripped\n a3d &lt;- iris3 ; dimnames(a3d) &lt;- NULL\n tail(a3d, c(6, -1, 2)) # keepnums = TRUE is default here!\n tail(a3d, c(6, -1, 2), keepnums = FALSE)\n \n ## data frame w/ a (non-standard) attribute:\n treeS &lt;- structure(trees, foo = \"bar\")\n (n &lt;- nrow(treeS))\n stopifnot(exprs = { # attribute is kept\n     identical(htS &lt;- head(treeS), treeS[1:6, ])\n     identical(attr(htS, \"foo\") , \"bar\")\n     identical(tlS &lt;- tail(treeS), treeS[(n-5):n, ])\n     ## BUT if I use \"useAttrib(.)\", this is *not* ok, when n is of length 2:\n     ## --- because [i,j]-indexing of data frames *also* drops \"other\" attributes ..\n     identical(tail(treeS, 3:2), treeS[(n-2):n, 2:3] )\n })\n \n tail(library) # last lines of function\n \n head(stats::ftable(Titanic))\n \n ## 1d-array (with named dim) :\n a1 &lt;- array(1:7, 7); names(dim(a1)) &lt;- \"O2\"\n stopifnot(exprs = {\n   identical( tail(a1, 10), a1)\n   identical( head(a1, 10), a1)\n   identical( head(a1, 1), a1 [1 , drop=FALSE] ) # was a1[1] in R &lt;= 3.6.x\n   identical( tail(a1, 2), a1[6:7])\n   identical( tail(a1, 1), a1 [7 , drop=FALSE] ) # was a1[7] in R &lt;= 3.6.x\n })"
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#adding-new-columns",
    "href": "modules/Module07-VarCreationClassesSummaries.html#adding-new-columns",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "Adding new columns",
    "text": "Adding new columns\nYou can add a new column, called newcol to df, using the $ operator:\n\ndf$log_IgG &lt;- log(df$IgG_concentration)\nhead(df,3)\n\n\n\n\nobservation_id\nIgG_concentration\nage\ngender\nslum\nlog_IgG\n\n\n\n\n5772\n0.3176895\n2\nFemale\nNon slum\n-1.146681\n\n\n8095\n3.4368231\n4\nFemale\nNon slum\n1.234547\n\n\n9784\n0.3000000\n4\nMale\nNon slum\n-1.203973"
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#creating-conditional-variables",
    "href": "modules/Module07-VarCreationClassesSummaries.html#creating-conditional-variables",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "Creating conditional variables",
    "text": "Creating conditional variables\nOne frequently-used tool is creating variables with conditions. A general function for creating new variables based on existing variables is the Base R ifelse() function, which “returns a value depending on whether the element of test is TRUE or FALSE.”\nConditional Element Selection\nDescription:\n 'ifelse' returns a value with the same shape as 'test' which is\n filled with elements selected from either 'yes' or 'no' depending\n on whether the element of 'test' is 'TRUE' or 'FALSE'.\nUsage:\n ifelse(test, yes, no)\n \nArguments:\ntest: an object which can be coerced to logical mode.\n\n yes: return values for true elements of 'test'.\n\n  no: return values for false elements of 'test'.\nDetails:\n If 'yes' or 'no' are too short, their elements are recycled.\n 'yes' will be evaluated if and only if any element of 'test' is\n true, and analogously for 'no'.\n\n Missing values in 'test' give missing values in the result.\nValue:\n A vector of the same length and attributes (including dimensions\n and '\"class\"') as 'test' and data values from the values of 'yes'\n or 'no'.  The mode of the answer will be coerced from logical to\n accommodate first any values taken from 'yes' and then any values\n taken from 'no'.\nWarning:\n The mode of the result may depend on the value of 'test' (see the\n examples), and the class attribute (see 'oldClass') of the result\n is taken from 'test' and may be inappropriate for the values\n selected from 'yes' and 'no'.\n\n Sometimes it is better to use a construction such as\n\n   (tmp &lt;- yes; tmp[!test] &lt;- no[!test]; tmp)\n \n , possibly extended to handle missing values in 'test'.\n\n Further note that 'if(test) yes else no' is much more efficient\n and often much preferable to 'ifelse(test, yes, no)' whenever\n 'test' is a simple true/false result, i.e., when 'length(test) ==\n 1'.\n\n The 'srcref' attribute of functions is handled specially: if\n 'test' is a simple true result and 'yes' evaluates to a function\n with 'srcref' attribute, 'ifelse' returns 'yes' including its\n attribute (the same applies to a false 'test' and 'no' argument).\n This functionality is only for backwards compatibility, the form\n 'if(test) yes else no' should be used whenever 'yes' and 'no' are\n functions.\nReferences:\n Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S\n Language_.  Wadsworth & Brooks/Cole.\nSee Also:\n 'if'.\nExamples:\n x &lt;- c(6:-4)\n sqrt(x)  #- gives warning\n sqrt(ifelse(x &gt;= 0, x, NA))  # no warning\n \n ## Note: the following also gives the warning !\n ifelse(x &gt;= 0, sqrt(x), NA)\n \n \n ## ifelse() strips attributes\n ## This is important when working with Dates and factors\n x &lt;- seq(as.Date(\"2000-02-29\"), as.Date(\"2004-10-04\"), by = \"1 month\")\n ## has many \"yyyy-mm-29\", but a few \"yyyy-03-01\" in the non-leap years\n y &lt;- ifelse(as.POSIXlt(x)$mday == 29, x, NA)\n head(y) # not what you expected ... ==&gt; need restore the class attribute:\n class(y) &lt;- class(x)\n y\n ## This is a (not atypical) case where it is better *not* to use ifelse(),\n ## but rather the more efficient and still clear:\n y2 &lt;- x\n y2[as.POSIXlt(x)$mday != 29] &lt;- NA\n ## which gives the same as ifelse()+class() hack:\n stopifnot(identical(y2, y))\n \n \n ## example of different return modes (and 'test' alone determining length):\n yes &lt;- 1:3\n no  &lt;- pi^(1:4)\n utils::str( ifelse(NA,    yes, no) ) # logical, length 1\n utils::str( ifelse(TRUE,  yes, no) ) # integer, length 1\n utils::str( ifelse(FALSE, yes, no) ) # double,  length 1"
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#ifelse-example",
    "href": "modules/Module07-VarCreationClassesSummaries.html#ifelse-example",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "ifelse example",
    "text": "ifelse example\nReminder of the first three arguments in the ifelse() function are ifelse(test, yes, no).\n\ndf$age_group &lt;- ifelse(df$age &lt;= 5, \"young\", \"old\")\nhead(df)\n\n\n\n\n\n\n\n\n\n\n\n\n\nobservation_id\nIgG_concentration\nage\ngender\nslum\nlog_IgG\nage_group\n\n\n\n\n5772\n0.3176895\n2\nFemale\nNon slum\n-1.1466807\nyoung\n\n\n8095\n3.4368231\n4\nFemale\nNon slum\n1.2345475\nyoung\n\n\n9784\n0.3000000\n4\nMale\nNon slum\n-1.2039728\nyoung\n\n\n9338\n143.2363014\n4\nMale\nNon slum\n4.9644957\nyoung\n\n\n6369\n0.4476534\n1\nMale\nNon slum\n-0.8037359\nyoung\n\n\n6885\n0.0252708\n4\nMale\nNon slum\n-3.6781074\nyoung"
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#nesting-ifelse-statements-example",
    "href": "modules/Module07-VarCreationClassesSummaries.html#nesting-ifelse-statements-example",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "Nesting ifelse statements example",
    "text": "Nesting ifelse statements example\n\ndf$age_group &lt;- ifelse(df$age &lt;= 5, \"young\", \n                       ifelse(df$age&lt;=10 & df$age&gt;5, \"middle\", \n                              ifelse(df$age&gt;10, \"old\", NA)))\nhead(df)\n\n\n\n\n\n\n\n\n\n\n\n\n\nobservation_id\nIgG_concentration\nage\ngender\nslum\nlog_IgG\nage_group\n\n\n\n\n5772\n0.3176895\n2\nFemale\nNon slum\n-1.1466807\nyoung\n\n\n8095\n3.4368231\n4\nFemale\nNon slum\n1.2345475\nyoung\n\n\n9784\n0.3000000\n4\nMale\nNon slum\n-1.2039728\nyoung\n\n\n9338\n143.2363014\n4\nMale\nNon slum\n4.9644957\nyoung\n\n\n6369\n0.4476534\n1\nMale\nNon slum\n-0.8037359\nyoung\n\n\n6885\n0.0252708\n4\nMale\nNon slum\n-3.6781074\nyoung"
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#overview---data-classes",
    "href": "modules/Module07-VarCreationClassesSummaries.html#overview---data-classes",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "Overview - Data Classes",
    "text": "Overview - Data Classes\n\nOne dimensional types (i.e., vectors of characters, numeric, logical, or factor values)\nTwo dimensional types (e.g., matrix, data frame, tibble)\nSpecial data classes (e.g., lists, dates)."
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#class-function",
    "href": "modules/Module07-VarCreationClassesSummaries.html#class-function",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "class() function",
    "text": "class() function\nThe class() function allows you to evaluate the class of an object.\n\nclass(df$IgG_concentration)\n\n[1] \"numeric\"\n\nclass(df$age)\n\n[1] \"integer\"\n\nclass(df$gender)\n\n[1] \"character\"\n\n\nReturn the First or Last Parts of an Object\nDescription:\n Returns the first or last parts of a vector, matrix, table, data\n frame or function.  Since 'head()' and 'tail()' are generic\n functions, they may also have been extended to other classes.\nUsage:\n head(x, ...)\n ## Default S3 method:\n head(x, n = 6L, ...)\n \n ## S3 method for class 'matrix'\n head(x, n = 6L, ...) # is exported as head.matrix()\n ## NB: The methods for 'data.frame' and 'array'  are identical to the 'matrix' one\n \n ## S3 method for class 'ftable'\n head(x, n = 6L, ...)\n ## S3 method for class 'function'\n head(x, n = 6L, ...)\n \n \n tail(x, ...)\n ## Default S3 method:\n tail(x, n = 6L, keepnums = FALSE, addrownums, ...)\n ## S3 method for class 'matrix'\n tail(x, n = 6L, keepnums = TRUE, addrownums, ...) # exported as tail.matrix()\n ## NB: The methods for 'data.frame', 'array', and 'table'\n ##     are identical to the  'matrix'  one\n \n ## S3 method for class 'ftable'\n tail(x, n = 6L, keepnums = FALSE, addrownums, ...)\n ## S3 method for class 'function'\n tail(x, n = 6L, ...)\n \nArguments:\n   x: an object\n\n   n: an integer vector of length up to 'dim(x)' (or 1, for\n      non-dimensioned objects).  A 'logical' is silently coerced to\n      integer.  Values specify the indices to be selected in the\n      corresponding dimension (or along the length) of the object.\n      A positive value of 'n[i]' includes the first/last 'n[i]'\n      indices in that dimension, while a negative value excludes\n      the last/first 'abs(n[i])', including all remaining indices.\n      'NA' or non-specified values (when 'length(n) &lt;\n      length(dim(x))') select all indices in that dimension. Must\n      contain at least one non-missing value.\nkeepnums: in each dimension, if no names in that dimension are present, create them using the indices included in that dimension. Ignored if ‘dim(x)’ is ‘NULL’ or its length 1.\naddrownums: deprecated - ‘keepnums’ should be used instead. Taken as the value of ‘keepnums’ if it is explicitly set when ‘keepnums’ is not.\n ...: arguments to be passed to or from other methods.\nDetails:\n For vector/array based objects, 'head()' ('tail()') returns a\n subset of the same dimensionality as 'x', usually of the same\n class. For historical reasons, by default they select the first\n (last) 6 indices in the first dimension (\"rows\") or along the\n length of a non-dimensioned vector, and the full extent (all\n indices) in any remaining dimensions. 'head.matrix()' and\n 'tail.matrix()' are exported.\n\n The default and array(/matrix) methods for 'head()' and 'tail()'\n are quite general. They will work as is for any class which has a\n 'dim()' method, a 'length()' method (only required if 'dim()'\n returns 'NULL'), and a '[' method (that accepts the 'drop'\n argument and can subset in all dimensions in the dimensioned\n case).\n\n For functions, the lines of the deparsed function are returned as\n character strings.\n\n When 'x' is an array(/matrix) of dimensionality two and more,\n 'tail()' will add dimnames similar to how they would appear in a\n full printing of 'x' for all dimensions 'k' where 'n[k]' is\n specified and non-missing and 'dimnames(x)[[k]]' (or 'dimnames(x)'\n itself) is 'NULL'.  Specifically, the form of the added dimnames\n will vary for different dimensions as follows:\n\n 'k=1' (rows): '\"[n,]\"' (right justified with whitespace padding)\n\n 'k=2' (columns): '\"[,n]\"' (with _no_ whitespace padding)\n\n 'k&gt;2' (higher dims): '\"n\"', i.e., the indices as _character_\n      values\n\n Setting 'keepnums = FALSE' suppresses this behaviour.\n\n As 'data.frame' subsetting ('indexing') keeps 'attributes', so do\n the 'head()' and 'tail()' methods for data frames.\nValue:\n An object (usually) like 'x' but generally smaller.  Hence, for\n 'array's, the result corresponds to 'x[.., drop=FALSE]'.  For\n 'ftable' objects 'x', a transformed 'format(x)'.\nNote:\n For array inputs the output of 'tail' when 'keepnums' is 'TRUE',\n any dimnames vectors added for dimensions '&gt;2' are the original\n numeric indices in that dimension _as character vectors_.  This\n means that, e.g., for 3-dimensional array 'arr', 'tail(arr,\n c(2,2,-1))[ , , 2]' and 'tail(arr, c(2,2,-1))[ , , \"2\"]' may both\n be valid but have completely different meanings.\nAuthor(s):\n Patrick Burns, improved and corrected by R-Core. Negative argument\n added by Vincent Goulet.  Multi-dimension support added by Gabriel\n Becker.\nExamples:\n head(letters)\n head(letters, n = -6L)\n \n head(freeny.x, n = 10L)\n head(freeny.y)\n \n head(iris3)\n head(iris3, c(6L, 2L))\n head(iris3, c(6L, -1L, 2L))\n \n tail(letters)\n tail(letters, n = -6L)\n \n tail(freeny.x)\n ## the bottom-right \"corner\" :\n tail(freeny.x, n = c(4, 2))\n tail(freeny.y)\n \n tail(iris3)\n tail(iris3, c(6L, 2L))\n tail(iris3, c(6L, -1L, 2L))\n \n ## iris with dimnames stripped\n a3d &lt;- iris3 ; dimnames(a3d) &lt;- NULL\n tail(a3d, c(6, -1, 2)) # keepnums = TRUE is default here!\n tail(a3d, c(6, -1, 2), keepnums = FALSE)\n \n ## data frame w/ a (non-standard) attribute:\n treeS &lt;- structure(trees, foo = \"bar\")\n (n &lt;- nrow(treeS))\n stopifnot(exprs = { # attribute is kept\n     identical(htS &lt;- head(treeS), treeS[1:6, ])\n     identical(attr(htS, \"foo\") , \"bar\")\n     identical(tlS &lt;- tail(treeS), treeS[(n-5):n, ])\n     ## BUT if I use \"useAttrib(.)\", this is *not* ok, when n is of length 2:\n     ## --- because [i,j]-indexing of data frames *also* drops \"other\" attributes ..\n     identical(tail(treeS, 3:2), treeS[(n-2):n, 2:3] )\n })\n \n tail(library) # last lines of function\n \n head(stats::ftable(Titanic))\n \n ## 1d-array (with named dim) :\n a1 &lt;- array(1:7, 7); names(dim(a1)) &lt;- \"O2\"\n stopifnot(exprs = {\n   identical( tail(a1, 10), a1)\n   identical( head(a1, 10), a1)\n   identical( head(a1, 1), a1 [1 , drop=FALSE] ) # was a1[1] in R &lt;= 3.6.x\n   identical( tail(a1, 2), a1[6:7])\n   identical( tail(a1, 1), a1 [7 , drop=FALSE] ) # was a1[7] in R &lt;= 3.6.x\n })"
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#one-dimensional-data-types",
    "href": "modules/Module07-VarCreationClassesSummaries.html#one-dimensional-data-types",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "One dimensional data types",
    "text": "One dimensional data types\n\nCharacter: strings or individual characters, quoted\nNumeric: any real number(s)\n\nDouble: contains fractional values (i.e., double precision) - default numeric\nInteger: any integer(s)/whole numbers\n\nLogical: variables composed of TRUE or FALSE\nFactor: categorical/qualitative variables"
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#character-and-numeric",
    "href": "modules/Module07-VarCreationClassesSummaries.html#character-and-numeric",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "Character and numeric",
    "text": "Character and numeric\nThis can also be a bit tricky.\nIf only one character in the whole vector, the class is assumed to be character\n\nclass(c(1, 2, \"tree\")) \n\n[1] \"character\"\n\n\nHere because integers are in quotations, it is read as a character class by R.\n\nclass(c(\"1\", \"4\", \"7\")) \n\n[1] \"character\"\n\n\nNote, this is the first time we have shown you nested functions. Here, instead of creating a new vector object (e.g., x &lt;- c(\"1\", \"4\", \"7\")) and then feeding the vector object x into the first argument of the class() function (e.g., class(x)), we combined the two steps and directly fed a vector object into the class function."
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#numeric-subclasses",
    "href": "modules/Module07-VarCreationClassesSummaries.html#numeric-subclasses",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "Numeric Subclasses",
    "text": "Numeric Subclasses\nThere are two major numeric subclasses\n\nDouble is a special subset of numeric that contains fractional values. Double stands for double-precision\nInteger is a special subset of numeric that contains only whole numbers.\n\ntypeof() identifies the vector type (double, integer, logical, or character), whereas class() identifies the root class. The difference between the two will be more clear when we look at two dimensional classes below.\n\nclass(df$IgG_concentration)\n\n[1] \"numeric\"\n\nclass(df$age)\n\n[1] \"integer\"\n\ntypeof(df$IgG_concentration)\n\n[1] \"double\"\n\ntypeof(df$age)\n\n[1] \"integer\""
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#logical",
    "href": "modules/Module07-VarCreationClassesSummaries.html#logical",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "Logical",
    "text": "Logical\nReminder logical is a type that only has two possible elements: TRUE and FALSE.\n\nclass(c(TRUE, FALSE, TRUE, TRUE, FALSE))\n\n[1] \"logical\"\n\n\nNote that logical elements are NOT in quotes. Putting R special classes (e.g., NA or FALSE) in quotations turns them into character value."
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#other-useful-functions-for-evaluatingsetting-classes",
    "href": "modules/Module07-VarCreationClassesSummaries.html#other-useful-functions-for-evaluatingsetting-classes",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "Other useful functions for evaluating/setting classes",
    "text": "Other useful functions for evaluating/setting classes\nThere are two useful functions associated with practically all R classes:\n\nis.CLASS_NAME(x) to logically check whether or not x is of certain class. For example, is.integer or is.character or is.numeric\nas.CLASS_NAME(x) to coerce between classes x from current x class into a certain class. For example, as.integer or as.character or as.numeric. This is particularly useful is maybe integer variable was read in as a character variable, or when you need to change a character variable to a factor variable (more on this later)."
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#examples-is.class_namex",
    "href": "modules/Module07-VarCreationClassesSummaries.html#examples-is.class_namex",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "Examples is.CLASS_NAME(x)",
    "text": "Examples is.CLASS_NAME(x)\n\nis.numeric(df$IgG_concentration)\n\n[1] TRUE\n\nis.character(df$age)\n\n[1] FALSE\n\nis.character(df$gender)\n\n[1] TRUE"
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#examples-as.class_namex",
    "href": "modules/Module07-VarCreationClassesSummaries.html#examples-as.class_namex",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "Examples as.CLASS_NAME(x)",
    "text": "Examples as.CLASS_NAME(x)\nIn some cases, coercing is seamless\n\nas.character(c(1, 4, 7))\n\n[1] \"1\" \"4\" \"7\"\n\nas.numeric(c(\"1\", \"4\", \"7\"))\n\n[1] 1 4 7\n\nas.logical(c(\"TRUE\", \"FALSE\", \"FALSE\"))\n\n[1]  TRUE FALSE FALSE\n\n\nIn some cases the coercing is not possible; if executed, will return NA (an R constant representing “Not Available” i.e. missing value)\n\nas.numeric(c(\"1\", \"4\", \"7a\"))\n\nWarning: NAs introduced by coercion\n\n\n[1]  1  4 NA\n\nas.logical(c(\"TRUE\", \"FALSE\", \"UNKNOWN\"))\n\n[1]  TRUE FALSE    NA"
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#factors",
    "href": "modules/Module07-VarCreationClassesSummaries.html#factors",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "Factors",
    "text": "Factors\nA factor is a special character vector where the elements have pre-defined groups or ‘levels’. You can think of these as qualitative or categorical variables. Use the factor() function to create factors from character values.\n\nclass(df$age_group)\n\n[1] \"character\"\n\ndf$age_group_factor &lt;- factor(df$age_group)\nclass(df$age_group_factor)\n\n[1] \"factor\"\n\nlevels(df$age_group_factor)\n\n[1] \"middle\" \"old\"    \"young\" \n\n\nNote that levels are, by default, set to alphanumerical order! And, the first is always the “reference” group. However, we often prefer a different reference group."
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#reference-groups",
    "href": "modules/Module07-VarCreationClassesSummaries.html#reference-groups",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "Reference Groups",
    "text": "Reference Groups\nWhy do we care about reference groups?\nGeneralized linear regression allows you to compare the outcome of two or more groups. Your reference group is the group that everything else is compared to. Say we want to assess whether being &lt;5 years old is associated with higher IgG antibody concentrations\nBy default middle is the reference group therefore we will only generate beta coefficients comparing middle to young AND middle to old. But, we want young to be the reference group so we will generate beta coefficients comparing young to middle AND young to old."
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#changing-factor-reference",
    "href": "modules/Module07-VarCreationClassesSummaries.html#changing-factor-reference",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "Changing factor reference",
    "text": "Changing factor reference\nChanging the reference group of a factor variable. - If the object is already a factor then use relevel() function and the ref argument to specify the reference. - If the object is a character then use factor() function and levels argument to specify the order of the values, the first being the reference.\nReorder Levels of Factor\nDescription:\n The levels of a factor are re-ordered so that the level specified\n by 'ref' is first and the others are moved down. This is useful\n for 'contr.treatment' contrasts which take the first level as the\n reference.\nUsage:\n relevel(x, ref, ...)\n \nArguments:\n   x: an unordered factor.\n\n ref: the reference level, typically a string.\n\n ...: additional arguments for future methods.\nDetails:\n This, as 'reorder()', is a special case of simply calling\n 'factor(x, levels = levels(x)[....])'.\nValue:\n A factor of the same length as 'x'.\nSee Also:\n 'factor', 'contr.treatment', 'levels', 'reorder'.\nExamples:\n warpbreaks$tension &lt;- relevel(warpbreaks$tension, ref = \"M\")\n summary(lm(breaks ~ wool + tension, data = warpbreaks))\nFactors\nDescription:\n The function 'factor' is used to encode a vector as a factor (the\n terms 'category' and 'enumerated type' are also used for factors).\n If argument 'ordered' is 'TRUE', the factor levels are assumed to\n be ordered.  For compatibility with S there is also a function\n 'ordered'.\n\n 'is.factor', 'is.ordered', 'as.factor' and 'as.ordered' are the\n membership and coercion functions for these classes.\nUsage:\n factor(x = character(), levels, labels = levels,\n        exclude = NA, ordered = is.ordered(x), nmax = NA)\n \n ordered(x = character(), ...)\n \n is.factor(x)\n is.ordered(x)\n \n as.factor(x)\n as.ordered(x)\n \n addNA(x, ifany = FALSE)\n \n .valid.factor(object)\n \nArguments:\n   x: a vector of data, usually taking a small number of distinct\n      values.\nlevels: an optional vector of the unique values (as character strings) that ‘x’ might have taken. The default is the unique set of values taken by ‘as.character(x)’, sorted into increasing order of ‘x’. Note that this set can be specified as smaller than ‘sort(unique(x))’.\nlabels: either an optional character vector of labels for the levels (in the same order as ‘levels’ after removing those in ‘exclude’), or a character string of length 1. Duplicated values in ‘labels’ can be used to map different values of ‘x’ to the same factor level.\nexclude: a vector of values to be excluded when forming the set of levels. This may be factor with the same level set as ‘x’ or should be a ‘character’.\nordered: logical flag to determine if the levels should be regarded as ordered (in the order given).\nnmax: an upper bound on the number of levels; see 'Details'.\n\n ...: (in 'ordered(.)'): any of the above, apart from 'ordered'\n      itself.\nifany: only add an ‘NA’ level if it is used, i.e. if ‘any(is.na(x))’.\nobject: an R object.\nDetails:\n The type of the vector 'x' is not restricted; it only must have an\n 'as.character' method and be sortable (by 'order').\n\n Ordered factors differ from factors only in their class, but\n methods and the model-fitting functions treat the two classes\n quite differently.\n\n The encoding of the vector happens as follows.  First all the\n values in 'exclude' are removed from 'levels'. If 'x[i]' equals\n 'levels[j]', then the 'i'-th element of the result is 'j'.  If no\n match is found for 'x[i]' in 'levels' (which will happen for\n excluded values) then the 'i'-th element of the result is set to\n 'NA'.\n\n Normally the 'levels' used as an attribute of the result are the\n reduced set of levels after removing those in 'exclude', but this\n can be altered by supplying 'labels'.  This should either be a set\n of new labels for the levels, or a character string, in which case\n the levels are that character string with a sequence number\n appended.\n\n 'factor(x, exclude = NULL)' applied to a factor without 'NA's is a\n no-operation unless there are unused levels: in that case, a\n factor with the reduced level set is returned.  If 'exclude' is\n used, since R version 3.4.0, excluding non-existing character\n levels is equivalent to excluding nothing, and when 'exclude' is a\n 'character' vector, that _is_ applied to the levels of 'x'.\n Alternatively, 'exclude' can be factor with the same level set as\n 'x' and will exclude the levels present in 'exclude'.\n\n The codes of a factor may contain 'NA'.  For a numeric 'x', set\n 'exclude = NULL' to make 'NA' an extra level (prints as '&lt;NA&gt;');\n by default, this is the last level.\n\n If 'NA' is a level, the way to set a code to be missing (as\n opposed to the code of the missing level) is to use 'is.na' on the\n left-hand-side of an assignment (as in 'is.na(f)[i] &lt;- TRUE';\n indexing inside 'is.na' does not work).  Under those circumstances\n missing values are currently printed as '&lt;NA&gt;', i.e., identical to\n entries of level 'NA'.\n\n 'is.factor' is generic: you can write methods to handle specific\n classes of objects, see InternalMethods.\n\n Where 'levels' is not supplied, 'unique' is called.  Since factors\n typically have quite a small number of levels, for large vectors\n 'x' it is helpful to supply 'nmax' as an upper bound on the number\n of unique values.\n\n When using 'c' to combine a (possibly ordered) factor with other\n objects, if all objects are (possibly ordered) factors, the result\n will be a factor with levels the union of the level sets of the\n elements, in the order the levels occur in the level sets of the\n elements (which means that if all the elements have the same level\n set, that is the level set of the result), equivalent to how\n 'unlist' operates on a list of factor objects.\nValue:\n 'factor' returns an object of class '\"factor\"' which has a set of\n integer codes the length of 'x' with a '\"levels\"' attribute of\n mode 'character' and unique ('!anyDuplicated(.)') entries.  If\n argument 'ordered' is true (or 'ordered()' is used) the result has\n class 'c(\"ordered\", \"factor\")'.  Undocumentedly for a long time,\n 'factor(x)' loses all 'attributes(x)' but '\"names\"', and resets\n '\"levels\"' and '\"class\"'.\n\n Applying 'factor' to an ordered or unordered factor returns a\n factor (of the same type) with just the levels which occur: see\n also '[.factor' for a more transparent way to achieve this.\n\n 'is.factor' returns 'TRUE' or 'FALSE' depending on whether its\n argument is of type factor or not.  Correspondingly, 'is.ordered'\n returns 'TRUE' when its argument is an ordered factor and 'FALSE'\n otherwise.\n\n 'as.factor' coerces its argument to a factor.  It is an\n abbreviated (sometimes faster) form of 'factor'.\n\n 'as.ordered(x)' returns 'x' if this is ordered, and 'ordered(x)'\n otherwise.\n\n 'addNA' modifies a factor by turning 'NA' into an extra level (so\n that 'NA' values are counted in tables, for instance).\n\n '.valid.factor(object)' checks the validity of a factor, currently\n only 'levels(object)', and returns 'TRUE' if it is valid,\n otherwise a string describing the validity problem.  This function\n is used for 'validObject(&lt;factor&gt;)'.\nWarning:\n The interpretation of a factor depends on both the codes and the\n '\"levels\"' attribute.  Be careful only to compare factors with the\n same set of levels (in the same order).  In particular,\n 'as.numeric' applied to a factor is meaningless, and may happen by\n implicit coercion.  To transform a factor 'f' to approximately its\n original numeric values, 'as.numeric(levels(f))[f]' is recommended\n and slightly more efficient than 'as.numeric(as.character(f))'.\n\n The levels of a factor are by default sorted, but the sort order\n may well depend on the locale at the time of creation, and should\n not be assumed to be ASCII.\n\n There are some anomalies associated with factors that have 'NA' as\n a level.  It is suggested to use them sparingly, e.g., only for\n tabulation purposes.\nComparison operators and group generic methods:\n There are '\"factor\"' and '\"ordered\"' methods for the group generic\n 'Ops' which provide methods for the Comparison operators, and for\n the 'min', 'max', and 'range' generics in 'Summary' of\n '\"ordered\"'.  (The rest of the groups and the 'Math' group\n generate an error as they are not meaningful for factors.)\n\n Only '==' and '!=' can be used for factors: a factor can only be\n compared to another factor with an identical set of levels (not\n necessarily in the same ordering) or to a character vector.\n Ordered factors are compared in the same way, but the general\n dispatch mechanism precludes comparing ordered and unordered\n factors.\n\n All the comparison operators are available for ordered factors.\n Collation is done by the levels of the operands: if both operands\n are ordered factors they must have the same level set.\nNote:\n In earlier versions of R, storing character data as a factor was\n more space efficient if there is even a small proportion of\n repeats.  However, identical character strings now share storage,\n so the difference is small in most cases.  (Integer values are\n stored in 4 bytes whereas each reference to a character string\n needs a pointer of 4 or 8 bytes.)\nReferences:\n Chambers, J. M. and Hastie, T. J. (1992) _Statistical Models in\n S_.  Wadsworth & Brooks/Cole.\nSee Also:\n '[.factor' for subsetting of factors.\n\n 'gl' for construction of balanced factors and 'C' for factors with\n specified contrasts.  'levels' and 'nlevels' for accessing the\n levels, and 'unclass' to get integer codes.\nExamples:\n (ff &lt;- factor(substring(\"statistics\", 1:10, 1:10), levels = letters))\n as.integer(ff)      # the internal codes\n (f. &lt;- factor(ff))  # drops the levels that do not occur\n ff[, drop = TRUE]   # the same, more transparently\n \n factor(letters[1:20], labels = \"letter\")\n \n class(ordered(4:1)) # \"ordered\", inheriting from \"factor\"\n z &lt;- factor(LETTERS[3:1], ordered = TRUE)\n ## and \"relational\" methods work:\n stopifnot(sort(z)[c(1,3)] == range(z), min(z) &lt; max(z))\n \n \n ## suppose you want \"NA\" as a level, and to allow missing values.\n (x &lt;- factor(c(1, 2, NA), exclude = NULL))\n is.na(x)[2] &lt;- TRUE\n x  # [1] 1    &lt;NA&gt; &lt;NA&gt;\n is.na(x)\n # [1] FALSE  TRUE FALSE\n \n ## More rational, since R 3.4.0 :\n factor(c(1:2, NA), exclude =  \"\" ) # keeps &lt;NA&gt; , as\n factor(c(1:2, NA), exclude = NULL) # always did\n ## exclude = &lt;character&gt;\n z # ordered levels 'A &lt; B &lt; C'\n factor(z, exclude = \"C\") # does exclude\n factor(z, exclude = \"B\") # ditto\n \n ## Now, labels maybe duplicated:\n ## factor() with duplicated labels allowing to \"merge levels\"\n x &lt;- c(\"Man\", \"Male\", \"Man\", \"Lady\", \"Female\")\n ## Map from 4 different values to only two levels:\n (xf &lt;- factor(x, levels = c(\"Male\", \"Man\" , \"Lady\",   \"Female\"),\n                  labels = c(\"Male\", \"Male\", \"Female\", \"Female\")))\n #&gt; [1] Male   Male   Male   Female Female\n #&gt; Levels: Male Female\n \n ## Using addNA()\n Month &lt;- airquality$Month\n table(addNA(Month))\n table(addNA(Month, ifany = TRUE))"
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#changing-factor-reference-examples",
    "href": "modules/Module07-VarCreationClassesSummaries.html#changing-factor-reference-examples",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "Changing factor reference examples",
    "text": "Changing factor reference examples\n\ndf$age_group_factor &lt;- relevel(df$age_group_factor, ref=\"young\")\nlevels(df$age_group_factor)\n\n[1] \"young\"  \"middle\" \"old\"   \n\n\nOR\n\ndf$age_group_factor &lt;- factor(df$age_group, levels=c(\"young\", \"middle\", \"old\"))\nlevels(df$age_group_factor)\n\n[1] \"young\"  \"middle\" \"old\"   \n\n\nArranging, tabulating, and plotting the data will reflect the new order"
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#two-dimensional-data-classes",
    "href": "modules/Module07-VarCreationClassesSummaries.html#two-dimensional-data-classes",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "Two-dimensional data classes",
    "text": "Two-dimensional data classes\nTwo-dimensional classes are those we would often use to store data read from a file\n\na matrix (matrix class)\na data frame (data.frame or tibble classes)"
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#matrices",
    "href": "modules/Module07-VarCreationClassesSummaries.html#matrices",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "Matrices",
    "text": "Matrices\nMatrices, like data frames are also composed of rows and columns. Matrices, unlike data.frame, the entire matrix is composed of one R class. For example: all entries are numeric, or all entries are character\nas.matrix() creates a matrix from a data frame (where all values are the same class).\nYou can also create a matrix from scratch using matrix() Use ?matrix to see the arguments.\n\nmatrix(1:6, ncol = 2) \n\n\n\n\n1\n4\n\n\n2\n5\n\n\n3\n6\n\n\n\n\nmatrix(1:6, ncol=2, byrow=TRUE) \n\n\n\n\n1\n2\n\n\n3\n4\n\n\n5\n6\n\n\n\n\n\nNotice, the first matrix filled in numbers 1-6 by columns first and then rows because default byrow argument is FALSE. In the second matrix, we changed the argument byrow to TRUE, and now numbers 1-6 are filled by rows first and then columns."
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#data-frame",
    "href": "modules/Module07-VarCreationClassesSummaries.html#data-frame",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "Data Frame",
    "text": "Data Frame\nYou can transform an existing matrix into data frames and tibble using as.data.frame().\n\nas.data.frame(matrix(1:6, ncol = 2) ) \n\n\n\n\nV1\nV2\n\n\n\n\n1\n4\n\n\n2\n5\n\n\n3\n6"
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#numeric-variable-data-summary",
    "href": "modules/Module07-VarCreationClassesSummaries.html#numeric-variable-data-summary",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "Numeric variable data summary",
    "text": "Numeric variable data summary\nData summarization on numeric vectors/variables: - mean(): takes the mean of x - sd(): takes the standard deviation of x - median(): takes the median of x - quantile(): displays sample quantiles of x. Default is min, IQR, max - range(): displays the range. Same as c(min(), max()) - sum(): sum of x - max(): maximum value in x - min(): minimum value in x\nNote, all have the  na.rm = argument for missing data\nArithmetic Mean\nDescription:\n Generic function for the (trimmed) arithmetic mean.\nUsage:\n mean(x, ...)\n \n ## Default S3 method:\n mean(x, trim = 0, na.rm = FALSE, ...)\n \nArguments:\n   x: An R object.  Currently there are methods for numeric/logical\n      vectors and date, date-time and time interval objects.\n      Complex vectors are allowed for 'trim = 0', only.\n\ntrim: the fraction (0 to 0.5) of observations to be trimmed from\n      each end of 'x' before the mean is computed.  Values of trim\n      outside that range are taken as the nearest endpoint.\nna.rm: a logical evaluating to ‘TRUE’ or ‘FALSE’ indicating whether ‘NA’ values should be stripped before the computation proceeds.\n ...: further arguments passed to or from other methods.\nValue:\n If 'trim' is zero (the default), the arithmetic mean of the values\n in 'x' is computed, as a numeric or complex vector of length one.\n If 'x' is not logical (coerced to numeric), numeric (including\n integer) or complex, 'NA_real_' is returned, with a warning.\n\n If 'trim' is non-zero, a symmetrically trimmed mean is computed\n with a fraction of 'trim' observations deleted from each end\n before the mean is computed.\nReferences:\n Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S\n Language_.  Wadsworth & Brooks/Cole.\nSee Also:\n 'weighted.mean', 'mean.POSIXct', 'colMeans' for row and column\n means.\nExamples:\n x &lt;- c(0:10, 50)\n xm &lt;- mean(x)\n c(xm, mean(x, trim = 0.10))"
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#numeric-variable-data-summary-examples",
    "href": "modules/Module07-VarCreationClassesSummaries.html#numeric-variable-data-summary-examples",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "Numeric variable data summary examples",
    "text": "Numeric variable data summary examples\n\nsummary(df)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nobservation_id\nIgG_concentration\nage\ngender\nslum\nlog_IgG\nage_group\nage_group_factor\n\n\n\n\n\nMin. :5006\nMin. : 0.0054\nMin. : 1.000\nLength:651\nLength:651\nMin. :-5.2231\nLength:651\nyoung :316\n\n\n\n1st Qu.:6306\n1st Qu.: 0.3000\n1st Qu.: 3.000\nClass :character\nClass :character\n1st Qu.:-1.2040\nClass :character\nmiddle:179\n\n\n\nMedian :7495\nMedian : 1.6658\nMedian : 6.000\nMode :character\nMode :character\nMedian : 0.5103\nMode :character\nold :147\n\n\n\nMean :7492\nMean : 87.3683\nMean : 6.606\nNA\nNA\nMean : 1.6074\nNA\nNA’s : 9\n\n\n\n3rd Qu.:8749\n3rd Qu.:141.4405\n3rd Qu.:10.000\nNA\nNA\n3rd Qu.: 4.9519\nNA\nNA\n\n\n\nMax. :9982\nMax. :916.4179\nMax. :15.000\nNA\nNA\nMax. : 6.8205\nNA\nNA\n\n\n\nNA\nNA’s :10\nNA’s :9\nNA\nNA\nNA’s :10\nNA\nNA\n\n\n\n\nrange(df$age)\n\n[1] NA NA\n\nrange(df$age, na.rm=TRUE)\n\n[1]  1 15\n\nmedian(df$IgG_concentration, na.rm=TRUE)\n\n[1] 1.665753"
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#character-variable-data-summaries",
    "href": "modules/Module07-VarCreationClassesSummaries.html#character-variable-data-summaries",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "Character Variable Data Summaries",
    "text": "Character Variable Data Summaries\nData summarization on character or factor vectors/variables * table()\nCross Tabulation and Table Creation\nDescription:\n 'table' uses cross-classifying factors to build a contingency\n table of the counts at each combination of factor levels.\nUsage:\n table(...,\n       exclude = if (useNA == \"no\") c(NA, NaN),\n       useNA = c(\"no\", \"ifany\", \"always\"),\n       dnn = list.names(...), deparse.level = 1)\n \n as.table(x, ...)\n is.table(x)\n \n ## S3 method for class 'table'\n as.data.frame(x, row.names = NULL, ...,\n               responseName = \"Freq\", stringsAsFactors = TRUE,\n               sep = \"\", base = list(LETTERS))\n \nArguments:\n ...: one or more objects which can be interpreted as factors\n      (including numbers or character strings), or a 'list' (such\n      as a data frame) whose components can be so interpreted.\n      (For 'as.table', arguments passed to specific methods; for\n      'as.data.frame', unused.)\nexclude: levels to remove for all factors in ‘…’. If it does not contain ‘NA’ and ‘useNA’ is not specified, it implies ‘useNA = “ifany”’. See ‘Details’ for its interpretation for non-factor arguments.\nuseNA: whether to include ‘NA’ values in the table. See ‘Details’. Can be abbreviated.\n dnn: the names to be given to the dimensions in the result (the\n      _dimnames names_).\ndeparse.level: controls how the default ‘dnn’ is constructed. See ‘Details’.\n   x: an arbitrary R object, or an object inheriting from class\n      '\"table\"' for the 'as.data.frame' method. Note that\n      'as.data.frame.table(x, *)' may be called explicitly for\n      non-table 'x' for \"reshaping\" 'array's.\nrow.names: a character vector giving the row names for the data frame.\nresponseName: The name to be used for the column of table entries, usually counts.\nstringsAsFactors: logical: should the classifying factors be returned as factors (the default) or character vectors?\nsep, base: passed to ‘provideDimnames’.\nDetails:\n If the argument 'dnn' is not supplied, the internal function\n 'list.names' is called to compute the 'dimname names' as follows:\n If '...' is one 'list' with its own 'names()', these 'names' are\n used.  Otherwise, if the arguments in '...' are named, those names\n are used.  For the remaining arguments, 'deparse.level = 0' gives\n an empty name, 'deparse.level = 1' uses the supplied argument if\n it is a symbol, and 'deparse.level = 2' will deparse the argument.\n\n Only when 'exclude' is specified (i.e., not by default) and\n non-empty, will 'table' potentially drop levels of factor\n arguments.\n\n 'useNA' controls if the table includes counts of 'NA' values: the\n allowed values correspond to never ('\"no\"'), only if the count is\n positive ('\"ifany\"') and even for zero counts ('\"always\"').  Note\n the somewhat \"pathological\" case of two different kinds of 'NA's\n which are treated differently, depending on both 'useNA' and\n 'exclude', see 'd.patho' in the 'Examples:' below.\n\n Both 'exclude' and 'useNA' operate on an \"all or none\" basis.  If\n you want to control the dimensions of a multiway table separately,\n modify each argument using 'factor' or 'addNA'.\n\n Non-factor arguments 'a' are coerced via 'factor(a,\n exclude=exclude)'.  Since R 3.4.0, care is taken _not_ to count\n the excluded values (where they were included in the 'NA' count,\n previously).\n\n The 'summary' method for class '\"table\"' (used for objects created\n by 'table' or 'xtabs') which gives basic information and performs\n a chi-squared test for independence of factors (note that the\n function 'chisq.test' currently only handles 2-d tables).\nValue:\n 'table()' returns a _contingency table_, an object of class\n '\"table\"', an array of integer values.  Note that unlike S the\n result is always an 'array', a 1D array if one factor is given.\n\n 'as.table' and 'is.table' coerce to and test for contingency\n table, respectively.\n\n The 'as.data.frame' method for objects inheriting from class\n '\"table\"' can be used to convert the array-based representation of\n a contingency table to a data frame containing the classifying\n factors and the corresponding entries (the latter as component\n named by 'responseName').  This is the inverse of 'xtabs'.\nReferences:\n Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S\n Language_.  Wadsworth & Brooks/Cole.\nSee Also:\n 'tabulate' is the underlying function and allows finer control.\n\n Use 'ftable' for printing (and more) of multidimensional tables.\n 'margin.table', 'prop.table', 'addmargins'.\n\n 'addNA' for constructing factors with 'NA' as a level.\n\n 'xtabs' for cross tabulation of data frames with a formula\n interface.\nExamples:\n require(stats) # for rpois and xtabs\n ## Simple frequency distribution\n table(rpois(100, 5))\n ## Check the design:\n with(warpbreaks, table(wool, tension))\n table(state.division, state.region)\n \n # simple two-way contingency table\n with(airquality, table(cut(Temp, quantile(Temp)), Month))\n \n a &lt;- letters[1:3]\n table(a, sample(a))                    # dnn is c(\"a\", \"\")\n table(a, sample(a), deparse.level = 0) # dnn is c(\"\", \"\")\n table(a, sample(a), deparse.level = 2) # dnn is c(\"a\", \"sample(a)\")\n \n ## xtabs() &lt;-&gt; as.data.frame.table() :\n UCBAdmissions ## already a contingency table\n DF &lt;- as.data.frame(UCBAdmissions)\n class(tab &lt;- xtabs(Freq ~ ., DF)) # xtabs & table\n ## tab *is* \"the same\" as the original table:\n all(tab == UCBAdmissions)\n all.equal(dimnames(tab), dimnames(UCBAdmissions))\n \n a &lt;- rep(c(NA, 1/0:3), 10)\n table(a)                 # does not report NA's\n table(a, exclude = NULL) # reports NA's\n b &lt;- factor(rep(c(\"A\",\"B\",\"C\"), 10))\n table(b)\n table(b, exclude = \"B\")\n d &lt;- factor(rep(c(\"A\",\"B\",\"C\"), 10), levels = c(\"A\",\"B\",\"C\",\"D\",\"E\"))\n table(d, exclude = \"B\")\n print(table(b, d), zero.print = \".\")\n \n ## NA counting:\n is.na(d) &lt;- 3:4\n d. &lt;- addNA(d)\n d.[1:7]\n table(d.) # \", exclude = NULL\" is not needed\n ## i.e., if you want to count the NA's of 'd', use\n table(d, useNA = \"ifany\")\n \n ## \"pathological\" case:\n d.patho &lt;- addNA(c(1,NA,1:2,1:3))[-7]; is.na(d.patho) &lt;- 3:4\n d.patho\n ## just 3 consecutive NA's ? --- well, have *two* kinds of NAs here :\n as.integer(d.patho) # 1 4 NA NA 1 2\n ##\n ## In R &gt;= 3.4.0, table() allows to differentiate:\n table(d.patho)                   # counts the \"unusual\" NA\n table(d.patho, useNA = \"ifany\")  # counts all three\n table(d.patho, exclude = NULL)   #  (ditto)\n table(d.patho, exclude = NA)     # counts none\n \n ## Two-way tables with NA counts. The 3rd variant is absurd, but shows\n ## something that cannot be done using exclude or useNA.\n with(airquality,\n    table(OzHi = Ozone &gt; 80, Month, useNA = \"ifany\"))\n with(airquality,\n    table(OzHi = Ozone &gt; 80, Month, useNA = \"always\"))\n with(airquality,\n    table(OzHi = Ozone &gt; 80, addNA(Month)))"
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#character-variable-data-summary-examples",
    "href": "modules/Module07-VarCreationClassesSummaries.html#character-variable-data-summary-examples",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "Character variable data summary examples",
    "text": "Character variable data summary examples\nNumber of observations in each category\n\ntable(df$gender)\n\n\n\n\nFemale\nMale\n\n\n\n\n325\n326\n\n\n\n\ntable(df$gender, useNA=\"always\")\n\n\n\n\nFemale\nMale\nNA\n\n\n\n\n325\n326\n0\n\n\n\n\ntable(df$age_group, useNA=\"always\")\n\n\n\n\nmiddle\nold\nyoung\nNA\n\n\n\n\n179\n147\n316\n9\n\n\n\n\n\nPercent of observations in each category (xxzane - better way in base r?)\n\ntable(df$gender)/nrow(df) #if no NA values\n\n\n\n\nFemale\nMale\n\n\n\n\n0.499232\n0.500768\n\n\n\n\ntable(df$age_group)/nrow(df[!is.na(df$age_group),]) #if there are NA values\n\n\n\n\nmiddle\nold\nyoung\n\n\n\n\n0.2788162\n0.228972\n0.4922118\n\n\n\n\ntable(df$age_group)/nrow(subset(df, !is.na(df$age_group),)) #if there are NA values\n\n\n\n\nmiddle\nold\nyoung\n\n\n\n\n0.2788162\n0.228972\n0.4922118"
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#summary",
    "href": "modules/Module07-VarCreationClassesSummaries.html#summary",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "Summary",
    "text": "Summary\n\nAdding (or modifying) columns/variable to a data frame by using $\nThere are two types of numeric class objects: integer and double\nLogical class objects only have TRUE or False (without quotes)\nis.CLASS_NAME(x) can be used to test the class of an object x\nas.CLASS_NAME(x) can be used to change the class of an object x\nFactors are a special character class that has levels\n…"
  },
  {
    "objectID": "modules/Module07-VarCreationClassesSummaries.html#acknowledgements",
    "href": "modules/Module07-VarCreationClassesSummaries.html#acknowledgements",
    "title": "Module 7: Variable Creation, Classes, and Summaries",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nThese are the materials I looked through, modified, or extracted to complete this module’s lecture.\n\n“Introduction to R for Public Health Researchers” Johns Hopkins University"
  },
  {
    "objectID": "modules/Module09-DataAnalysis.html#learning-objectives",
    "href": "modules/Module09-DataAnalysis.html#learning-objectives",
    "title": "Module 9: Data Analysis",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nAfter module 9, you should be able to…\n\n  Descriptively assess association between two variables\n  Compute basic statistics \n  Fit a generalized linear model"
  },
  {
    "objectID": "modules/Module09-DataAnalysis.html#import-data-for-this-module",
    "href": "modules/Module09-DataAnalysis.html#import-data-for-this-module",
    "title": "Module 9: Data Analysis",
    "section": "Import data for this module",
    "text": "Import data for this module\nLet’s read in our data (again) and take a quick look.\n\ndf &lt;- read.csv(file = \"data/serodata.csv\") #relative path\nhead(x=df, n=3)\n\n  observation_id IgG_concentration age gender     slum\n1           5772         0.3176895   2 Female Non slum\n2           8095         3.4368231   4 Female Non slum\n3           9784         0.3000000   4   Male Non slum"
  },
  {
    "objectID": "modules/Module09-DataAnalysis.html#prep-data",
    "href": "modules/Module09-DataAnalysis.html#prep-data",
    "title": "Module 9: Data Analysis",
    "section": "Prep data",
    "text": "Prep data\nCreate age_group three level factor variable\n\ndf$age_group &lt;- ifelse(df$age &lt;= 5, \"young\", \n                       ifelse(df$age&lt;=10 & df$age&gt;5, \"middle\", \n                              ifelse(df$age&gt;10, \"old\", NA)))\ndf$age_group &lt;- factor(df$age_group, levels=c(\"young\", \"middle\", \"old\"))\n\nCreate seropos binary variable representing seropositivity if antibody concentrations are &gt;10 mIUmL.\n\ndf$seropos &lt;- ifelse(df$IgG_concentration&lt;10, 0, \n                                        ifelse(df$IgG_concentration&gt;=10, 1, NA))"
  },
  {
    "objectID": "modules/Module09-DataAnalysis.html#variable-contingency-tables",
    "href": "modules/Module09-DataAnalysis.html#variable-contingency-tables",
    "title": "Module 9: Data Analysis",
    "section": "2 variable contingency tables",
    "text": "2 variable contingency tables\nWe use table() prior to look at one variable, now we can generate frequency tables for 2 plus variables. To get cell percentages, the prop.table() is useful.\n\nfreq &lt;- table(df$age_group, df$seropo)\nprop &lt;- prop.table(freq)\nfreq\n\n        \n           0   1\n  young  254  57\n  middle  70 105\n  old     30 116\n\nprop\n\n        \n                  0          1\n  young  0.40189873 0.09018987\n  middle 0.11075949 0.16613924\n  old    0.04746835 0.18354430"
  },
  {
    "objectID": "modules/Module09-DataAnalysis.html#chi-square-test",
    "href": "modules/Module09-DataAnalysis.html#chi-square-test",
    "title": "Module 9: Data Analysis",
    "section": "Chi-Square test",
    "text": "Chi-Square test\nThe chisq.test() function test of independence of factor variables from stats package.\nRegistered S3 method overwritten by 'printr':\n  method                from     \n  knit_print.data.frame rmarkdown\nPearson’s Chi-squared Test for Count Data\nDescription:\n 'chisq.test' performs chi-squared contingency table tests and\n goodness-of-fit tests.\nUsage:\n chisq.test(x, y = NULL, correct = TRUE,\n            p = rep(1/length(x), length(x)), rescale.p = FALSE,\n            simulate.p.value = FALSE, B = 2000)\n \nArguments:\n   x: a numeric vector or matrix. 'x' and 'y' can also both be\n      factors.\n\n   y: a numeric vector; ignored if 'x' is a matrix.  If 'x' is a\n      factor, 'y' should be a factor of the same length.\ncorrect: a logical indicating whether to apply continuity correction when computing the test statistic for 2 by 2 tables: one half is subtracted from all |O - E| differences; however, the correction will not be bigger than the differences themselves. No correction is done if ‘simulate.p.value = TRUE’.\n   p: a vector of probabilities of the same length as 'x'.  An\n      error is given if any entry of 'p' is negative.\nrescale.p: a logical scalar; if TRUE then ‘p’ is rescaled (if necessary) to sum to 1. If ‘rescale.p’ is FALSE, and ‘p’ does not sum to 1, an error is given.\nsimulate.p.value: a logical indicating whether to compute p-values by Monte Carlo simulation.\n   B: an integer specifying the number of replicates used in the\n      Monte Carlo test.\nDetails:\n If 'x' is a matrix with one row or column, or if 'x' is a vector\n and 'y' is not given, then a _goodness-of-fit test_ is performed\n ('x' is treated as a one-dimensional contingency table).  The\n entries of 'x' must be non-negative integers.  In this case, the\n hypothesis tested is whether the population probabilities equal\n those in 'p', or are all equal if 'p' is not given.\n\n If 'x' is a matrix with at least two rows and columns, it is taken\n as a two-dimensional contingency table: the entries of 'x' must be\n non-negative integers.  Otherwise, 'x' and 'y' must be vectors or\n factors of the same length; cases with missing values are removed,\n the objects are coerced to factors, and the contingency table is\n computed from these.  Then Pearson's chi-squared test is performed\n of the null hypothesis that the joint distribution of the cell\n counts in a 2-dimensional contingency table is the product of the\n row and column marginals.\n\n If 'simulate.p.value' is 'FALSE', the p-value is computed from the\n asymptotic chi-squared distribution of the test statistic;\n continuity correction is only used in the 2-by-2 case (if\n 'correct' is 'TRUE', the default).  Otherwise the p-value is\n computed for a Monte Carlo test (Hope, 1968) with 'B' replicates.\n The default 'B = 2000' implies a minimum p-value of about 0.0005\n (1/(B+1)).\n\n In the contingency table case, simulation is done by random\n sampling from the set of all contingency tables with given\n marginals, and works only if the marginals are strictly positive.\n Continuity correction is never used, and the statistic is quoted\n without it.  Note that this is not the usual sampling situation\n assumed for the chi-squared test but rather that for Fisher's\n exact test.\n\n In the goodness-of-fit case simulation is done by random sampling\n from the discrete distribution specified by 'p', each sample being\n of size 'n = sum(x)'.  This simulation is done in R and may be\n slow.\nValue:\n A list with class '\"htest\"' containing the following components:\nstatistic: the value the chi-squared test statistic.\nparameter: the degrees of freedom of the approximate chi-squared distribution of the test statistic, ‘NA’ if the p-value is computed by Monte Carlo simulation.\np.value: the p-value for the test.\nmethod: a character string indicating the type of test performed, and whether Monte Carlo simulation or continuity correction was used.\ndata.name: a character string giving the name(s) of the data.\nobserved: the observed counts.\nexpected: the expected counts under the null hypothesis.\nresiduals: the Pearson residuals, ‘(observed - expected) / sqrt(expected)’.\nstdres: standardized residuals, ‘(observed - expected) / sqrt(V)’, where ‘V’ is the residual cell variance (Agresti, 2007, section 2.4.5 for the case where ‘x’ is a matrix, ‘n * p * (1 - p)’ otherwise).\nSource:\n The code for Monte Carlo simulation is a C translation of the\n Fortran algorithm of Patefield (1981).\nReferences:\n Hope, A. C. A. (1968).  A simplified Monte Carlo significance test\n procedure.  _Journal of the Royal Statistical Society Series B_,\n *30*, 582-598.  doi:10.1111/j.2517-6161.1968.tb00759.x\n &lt;https://doi.org/10.1111/j.2517-6161.1968.tb00759.x&gt;.\n\n Patefield, W. M. (1981).  Algorithm AS 159: An efficient method of\n generating r x c tables with given row and column totals.\n _Applied Statistics_, *30*, 91-97.  doi:10.2307/2346669\n &lt;https://doi.org/10.2307/2346669&gt;.\n\n Agresti, A. (2007).  _An Introduction to Categorical Data\n Analysis_, 2nd ed.  New York: John Wiley & Sons.  Page 38.\nSee Also:\n For goodness-of-fit testing, notably of continuous distributions,\n 'ks.test'.\nExamples:\n ## From Agresti(2007) p.39\n M &lt;- as.table(rbind(c(762, 327, 468), c(484, 239, 477)))\n dimnames(M) &lt;- list(gender = c(\"F\", \"M\"),\n                     party = c(\"Democrat\",\"Independent\", \"Republican\"))\n (Xsq &lt;- chisq.test(M))  # Prints test summary\n Xsq$observed   # observed counts (same as M)\n Xsq$expected   # expected counts under the null\n Xsq$residuals  # Pearson residuals\n Xsq$stdres     # standardized residuals\n \n \n ## Effect of simulating p-values\n x &lt;- matrix(c(12, 5, 7, 7), ncol = 2)\n chisq.test(x)$p.value           # 0.4233\n chisq.test(x, simulate.p.value = TRUE, B = 10000)$p.value\n                                 # around 0.29!\n \n ## Testing for population probabilities\n ## Case A. Tabulated data\n x &lt;- c(A = 20, B = 15, C = 25)\n chisq.test(x)\n chisq.test(as.table(x))             # the same\n x &lt;- c(89,37,30,28,2)\n p &lt;- c(40,20,20,15,5)\n try(\n chisq.test(x, p = p)                # gives an error\n )\n chisq.test(x, p = p, rescale.p = TRUE)\n                                 # works\n p &lt;- c(0.40,0.20,0.20,0.19,0.01)\n                                 # Expected count in category 5\n                                 # is 1.86 &lt; 5 ==&gt; chi square approx.\n chisq.test(x, p = p)            #               maybe doubtful, but is ok!\n chisq.test(x, p = p, simulate.p.value = TRUE)\n \n ## Case B. Raw data\n x &lt;- trunc(5 * runif(100))\n chisq.test(table(x))            # NOT 'chisq.test(x)'!"
  },
  {
    "objectID": "modules/Module09-DataAnalysis.html#chi-square-test-1",
    "href": "modules/Module09-DataAnalysis.html#chi-square-test-1",
    "title": "Module 9: Data Analysis",
    "section": "Chi-Square test",
    "text": "Chi-Square test\n\nchisq.test(freq)\n\n\n    Pearson's Chi-squared test\n\ndata:  freq\nX-squared = 175.85, df = 2, p-value &lt; 2.2e-16\n\n\nWe reject the null hypothesis that the proportion of seropositive individuals who are young (&lt;5yo) is the same for individuals who are middle (5-10yo) or old (&gt;10yo)."
  },
  {
    "objectID": "modules/Module09-DataAnalysis.html#correlation",
    "href": "modules/Module09-DataAnalysis.html#correlation",
    "title": "Module 9: Data Analysis",
    "section": "Correlation",
    "text": "Correlation\nFirst, we compute correlation by providing two vectors.\nLike other functions, if there are NAs, you get NA as the result. But if you specify use only the complete observations, then it will give you correlation using the non-missing data.\n\ncor(df$age, df$IgG_concentration, method=\"pearson\")\n\n[1] NA\n\ncor(df$age, df$IgG_concentration, method=\"pearson\", use = \"complete.obs\") #IF have missing data\n\n[1] 0.2604783\n\n\nSmall positive correlation between IgG concentration and age."
  },
  {
    "objectID": "modules/Module09-DataAnalysis.html#t-test",
    "href": "modules/Module09-DataAnalysis.html#t-test",
    "title": "Module 9: Data Analysis",
    "section": "T-test",
    "text": "T-test\nThe commonly used are:\n\none-sample t-test – used to test mean of a variable in one group (to the null hypothesis mean)\ntwo-sample t-test – used to test difference in means of a variable between two groups (null hypothesis - the group means are the same); if “two groups” are data of the same individuals collected at 2 time points, we say it is two-sample paired t-test"
  },
  {
    "objectID": "modules/Module09-DataAnalysis.html#t-test-1",
    "href": "modules/Module09-DataAnalysis.html#t-test-1",
    "title": "Module 9: Data Analysis",
    "section": "T-test",
    "text": "T-test\nWe can use the t.test() function from the stats package.\nStudent’s t-Test\nDescription:\n Performs one and two sample t-tests on vectors of data.\nUsage:\n t.test(x, ...)\n \n ## Default S3 method:\n t.test(x, y = NULL,\n        alternative = c(\"two.sided\", \"less\", \"greater\"),\n        mu = 0, paired = FALSE, var.equal = FALSE,\n        conf.level = 0.95, ...)\n \n ## S3 method for class 'formula'\n t.test(formula, data, subset, na.action, ...)\n \nArguments:\n   x: a (non-empty) numeric vector of data values.\n\n   y: an optional (non-empty) numeric vector of data values.\nalternative: a character string specifying the alternative hypothesis, must be one of ‘“two.sided”’ (default), ‘“greater”’ or ‘“less”’. You can specify just the initial letter.\n  mu: a number indicating the true value of the mean (or difference\n      in means if you are performing a two sample test).\npaired: a logical indicating whether you want a paired t-test.\nvar.equal: a logical variable indicating whether to treat the two variances as being equal. If ‘TRUE’ then the pooled variance is used to estimate the variance otherwise the Welch (or Satterthwaite) approximation to the degrees of freedom is used.\nconf.level: confidence level of the interval.\nformula: a formula of the form ‘lhs ~ rhs’ where ‘lhs’ is a numeric variable giving the data values and ‘rhs’ either ‘1’ for a one-sample or paired test or a factor with two levels giving the corresponding groups. If ‘lhs’ is of class ‘“Pair”’ and ‘rhs’ is ‘1’, a paired test is done.\ndata: an optional matrix or data frame (or similar: see\n      'model.frame') containing the variables in the formula\n      'formula'.  By default the variables are taken from\n      'environment(formula)'.\nsubset: an optional vector specifying a subset of observations to be used.\nna.action: a function which indicates what should happen when the data contain ‘NA’s. Defaults to ’getOption(“na.action”)’.\n ...: further arguments to be passed to or from methods.\nDetails:\n 'alternative = \"greater\"' is the alternative that 'x' has a larger\n mean than 'y'. For the one-sample case: that the mean is positive.\n\n If 'paired' is 'TRUE' then both 'x' and 'y' must be specified and\n they must be the same length.  Missing values are silently removed\n (in pairs if 'paired' is 'TRUE').  If 'var.equal' is 'TRUE' then\n the pooled estimate of the variance is used.  By default, if\n 'var.equal' is 'FALSE' then the variance is estimated separately\n for both groups and the Welch modification to the degrees of\n freedom is used.\n\n If the input data are effectively constant (compared to the larger\n of the two means) an error is generated.\nValue:\n A list with class '\"htest\"' containing the following components:\nstatistic: the value of the t-statistic.\nparameter: the degrees of freedom for the t-statistic.\np.value: the p-value for the test.\nconf.int: a confidence interval for the mean appropriate to the specified alternative hypothesis.\nestimate: the estimated mean or difference in means depending on whether it was a one-sample test or a two-sample test.\nnull.value: the specified hypothesized value of the mean or mean difference depending on whether it was a one-sample test or a two-sample test.\nstderr: the standard error of the mean (difference), used as denominator in the t-statistic formula.\nalternative: a character string describing the alternative hypothesis.\nmethod: a character string indicating what type of t-test was performed.\ndata.name: a character string giving the name(s) of the data.\nSee Also:\n 'prop.test'\nExamples:\n require(graphics)\n \n t.test(1:10, y = c(7:20))      # P = .00001855\n t.test(1:10, y = c(7:20, 200)) # P = .1245    -- NOT significant anymore\n \n ## Classical example: Student's sleep data\n plot(extra ~ group, data = sleep)\n ## Traditional interface\n with(sleep, t.test(extra[group == 1], extra[group == 2]))\n \n ## Formula interface\n t.test(extra ~ group, data = sleep)\n \n ## Formula interface to one-sample test\n t.test(extra ~ 1, data = sleep)\n \n ## Formula interface to paired test\n ## The sleep data are actually paired, so could have been in wide format:\n sleep2 &lt;- reshape(sleep, direction = \"wide\", \n                   idvar = \"ID\", timevar = \"group\")\n t.test(Pair(extra.1, extra.2) ~ 1, data = sleep2)"
  },
  {
    "objectID": "modules/Module09-DataAnalysis.html#running-two-sample-t-test",
    "href": "modules/Module09-DataAnalysis.html#running-two-sample-t-test",
    "title": "Module 9: Data Analysis",
    "section": "Running two-sample t-test",
    "text": "Running two-sample t-test\nThe base R - t.test() function from the stats package. It tests test difference in means of a variable between two groups. By default:\n\ntests whether difference in means of a variable is equal to 0 (default mu=0)\nuses “two sided” alternative (alternative = \"two.sided\")\nreturns result assuming confidence level 0.95 (conf.level = 0.95)\nassumes data are not paired (paired = FALSE)\nassumes true variance in the two groups is not equal (var.equal = FALSE)"
  },
  {
    "objectID": "modules/Module09-DataAnalysis.html#running-two-sample-t-test-1",
    "href": "modules/Module09-DataAnalysis.html#running-two-sample-t-test-1",
    "title": "Module 9: Data Analysis",
    "section": "Running two-sample t-test",
    "text": "Running two-sample t-test\n\nIgG_young &lt;- df$IgG_concentration[df$age_group==\"young\"]\nIgG_old &lt;- df$IgG_concentration[df$age_group==\"old\"]\n\nt.test(IgG_young, IgG_old)\n\n\n    Welch Two Sample t-test\n\ndata:  IgG_young and IgG_old\nt = -6.1969, df = 259.54, p-value = 2.25e-09\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -111.09281  -57.51515\nsample estimates:\nmean of x mean of y \n 45.05056 129.35454 \n\n\nThe mean IgG concenration of young and old is 45.05 and 129.35 mIU/mL, respectively. We reject null hypothesis that the difference in the mean IgG concentration of young and old is 0 mIU/mL."
  },
  {
    "objectID": "modules/Module09-DataAnalysis.html#linear-regression-fit-in-r",
    "href": "modules/Module09-DataAnalysis.html#linear-regression-fit-in-r",
    "title": "Module 9: Data Analysis",
    "section": "Linear regression fit in R",
    "text": "Linear regression fit in R\nTo fit regression models in R, we use the function glm() (Generalized Linear Model).\nFitting Generalized Linear Models\nDescription:\n 'glm' is used to fit generalized linear models, specified by\n giving a symbolic description of the linear predictor and a\n description of the error distribution.\nUsage:\n glm(formula, family = gaussian, data, weights, subset,\n     na.action, start = NULL, etastart, mustart, offset,\n     control = list(...), model = TRUE, method = \"glm.fit\",\n     x = FALSE, y = TRUE, singular.ok = TRUE, contrasts = NULL, ...)\n \n glm.fit(x, y, weights = rep.int(1, nobs),\n         start = NULL, etastart = NULL, mustart = NULL,\n         offset = rep.int(0, nobs), family = gaussian(),\n         control = list(), intercept = TRUE, singular.ok = TRUE)\n \n ## S3 method for class 'glm'\n weights(object, type = c(\"prior\", \"working\"), ...)\n \nArguments:\nformula: an object of class ‘“formula”’ (or one that can be coerced to that class): a symbolic description of the model to be fitted. The details of model specification are given under ‘Details’.\nfamily: a description of the error distribution and link function to be used in the model. For ‘glm’ this can be a character string naming a family function, a family function or the result of a call to a family function. For ‘glm.fit’ only the third option is supported. (See ‘family’ for details of family functions.)\ndata: an optional data frame, list or environment (or object\n      coercible by 'as.data.frame' to a data frame) containing the\n      variables in the model.  If not found in 'data', the\n      variables are taken from 'environment(formula)', typically\n      the environment from which 'glm' is called.\nweights: an optional vector of ‘prior weights’ to be used in the fitting process. Should be ‘NULL’ or a numeric vector.\nsubset: an optional vector specifying a subset of observations to be used in the fitting process.\nna.action: a function which indicates what should happen when the data contain ‘NA’s. The default is set by the ’na.action’ setting of ‘options’, and is ‘na.fail’ if that is unset. The ‘factory-fresh’ default is ‘na.omit’. Another possible value is ‘NULL’, no action. Value ‘na.exclude’ can be useful.\nstart: starting values for the parameters in the linear predictor.\netastart: starting values for the linear predictor.\nmustart: starting values for the vector of means.\noffset: this can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be ‘NULL’ or a numeric vector of length equal to the number of cases. One or more ‘offset’ terms can be included in the formula instead or as well, and if more than one is specified their sum is used. See ‘model.offset’.\ncontrol: a list of parameters for controlling the fitting process. For ‘glm.fit’ this is passed to ‘glm.control’.\nmodel: a logical value indicating whether model frame should be included as a component of the returned value.\nmethod: the method to be used in fitting the model. The default method ‘“glm.fit”’ uses iteratively reweighted least squares (IWLS): the alternative ‘“model.frame”’ returns the model frame and does no fitting.\n      User-supplied fitting functions can be supplied either as a\n      function or a character string naming a function, with a\n      function which takes the same arguments as 'glm.fit'.  If\n      specified as a character string it is looked up from within\n      the 'stats' namespace.\n\nx, y: For 'glm': logical values indicating whether the response\n      vector and model matrix used in the fitting process should be\n      returned as components of the returned value.\n\n      For 'glm.fit': 'x' is a design matrix of dimension 'n * p',\n      and 'y' is a vector of observations of length 'n'.\nsingular.ok: logical; if ‘FALSE’ a singular fit is an error.\ncontrasts: an optional list. See the ‘contrasts.arg’ of ‘model.matrix.default’.\nintercept: logical. Should an intercept be included in the null model?\nobject: an object inheriting from class ‘“glm”’.\ntype: character, partial matching allowed.  Type of weights to\n      extract from the fitted model object.  Can be abbreviated.\n\n ...: For 'glm': arguments to be used to form the default 'control'\n      argument if it is not supplied directly.\n\n      For 'weights': further arguments passed to or from other\n      methods.\nDetails:\n A typical predictor has the form 'response ~ terms' where\n 'response' is the (numeric) response vector and 'terms' is a\n series of terms which specifies a linear predictor for 'response'.\n For 'binomial' and 'quasibinomial' families the response can also\n be specified as a 'factor' (when the first level denotes failure\n and all others success) or as a two-column matrix with the columns\n giving the numbers of successes and failures.  A terms\n specification of the form 'first + second' indicates all the terms\n in 'first' together with all the terms in 'second' with any\n duplicates removed.\n\n A specification of the form 'first:second' indicates the set of\n terms obtained by taking the interactions of all terms in 'first'\n with all terms in 'second'.  The specification 'first*second'\n indicates the _cross_ of 'first' and 'second'.  This is the same\n as 'first + second + first:second'.\n\n The terms in the formula will be re-ordered so that main effects\n come first, followed by the interactions, all second-order, all\n third-order and so on: to avoid this pass a 'terms' object as the\n formula.\n\n Non-'NULL' 'weights' can be used to indicate that different\n observations have different dispersions (with the values in\n 'weights' being inversely proportional to the dispersions); or\n equivalently, when the elements of 'weights' are positive integers\n w_i, that each response y_i is the mean of w_i unit-weight\n observations.  For a binomial GLM prior weights are used to give\n the number of trials when the response is the proportion of\n successes: they would rarely be used for a Poisson GLM.\n\n 'glm.fit' is the workhorse function: it is not normally called\n directly but can be more efficient where the response vector,\n design matrix and family have already been calculated.\n\n If more than one of 'etastart', 'start' and 'mustart' is\n specified, the first in the list will be used.  It is often\n advisable to supply starting values for a 'quasi' family, and also\n for families with unusual links such as 'gaussian(\"log\")'.\n\n All of 'weights', 'subset', 'offset', 'etastart' and 'mustart' are\n evaluated in the same way as variables in 'formula', that is first\n in 'data' and then in the environment of 'formula'.\n\n For the background to warning messages about 'fitted probabilities\n numerically 0 or 1 occurred' for binomial GLMs, see Venables &\n Ripley (2002, pp. 197-8).\nValue:\n 'glm' returns an object of class inheriting from '\"glm\"' which\n inherits from the class '\"lm\"'. See later in this section.  If a\n non-standard 'method' is used, the object will also inherit from\n the class (if any) returned by that function.\n\n The function 'summary' (i.e., 'summary.glm') can be used to obtain\n or print a summary of the results and the function 'anova' (i.e.,\n 'anova.glm') to produce an analysis of variance table.\n\n The generic accessor functions 'coefficients', 'effects',\n 'fitted.values' and 'residuals' can be used to extract various\n useful features of the value returned by 'glm'.\n\n 'weights' extracts a vector of weights, one for each case in the\n fit (after subsetting and 'na.action').\n\n An object of class '\"glm\"' is a list containing at least the\n following components:\ncoefficients: a named vector of coefficients\nresiduals: the working residuals, that is the residuals in the final iteration of the IWLS fit. Since cases with zero weights are omitted, their working residuals are ‘NA’.\nfitted.values: the fitted mean values, obtained by transforming the linear predictors by the inverse of the link function.\nrank: the numeric rank of the fitted linear model.\nfamily: the ‘family’ object used.\nlinear.predictors: the linear fit on link scale.\ndeviance: up to a constant, minus twice the maximized log-likelihood. Where sensible, the constant is chosen so that a saturated model has deviance zero.\n aic: A version of Akaike's _An Information Criterion_, minus twice\n      the maximized log-likelihood plus twice the number of\n      parameters, computed via the 'aic' component of the family.\n      For binomial and Poison families the dispersion is fixed at\n      one and the number of parameters is the number of\n      coefficients.  For gaussian, Gamma and inverse gaussian\n      families the dispersion is estimated from the residual\n      deviance, and the number of parameters is the number of\n      coefficients plus one.  For a gaussian family the MLE of the\n      dispersion is used so this is a valid value of AIC, but for\n      Gamma and inverse gaussian families it is not.  For families\n      fitted by quasi-likelihood the value is 'NA'.\nnull.deviance: The deviance for the null model, comparable with ‘deviance’. The null model will include the offset, and an intercept if there is one in the model. Note that this will be incorrect if the link function depends on the data other than through the fitted mean: specify a zero offset to force a correct calculation.\niter: the number of iterations of IWLS used.\nweights: the working weights, that is the weights in the final iteration of the IWLS fit.\nprior.weights: the weights initially supplied, a vector of ’1’s if none were.\ndf.residual: the residual degrees of freedom.\ndf.null: the residual degrees of freedom for the null model.\n   y: if requested (the default) the 'y' vector used. (It is a\n      vector even for a binomial model.)\n\n   x: if requested, the model matrix.\nmodel: if requested (the default), the model frame.\nconverged: logical. Was the IWLS algorithm judged to have converged?\nboundary: logical. Is the fitted value on the boundary of the attainable values?\ncall: the matched call.\nformula: the formula supplied.\nterms: the ‘terms’ object used.\ndata: the 'data argument'.\noffset: the offset vector used.\ncontrol: the value of the ‘control’ argument used.\nmethod: the name of the fitter function used (when provided as a ‘character’ string to ‘glm()’) or the fitter ‘function’ (when provided as that).\ncontrasts: (where relevant) the contrasts used.\nxlevels: (where relevant) a record of the levels of the factors used in fitting.\nna.action: (where relevant) information returned by ‘model.frame’ on the special handling of ’NA’s.\n In addition, non-empty fits will have components 'qr', 'R' and\n 'effects' relating to the final weighted linear fit.\n\n Objects of class '\"glm\"' are normally of class 'c(\"glm\", \"lm\")',\n that is inherit from class '\"lm\"', and well-designed methods for\n class '\"lm\"' will be applied to the weighted linear model at the\n final iteration of IWLS.  However, care is needed, as extractor\n functions for class '\"glm\"' such as 'residuals' and 'weights' do\n *not* just pick out the component of the fit with the same name.\n\n If a 'binomial' 'glm' model was specified by giving a two-column\n response, the weights returned by 'prior.weights' are the total\n numbers of cases (factored by the supplied case weights) and the\n component 'y' of the result is the proportion of successes.\nFitting functions:\n The argument 'method' serves two purposes.  One is to allow the\n model frame to be recreated with no fitting.  The other is to\n allow the default fitting function 'glm.fit' to be replaced by a\n function which takes the same arguments and uses a different\n fitting algorithm.  If 'glm.fit' is supplied as a character string\n it is used to search for a function of that name, starting in the\n 'stats' namespace.\n\n The class of the object return by the fitter (if any) will be\n prepended to the class returned by 'glm'.\nAuthor(s):\n The original R implementation of 'glm' was written by Simon Davies\n working for Ross Ihaka at the University of Auckland, but has\n since been extensively re-written by members of the R Core team.\n\n The design was inspired by the S function of the same name\n described in Hastie & Pregibon (1992).\nReferences:\n Dobson, A. J. (1990) _An Introduction to Generalized Linear\n Models._ London: Chapman and Hall.\n\n Hastie, T. J. and Pregibon, D. (1992) _Generalized linear models._\n Chapter 6 of _Statistical Models in S_ eds J. M. Chambers and T.\n J. Hastie, Wadsworth & Brooks/Cole.\n\n McCullagh P. and Nelder, J. A. (1989) _Generalized Linear Models._\n London: Chapman and Hall.\n\n Venables, W. N. and Ripley, B. D. (2002) _Modern Applied\n Statistics with S._ New York: Springer.\nSee Also:\n 'anova.glm', 'summary.glm', etc. for 'glm' methods, and the\n generic functions 'anova', 'summary', 'effects', 'fitted.values',\n and 'residuals'.\n\n 'lm' for non-generalized _linear_ models (which SAS calls GLMs,\n for 'general' linear models).\n\n 'loglin' and 'loglm' (package 'MASS') for fitting log-linear\n models (which binomial and Poisson GLMs are) to contingency\n tables.\n\n 'bigglm' in package 'biglm' for an alternative way to fit GLMs to\n large datasets (especially those with many cases).\n\n 'esoph', 'infert' and 'predict.glm' have examples of fitting\n binomial glms.\nExamples:\n ## Dobson (1990) Page 93: Randomized Controlled Trial :\n counts &lt;- c(18,17,15,20,10,20,25,13,12)\n outcome &lt;- gl(3,1,9)\n treatment &lt;- gl(3,3)\n data.frame(treatment, outcome, counts) # showing data\n glm.D93 &lt;- glm(counts ~ outcome + treatment, family = poisson())\n anova(glm.D93)\n summary(glm.D93)\n ## Computing AIC [in many ways]:\n (A0 &lt;- AIC(glm.D93))\n (ll &lt;- logLik(glm.D93))\n A1 &lt;- -2*c(ll) + 2*attr(ll, \"df\")\n A2 &lt;- glm.D93$family$aic(counts, mu=fitted(glm.D93), wt=1) +\n         2 * length(coef(glm.D93))\n stopifnot(exprs = {\n   all.equal(A0, A1)\n   all.equal(A1, A2)\n   all.equal(A1, glm.D93$aic)\n })\n \n \n ## an example with offsets from Venables & Ripley (2002, p.189)\n utils::data(anorexia, package = \"MASS\")\n \n anorex.1 &lt;- glm(Postwt ~ Prewt + Treat + offset(Prewt),\n                 family = gaussian, data = anorexia)\n summary(anorex.1)\n \n \n # A Gamma example, from McCullagh & Nelder (1989, pp. 300-2)\n clotting &lt;- data.frame(\n     u = c(5,10,15,20,30,40,60,80,100),\n     lot1 = c(118,58,42,35,27,25,21,19,18),\n     lot2 = c(69,35,26,21,18,16,13,12,12))\n summary(glm(lot1 ~ log(u), data = clotting, family = Gamma))\n summary(glm(lot2 ~ log(u), data = clotting, family = Gamma))\n ## Aliased (\"S\"ingular) -&gt; 1 NA coefficient\n (fS &lt;- glm(lot2 ~ log(u) + log(u^2), data = clotting, family = Gamma))\n tools::assertError(update(fS, singular.ok=FALSE), verbose=interactive())\n ## -&gt; .. \"singular fit encountered\"\n \n ## Not run:\n \n ## for an example of the use of a terms object as a formula\n demo(glm.vr)\n ## End(Not run)"
  },
  {
    "objectID": "modules/Module09-DataAnalysis.html#linear-regression-fit-in-r-1",
    "href": "modules/Module09-DataAnalysis.html#linear-regression-fit-in-r-1",
    "title": "Module 9: Data Analysis",
    "section": "Linear regression fit in R",
    "text": "Linear regression fit in R\nWe tend to focus on three arguments:\n\nformula – model formula written using names of columns in our data\ndata – our data frame\n  `family` -- error distribution and link function\n\n\nfit1 &lt;- glm(IgG_concentration~age+gender+slum, data=df, family=gaussian())\nfit2 &lt;- glm(seropos~age_group+gender+slum, data=df, family = binomial(link = \"logit\"))"
  },
  {
    "objectID": "modules/Module09-DataAnalysis.html#summary.glm",
    "href": "modules/Module09-DataAnalysis.html#summary.glm",
    "title": "Module 9: Data Analysis",
    "section": "summary.glm()",
    "text": "summary.glm()\nThe summary() function when applied to a fit object based on a glm is technically the summary.glm() function and produces details of the model fit. Note on object oriented code.\n\nSummarizing Generalized Linear Model Fits\nDescription:\n These functions are all 'methods' for class 'glm' or 'summary.glm'\n objects.\nUsage:\n ## S3 method for class 'glm'\n summary(object, dispersion = NULL, correlation = FALSE,\n         symbolic.cor = FALSE, ...)\n \n ## S3 method for class 'summary.glm'\n print(x, digits = max(3, getOption(\"digits\") - 3),\n       symbolic.cor = x$symbolic.cor,\n       signif.stars = getOption(\"show.signif.stars\"),\n       show.residuals = FALSE, ...)\n \nArguments:\nobject: an object of class ‘“glm”’, usually, a result of a call to ‘glm’.\n   x: an object of class '\"summary.glm\"', usually, a result of a\n      call to 'summary.glm'.\ndispersion: the dispersion parameter for the family used. Either a single numerical value or ‘NULL’ (the default), when it is inferred from ‘object’ (see ‘Details’).\ncorrelation: logical; if ‘TRUE’, the correlation matrix of the estimated parameters is returned and printed.\ndigits: the number of significant digits to use when printing.\nsymbolic.cor: logical. If ‘TRUE’, print the correlations in a symbolic form (see ‘symnum’) rather than as numbers.\nsignif.stars: logical. If ‘TRUE’, ‘significance stars’ are printed for each coefficient.\nshow.residuals: logical. If ‘TRUE’ then a summary of the deviance residuals is printed at the head of the output.\n ...: further arguments passed to or from other methods.\nDetails:\n 'print.summary.glm' tries to be smart about formatting the\n coefficients, standard errors, etc. and additionally gives\n 'significance stars' if 'signif.stars' is 'TRUE'.  The\n 'coefficients' component of the result gives the estimated\n coefficients and their estimated standard errors, together with\n their ratio.  This third column is labelled 't ratio' if the\n dispersion is estimated, and 'z ratio' if the dispersion is known\n (or fixed by the family).  A fourth column gives the two-tailed\n p-value corresponding to the t or z ratio based on a Student t or\n Normal reference distribution.  (It is possible that the\n dispersion is not known and there are no residual degrees of\n freedom from which to estimate it.  In that case the estimate is\n 'NaN'.)\n\n Aliased coefficients are omitted in the returned object but\n restored by the 'print' method.\n\n Correlations are printed to two decimal places (or symbolically):\n to see the actual correlations print 'summary(object)$correlation'\n directly.\n\n The dispersion of a GLM is not used in the fitting process, but it\n is needed to find standard errors.  If 'dispersion' is not\n supplied or 'NULL', the dispersion is taken as '1' for the\n 'binomial' and 'Poisson' families, and otherwise estimated by the\n residual Chisquared statistic (calculated from cases with non-zero\n weights) divided by the residual degrees of freedom.\n\n 'summary' can be used with Gaussian 'glm' fits to handle the case\n of a linear regression with known error variance, something not\n handled by 'summary.lm'.\nValue:\n 'summary.glm' returns an object of class '\"summary.glm\"', a list\n with components\n\ncall: the component from 'object'.\nfamily: the component from ‘object’.\ndeviance: the component from ‘object’.\ncontrasts: the component from ‘object’.\ndf.residual: the component from ‘object’.\nnull.deviance: the component from ‘object’.\ndf.null: the component from ‘object’.\ndeviance.resid: the deviance residuals: see ‘residuals.glm’.\ncoefficients: the matrix of coefficients, standard errors, z-values and p-values. Aliased coefficients are omitted.\naliased: named logical vector showing if the original coefficients are aliased.\ndispersion: either the supplied argument or the inferred/estimated dispersion if the former is ‘NULL’.\n  df: a 3-vector of the rank of the model and the number of\n      residual degrees of freedom, plus number of coefficients\n      (including aliased ones).\ncov.unscaled: the unscaled (‘dispersion = 1’) estimated covariance matrix of the estimated coefficients.\ncov.scaled: ditto, scaled by ‘dispersion’.\ncorrelation: (only if ‘correlation’ is true.) The estimated correlations of the estimated coefficients.\nsymbolic.cor: (only if ‘correlation’ is true.) The value of the argument ‘symbolic.cor’.\nSee Also:\n 'glm', 'summary'.\nExamples:\n ## For examples see example(glm)"
  },
  {
    "objectID": "modules/Module09-DataAnalysis.html#linear-regression-fit-in-r-2",
    "href": "modules/Module09-DataAnalysis.html#linear-regression-fit-in-r-2",
    "title": "Module 9: Data Analysis",
    "section": "Linear regression fit in R",
    "text": "Linear regression fit in R\nLets look at the output…\n\nsummary(fit1)\n\n\nCall:\nglm(formula = IgG_concentration ~ age + gender + slum, family = gaussian(), \n    data = df)\n\nCoefficients:\n             Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)    46.132     16.774   2.750  0.00613 ** \nage             9.324      1.388   6.718 4.15e-11 ***\ngenderMale     -9.655     11.543  -0.836  0.40321    \nslumNon slum  -20.353     14.299  -1.423  0.15513    \nslumSlum      -29.705     25.009  -1.188  0.23536    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for gaussian family taken to be 20918.39)\n\n    Null deviance: 14141483  on 631  degrees of freedom\nResidual deviance: 13115831  on 627  degrees of freedom\n  (19 observations deleted due to missingness)\nAIC: 8087.9\n\nNumber of Fisher Scoring iterations: 2\n\nsummary(fit2)\n\n\nCall:\nglm(formula = seropos ~ age_group + gender + slum, family = binomial(link = \"logit\"), \n    data = df)\n\nCoefficients:\n                Estimate Std. Error z value Pr(&gt;|z|)    \n(Intercept)      -1.3220     0.2516  -5.254 1.49e-07 ***\nage_groupmiddle   1.9020     0.2133   8.916  &lt; 2e-16 ***\nage_groupold      2.8443     0.2522  11.278  &lt; 2e-16 ***\ngenderMale       -0.1725     0.1895  -0.910    0.363    \nslumNon slum     -0.1099     0.2329  -0.472    0.637    \nslumSlum         -0.1073     0.4118  -0.261    0.794    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 866.98  on 631  degrees of freedom\nResidual deviance: 679.10  on 626  degrees of freedom\n  (19 observations deleted due to missingness)\nAIC: 691.1\n\nNumber of Fisher Scoring iterations: 4"
  },
  {
    "objectID": "modules/Module09-DataAnalysis.html#summary",
    "href": "modules/Module09-DataAnalysis.html#summary",
    "title": "Module 9: Data Analysis",
    "section": "Summary",
    "text": "Summary\n\n  Use `cor()` to calculate correlation between two numeric vectors.\ncorrplot() and ggpairs() is nice for a quick visualization of correlations\nt.test() or t_test() tests the mean compared to null or difference in means between two groups\n  ... xxamy more"
  },
  {
    "objectID": "modules/Module09-DataAnalysis.html#acknowledgements",
    "href": "modules/Module09-DataAnalysis.html#acknowledgements",
    "title": "Module 9: Data Analysis",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nThese are the materials I looked through, modified, or extracted to complete this module’s lecture.\n\n“Introduction to R for Public Health Researchers” Johns Hopkins University"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#learning-objectives",
    "href": "modules/Module10-DataVisualization.html#learning-objectives",
    "title": "Module 10: Data Visualization",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nAfter module 10, you should be able to…\n\n  Create Base R plots"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#import-data-for-this-module",
    "href": "modules/Module10-DataVisualization.html#import-data-for-this-module",
    "title": "Module 10: Data Visualization",
    "section": "Import data for this module",
    "text": "Import data for this module\nLet’s read in our data (again) and take a quick look.\n\ndf &lt;- read.csv(file = \"data/serodata.csv\") #relative path\nhead(x=df, n=3)\n\n  observation_id IgG_concentration age gender     slum\n1           5772         0.3176895   2 Female Non slum\n2           8095         3.4368231   4 Female Non slum\n3           9784         0.3000000   4   Male Non slum"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#prep-data",
    "href": "modules/Module10-DataVisualization.html#prep-data",
    "title": "Module 10: Data Visualization",
    "section": "Prep data",
    "text": "Prep data\nCreate age_group three level factor variable\n\ndf$age_group &lt;- ifelse(df$age &lt;= 5, \"young\", \n                       ifelse(df$age&lt;=10 & df$age&gt;5, \"middle\", \n                              ifelse(df$age&gt;10, \"old\", NA)))\ndf$age_group &lt;- factor(df$age_group, levels=c(\"young\", \"middle\", \"old\"))\n\nCreate seropos binary variable representing seropositivity if antibody concentrations are &gt;10 mIUmL.\n\ndf$seropos &lt;- ifelse(df$IgG_concentration&lt;10, 0, \n                                        ifelse(df$IgG_concentration&gt;=10, 1, NA))"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#base-r-data-visualizattion-functions",
    "href": "modules/Module10-DataVisualization.html#base-r-data-visualizattion-functions",
    "title": "Module 10: Data Visualization",
    "section": "Base R data visualizattion functions",
    "text": "Base R data visualizattion functions\nThe Base R ‘graphics’ package has a ton of graphics options.\nRegistered S3 method overwritten by 'printr':\n  method                from     \n  knit_print.data.frame rmarkdown\nThe R Graphics Package\nDescription:\n R functions for base graphics\nDetails:\n This package contains functions for 'base' graphics.  Base\n graphics are traditional S-like graphics, as opposed to the more\n recent grid graphics.\n\n For a complete list of functions with individual help pages, use\n 'library(help = \"graphics\")'.\nAuthor(s):\n R Core Team and contributors worldwide\n\n Maintainer: R Core Team &lt;mailto:R-core@r-project.org&gt;\nReferences:\n Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S\n Language_.  Wadsworth & Brooks/Cole.\n\n Murrell, P. (2005) _R Graphics_. Chapman & Hall/CRC Press.     Information on package 'graphics'\nDescription:\nPackage: graphics Version: 4.3.1 Priority: base Title: The R Graphics Package Author: R Core Team and contributors worldwide Maintainer: R Core Team do-use-Contact-address@r-project.org Contact: R-help mailing list r-help@r-project.org Description: R functions for base graphics. Imports: grDevices License: Part of R 4.3.1 NeedsCompilation: yes Built: R 4.3.1; aarch64-apple-darwin20; 2023-06-16 21:53:01 UTC; unix\nIndex:\nAxis Generic Function to Add an Axis to a Plot abline Add Straight Lines to a Plot arrows Add Arrows to a Plot assocplot Association Plots axTicks Compute Axis Tickmark Locations axis Add an Axis to a Plot axis.POSIXct Date and Date-time Plotting Functions barplot Bar Plots box Draw a Box around a Plot boxplot Box Plots boxplot.matrix Draw a Boxplot for each Column (Row) of a Matrix bxp Draw Box Plots from Summaries cdplot Conditional Density Plots clip Set Clipping Region contour Display Contours coplot Conditioning Plots curve Draw Function Plots dotchart Cleveland’s Dot Plots filled.contour Level (Contour) Plots fourfoldplot Fourfold Plots frame Create / Start a New Plot Frame graphics-package The R Graphics Package grconvertX Convert between Graphics Coordinate Systems grid Add Grid to a Plot hist Histograms hist.POSIXt Histogram of a Date or Date-Time Object identify Identify Points in a Scatter Plot image Display a Color Image layout Specifying Complex Plot Arrangements legend Add Legends to Plots lines Add Connected Line Segments to a Plot locator Graphical Input matplot Plot Columns of Matrices mosaicplot Mosaic Plots mtext Write Text into the Margins of a Plot pairs Scatterplot Matrices panel.smooth Simple Panel Plot par Set or Query Graphical Parameters persp Perspective Plots pie Pie Charts plot.data.frame Plot Method for Data Frames plot.default The Default Scatterplot Function plot.design Plot Univariate Effects of a Design or Model plot.factor Plotting Factor Variables plot.formula Formula Notation for Scatterplots plot.histogram Plot Histograms plot.raster Plotting Raster Images plot.table Plot Methods for ‘table’ Objects plot.window Set up World Coordinates for Graphics Window plot.xy Basic Internal Plot Function points Add Points to a Plot polygon Polygon Drawing polypath Path Drawing rasterImage Draw One or More Raster Images rect Draw One or More Rectangles rug Add a Rug to a Plot screen Creating and Controlling Multiple Screens on a Single Device segments Add Line Segments to a Plot smoothScatter Scatterplots with Smoothed Densities Color Representation spineplot Spine Plots and Spinograms stars Star (Spider/Radar) Plots and Segment Diagrams stem Stem-and-Leaf Plots stripchart 1-D Scatter Plots strwidth Plotting Dimensions of Character Strings and Math Expressions sunflowerplot Produce a Sunflower Scatter Plot symbols Draw Symbols (Circles, Squares, Stars, Thermometers, Boxplots) text Add Text to a Plot title Plot Annotation xinch Graphical Units xspline Draw an X-spline\nhist() displays histogram of one variable plot() displays x-y plot of two variables"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#summary",
    "href": "modules/Module10-DataVisualization.html#summary",
    "title": "Module 10: Data Visualization",
    "section": "Summary",
    "text": "Summary"
  },
  {
    "objectID": "modules/Module10-DataVisualization.html#acknowledgements",
    "href": "modules/Module10-DataVisualization.html#acknowledgements",
    "title": "Module 10: Data Visualization",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nThese are the materials I looked through, modified, or extracted to complete this module’s lecture.\n\n“Introduction to R for Public Health Researchers” Johns Hopkins University"
  }
]